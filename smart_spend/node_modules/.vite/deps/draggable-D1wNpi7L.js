import { n as __export } from "./chunk-DUEDWNxO.js";

//#region node_modules/animejs/dist/modules/core/consts.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
var isBrowser = typeof window !== "undefined";
/** @type {Window & {AnimeJS: Array}|null} */
var win = isBrowser ? window : null;
/** @type {Document|null} */
var doc = isBrowser ? document : null;
/** @enum {Number} */
var tweenTypes = {
	OBJECT: 0,
	ATTRIBUTE: 1,
	CSS: 2,
	TRANSFORM: 3,
	CSS_VAR: 4
};
/** @enum {Number} */
var valueTypes = {
	NUMBER: 0,
	UNIT: 1,
	COLOR: 2,
	COMPLEX: 3
};
/** @enum {Number} */
var tickModes = {
	NONE: 0,
	AUTO: 1,
	FORCE: 2
};
/** @enum {Number} */
var compositionTypes = {
	replace: 0,
	none: 1,
	blend: 2
};
var isRegisteredTargetSymbol = Symbol();
var isDomSymbol = Symbol();
var isSvgSymbol = Symbol();
var transformsSymbol = Symbol();
var morphPointsSymbol = Symbol();
var proxyTargetSymbol = Symbol();
var minValue = 1e-11;
var maxValue = 0xe8d4a51000;
var K = 1e3;
var maxFps = 120;
var emptyString = "";
var cssVarPrefix = "var(";
var shortTransforms = /* @__PURE__ */ (() => {
	const map = /* @__PURE__ */ new Map();
	map.set("x", "translateX");
	map.set("y", "translateY");
	map.set("z", "translateZ");
	return map;
})();
var validTransforms = [
	"translateX",
	"translateY",
	"translateZ",
	"rotate",
	"rotateX",
	"rotateY",
	"rotateZ",
	"scale",
	"scaleX",
	"scaleY",
	"scaleZ",
	"skew",
	"skewX",
	"skewY",
	"matrix",
	"matrix3d",
	"perspective"
];
var transformsFragmentStrings = /* @__PURE__ */ validTransforms.reduce((a, v) => ({
	...a,
	[v]: v + "("
}), {});
/** @return {void} */
var noop = () => {};
var hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
var rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
var rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
var hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
var hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
var digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
var unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
var lowerCaseRgx = /([a-z])([A-Z])/g;
var transformsExecRgx = /(\w+)(\([^)]+\)+)/g;
var relativeValuesExecRgx = /(\*=|\+=|-=)/;
var cssVariableMatchRgx = /var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/;

//#endregion
//#region node_modules/animejs/dist/modules/core/globals.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DefaultsParams,
*   DOMTarget,
* } from '../types/index.js'
*
* @import {
*   Scope,
* } from '../scope/index.js'
*/
/** @type {DefaultsParams} */
var defaults = {
	id: null,
	keyframes: null,
	playbackEase: null,
	playbackRate: 1,
	frameRate: maxFps,
	loop: 0,
	reversed: false,
	alternate: false,
	autoplay: true,
	persist: false,
	duration: K,
	delay: 0,
	loopDelay: 0,
	ease: "out(2)",
	composition: compositionTypes.replace,
	modifier: (v) => v,
	onBegin: noop,
	onBeforeUpdate: noop,
	onUpdate: noop,
	onLoop: noop,
	onPause: noop,
	onComplete: noop,
	onRender: noop
};
var scope = {
	current: null,
	root: doc
};
var globals = {
	defaults,
	precision: 4,
	timeScale: 1,
	tickThreshold: 200
};
var globalVersions = {
	version: "4.2.2",
	engine: null
};
if (isBrowser) {
	if (!win.AnimeJS) win.AnimeJS = [];
	win.AnimeJS.push(globalVersions);
}

//#endregion
//#region node_modules/animejs/dist/modules/core/helpers.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Target,
*   DOMTarget,
* } from '../types/index.js'
*/
/**
* @param  {String} str
* @return {String}
*/
var toLowerCase = (str) => str.replace(lowerCaseRgx, "$1-$2").toLowerCase();
/**
* Prioritize this method instead of regex when possible
* @param  {String} str
* @param  {String} sub
* @return {Boolean}
*/
var stringStartsWith = (str, sub) => str.indexOf(sub) === 0;
var now = Date.now;
var isArr = Array.isArray;
/**@param {any} a @return {a is Record<String, any>} */
var isObj = (a) => a && a.constructor === Object;
/**@param {any} a @return {a is Number} */
var isNum = (a) => typeof a === "number" && !isNaN(a);
/**@param {any} a @return {a is String} */
var isStr = (a) => typeof a === "string";
/**@param {any} a @return {a is Function} */
var isFnc = (a) => typeof a === "function";
/**@param {any} a @return {a is undefined} */
var isUnd = (a) => typeof a === "undefined";
/**@param {any} a @return {a is null | undefined} */
var isNil = (a) => isUnd(a) || a === null;
/**@param {any} a @return {a is SVGElement} */
var isSvg = (a) => isBrowser && a instanceof SVGElement;
/**@param {any} a @return {Boolean} */
var isHex = (a) => hexTestRgx.test(a);
/**@param {any} a @return {Boolean} */
var isRgb = (a) => stringStartsWith(a, "rgb");
/**@param {any} a @return {Boolean} */
var isHsl = (a) => stringStartsWith(a, "hsl");
/**@param {any} a @return {Boolean} */
var isCol = (a) => isHex(a) || isRgb(a) || isHsl(a);
/**@param {any} a @return {Boolean} */
var isKey = (a) => !globals.defaults.hasOwnProperty(a);
var svgCssReservedProperties = [
	"opacity",
	"rotate",
	"overflow",
	"color"
];
/**
* @param  {Target} el
* @param  {String} propertyName
* @return {Boolean}
*/
var isValidSVGAttribute = (el, propertyName) => {
	if (svgCssReservedProperties.includes(propertyName)) return false;
	if (el.getAttribute(propertyName) || propertyName in el) {
		if (propertyName === "scale") {
			const elParentNode = el.parentNode;
			return elParentNode && elParentNode.tagName === "filter";
		}
		return true;
	}
};
/**
* @param  {Number|String} str
* @return {Number}
*/
var parseNumber = (str) => isStr(str) ? parseFloat(str) : str;
var pow = Math.pow;
var sqrt = Math.sqrt;
var sin = Math.sin;
var cos = Math.cos;
var abs = Math.abs;
var exp = Math.exp;
var ceil = Math.ceil;
var floor = Math.floor;
var asin = Math.asin;
var max = Math.max;
var atan2 = Math.atan2;
var PI = Math.PI;
var _round = Math.round;
/**
* Clamps a value between min and max bounds
*
* @param  {Number} v - Value to clamp
* @param  {Number} min - Minimum boundary
* @param  {Number} max - Maximum boundary
* @return {Number}
*/
var clamp = (v, min, max$1) => v < min ? min : v > max$1 ? max$1 : v;
var powCache = {};
/**
* Rounds a number to specified decimal places
*
* @param  {Number} v - Value to round
* @param  {Number} decimalLength - Number of decimal places
* @return {Number}
*/
var round = (v, decimalLength) => {
	if (decimalLength < 0) return v;
	if (!decimalLength) return _round(v);
	let p = powCache[decimalLength];
	if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
	return _round(v * p) / p;
};
/**
* Snaps a value to nearest increment or array value
*
* @param  {Number} v - Value to snap
* @param  {Number|Array<Number>} increment - Step size or array of snap points
* @return {Number}
*/
var snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => abs(cv - v) < abs(closest - v) ? cv : closest) : increment ? _round(v / increment) * increment : v;
/**
* Linear interpolation between two values
*
* @param  {Number} start - Starting value
* @param  {Number} end - Ending value
* @param  {Number} factor - Interpolation factor in the range [0, 1]
* @return {Number} The interpolated value
*/
var lerp = (start, end, factor) => start + (end - start) * factor;
/**
* Replaces infinity with maximum safe value
*
* @param  {Number} v - Value to check
* @return {Number}
*/
var clampInfinity = (v) => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;
/**
* Normalizes time value with minimum threshold
*
* @param  {Number} v - Time value to normalize
* @return {Number}
*/
var normalizeTime = (v) => v <= minValue ? minValue : clampInfinity(round(v, 11));
/**
* @template T
* @param    {T[]} a
* @return   {T[]}
*/
var cloneArray = (a) => isArr(a) ? [...a] : a;
/**
* @template T
* @template U
* @param    {T} o1
* @param    {U} o2
* @return   {T & U}
*/
var mergeObjects = (o1, o2) => {
	const merged = { ...o1 };
	for (let p in o2) {
		const o1p = o1[p];
		merged[p] = isUnd(o1p) ? o2[p] : o1p;
	}
	return merged;
};
/**
* @param  {Object} parent
* @param  {Function} callback
* @param  {Boolean} [reverse]
* @param  {String} [prevProp]
* @param  {String} [nextProp]
* @return {void}
*/
var forEachChildren = (parent, callback, reverse, prevProp = "_prev", nextProp = "_next") => {
	let next = parent._head;
	let adjustedNextProp = nextProp;
	if (reverse) {
		next = parent._tail;
		adjustedNextProp = prevProp;
	}
	while (next) {
		const currentNext = next[adjustedNextProp];
		callback(next);
		next = currentNext;
	}
};
/**
* @param  {Object} parent
* @param  {Object} child
* @param  {String} [prevProp]
* @param  {String} [nextProp]
* @return {void}
*/
var removeChild = (parent, child, prevProp = "_prev", nextProp = "_next") => {
	const prev = child[prevProp];
	const next = child[nextProp];
	prev ? prev[nextProp] = next : parent._head = next;
	next ? next[prevProp] = prev : parent._tail = prev;
	child[prevProp] = null;
	child[nextProp] = null;
};
/**
* @param  {Object} parent
* @param  {Object} child
* @param  {Function} [sortMethod]
* @param  {String} prevProp
* @param  {String} nextProp
* @return {void}
*/
var addChild = (parent, child, sortMethod, prevProp = "_prev", nextProp = "_next") => {
	let prev = parent._tail;
	while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
	const next = prev ? prev[nextProp] : parent._head;
	prev ? prev[nextProp] = child : parent._head = child;
	next ? next[prevProp] = child : parent._tail = child;
	child[prevProp] = prev;
	child[nextProp] = next;
};

//#endregion
//#region node_modules/animejs/dist/modules/core/transforms.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DOMTarget,
* } from '../types/index.js'
*/
/**
* @param  {DOMTarget} target
* @param  {String} propName
* @param  {Object} animationInlineStyles
* @return {String}
*/
var parseInlineTransforms = (target, propName, animationInlineStyles) => {
	const inlineTransforms = target.style.transform;
	let inlinedStylesPropertyValue;
	if (inlineTransforms) {
		const cachedTransforms = target[transformsSymbol];
		let t;
		while (t = transformsExecRgx.exec(inlineTransforms)) {
			const inlinePropertyName = t[1];
			const inlinePropertyValue = t[2].slice(1, -1);
			cachedTransforms[inlinePropertyName] = inlinePropertyValue;
			if (inlinePropertyName === propName) {
				inlinedStylesPropertyValue = inlinePropertyValue;
				if (animationInlineStyles) animationInlineStyles[propName] = inlinePropertyValue;
			}
		}
	}
	return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, "scale") ? "1" : stringStartsWith(propName, "rotate") || stringStartsWith(propName, "skew") ? "0deg" : "0px";
};

//#endregion
//#region node_modules/animejs/dist/modules/core/colors.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   ColorArray,
* } from '../types/index.js'
*/
/**
* RGB / RGBA Color value string -> RGBA values array
* @param  {String} rgbValue
* @return {ColorArray}
*/
var rgbToRgba = (rgbValue) => {
	const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
	const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
	return [
		+rgba[1],
		+rgba[2],
		+rgba[3],
		a
	];
};
/**
* HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
* @param  {String} hexValue
* @return {ColorArray}
*/
var hexToRgba = (hexValue) => {
	const hexLength = hexValue.length;
	const isShort = hexLength === 4 || hexLength === 5;
	return [
		+("0x" + hexValue[1] + hexValue[isShort ? 1 : 2]),
		+("0x" + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
		+("0x" + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
		hexLength === 5 || hexLength === 9 ? +(+("0x" + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1
	];
};
/**
* @param  {Number} p
* @param  {Number} q
* @param  {Number} t
* @return {Number}
*/
var hue2rgb = (p, q, t) => {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	return t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
};
/**
* HSL / HSLA Color value string -> RGBA values array
* @param  {String} hslValue
* @return {ColorArray}
*/
var hslToRgba = (hslValue) => {
	const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
	const h = +hsla[1] / 360;
	const s = +hsla[2] / 100;
	const l = +hsla[3] / 100;
	const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
	let r, g, b;
	if (s === 0) r = g = b = l;
	else {
		const q = l < .5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);
		g = round(hue2rgb(p, q, h) * 255, 0);
		b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);
	}
	return [
		r,
		g,
		b,
		a
	];
};
/**
* All in one color converter that converts a color string value into an array of RGBA values
* @param  {String} colorString
* @return {ColorArray}
*/
var convertColorStringValuesToRgbaArray = (colorString) => {
	return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [
		0,
		0,
		0,
		1
	];
};

//#endregion
//#region node_modules/animejs/dist/modules/core/values.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Target,
*   DOMTarget,
*   Tween,
*   TweenPropValue,
*   TweenDecomposedValue,
* } from '../types/index.js'
*/
/**
* @template T, D
* @param {T|undefined} targetValue
* @param {D} defaultValue
* @return {T|D}
*/
var setValue = (targetValue, defaultValue) => {
	return isUnd(targetValue) ? defaultValue : targetValue;
};
/**
* @param  {TweenPropValue} value
* @param  {Target} target
* @param  {Number} index
* @param  {Number} total
* @param  {Object} [store]
* @return {any}
*/
var getFunctionValue = (value, target, index, total, store) => {
	let func;
	if (isFnc(value)) func = () => {
		const computed = value(target, index, total);
		return !isNaN(+computed) ? +computed : computed || 0;
	};
	else if (isStr(value) && stringStartsWith(value, cssVarPrefix)) func = () => {
		const match = value.match(cssVariableMatchRgx);
		const cssVarName = match[1];
		const fallbackValue = match[2];
		let computed = getComputedStyle(target)?.getPropertyValue(cssVarName);
		if ((!computed || computed.trim() === emptyString) && fallbackValue) computed = fallbackValue.trim();
		return computed || 0;
	};
	else return value;
	if (store) store.func = func;
	return func();
};
/**
* @param  {Target} target
* @param  {String} prop
* @return {tweenTypes}
*/
var getTweenType = (target, prop) => {
	return !target[isDomSymbol] ? tweenTypes.OBJECT : target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE : validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM : stringStartsWith(prop, "--") ? tweenTypes.CSS_VAR : prop in target.style ? tweenTypes.CSS : prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE;
};
/**
* @param  {DOMTarget} target
* @param  {String} propName
* @param  {Object} animationInlineStyles
* @return {String}
*/
var getCSSValue = (target, propName, animationInlineStyles) => {
	const inlineStyles = target.style[propName];
	if (inlineStyles && animationInlineStyles) animationInlineStyles[propName] = inlineStyles;
	const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
	return value === "auto" ? "0" : value;
};
/**
* @param {Target} target
* @param {String} propName
* @param {tweenTypes} [tweenType]
* @param {Object|void} [animationInlineStyles]
* @return {String|Number}
*/
var getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
	const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
	return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? target.getAttribute(propName) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(target, propName, animationInlineStyles) : type === tweenTypes.CSS_VAR ? getCSSValue(target, propName, animationInlineStyles).trimStart() : getCSSValue(target, propName, animationInlineStyles);
};
/**
* @param  {Number} x
* @param  {Number} y
* @param  {String} operator
* @return {Number}
*/
var getRelativeValue = (x, y, operator) => {
	return operator === "-" ? x - y : operator === "+" ? x + y : x * y;
};
/** @return {TweenDecomposedValue} */
var createDecomposedValueTargetObject = () => {
	return {
		t: valueTypes.NUMBER,
		n: 0,
		u: null,
		o: null,
		d: null,
		s: null
	};
};
/**
* @param  {String|Number} rawValue
* @param  {TweenDecomposedValue} targetObject
* @return {TweenDecomposedValue}
*/
var decomposeRawValue = (rawValue, targetObject) => {
	/** @type {valueTypes} */
	targetObject.t = valueTypes.NUMBER;
	targetObject.n = 0;
	targetObject.u = null;
	targetObject.o = null;
	targetObject.d = null;
	targetObject.s = null;
	if (!rawValue) return targetObject;
	const num = +rawValue;
	if (!isNaN(num)) {
		targetObject.n = num;
		return targetObject;
	} else {
		let str = rawValue;
		if (str[1] === "=") {
			targetObject.o = str[0];
			str = str.slice(2);
		}
		const unitMatch = str.includes(" ") ? false : unitsExecRgx.exec(str);
		if (unitMatch) {
			targetObject.t = valueTypes.UNIT;
			targetObject.n = +unitMatch[1];
			targetObject.u = unitMatch[2];
			return targetObject;
		} else if (targetObject.o) {
			targetObject.n = +str;
			return targetObject;
		} else if (isCol(str)) {
			targetObject.t = valueTypes.COLOR;
			targetObject.d = convertColorStringValuesToRgbaArray(str);
			return targetObject;
		} else {
			const matchedNumbers = str.match(digitWithExponentRgx);
			targetObject.t = valueTypes.COMPLEX;
			targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
			targetObject.s = str.split(digitWithExponentRgx) || [];
			return targetObject;
		}
	}
};
/**
* @param  {Tween} tween
* @param  {TweenDecomposedValue} targetObject
* @return {TweenDecomposedValue}
*/
var decomposeTweenValue = (tween, targetObject) => {
	targetObject.t = tween._valueType;
	targetObject.n = tween._toNumber;
	targetObject.u = tween._unit;
	targetObject.o = null;
	targetObject.d = cloneArray(tween._toNumbers);
	targetObject.s = cloneArray(tween._strings);
	return targetObject;
};
var decomposedOriginalValue = createDecomposedValueTargetObject();

//#endregion
//#region node_modules/animejs/dist/modules/core/render.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
*   @import {
*   Tickable,
*   Renderable,
*   CallbackArgument,
*   Tween,
*   DOMTarget,
* } from '../types/index.js'
*/
/**
* @import {
*   JSAnimation,
* } from '../animation/animation.js'
*/
/**
* @import {
*   Timeline,
* } from '../timeline/timeline.js'
*/
/**
* @param  {Tickable} tickable
* @param  {Number} time
* @param  {Number} muteCallbacks
* @param  {Number} internalRender
* @param  {tickModes} tickMode
* @return {Number}
*/
var render = (tickable, time, muteCallbacks, internalRender, tickMode) => {
	const parent = tickable.parent;
	const duration = tickable.duration;
	const completed = tickable.completed;
	const iterationDuration = tickable.iterationDuration;
	const iterationCount = tickable.iterationCount;
	const _currentIteration = tickable._currentIteration;
	const _loopDelay = tickable._loopDelay;
	const _reversed = tickable._reversed;
	const _alternate = tickable._alternate;
	const _hasChildren = tickable._hasChildren;
	const tickableDelay = tickable._delay;
	const tickablePrevAbsoluteTime = tickable._currentTime;
	const tickableEndTime = tickableDelay + iterationDuration;
	const tickableAbsoluteTime = time - tickableDelay;
	const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);
	const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);
	const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
	const isCurrentTimeAboveZero = tickableCurrentTime > 0;
	const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
	const isSetter = duration <= minValue;
	const forcedTick = tickMode === tickModes.FORCE;
	let isOdd = 0;
	let iterationElapsedTime = tickableAbsoluteTime;
	let hasRendered = 0;
	if (iterationCount > 1) {
		tickable._currentIteration = clamp(~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay))), 0, iterationCount);
		if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
		isOdd = tickable._currentIteration % 2;
		iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
	}
	const isReversed = _reversed ^ (_alternate && isOdd);
	const _ease = tickable._ease;
	let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
	if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
	const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;
	tickable._currentTime = tickableAbsoluteTime;
	tickable._iterationTime = iterationTime;
	tickable.backwards = isRunningBackwards;
	if (isCurrentTimeAboveZero && !tickable.began) {
		tickable.began = true;
		if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) tickable.onBegin(tickable);
	} else if (tickableAbsoluteTime <= 0) tickable.began = false;
	if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) tickable.onLoop(tickable);
	if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime || time <= tickableDelay && tickablePrevTime > tickableDelay || time >= tickableEndTime && tickablePrevTime !== duration) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed || isCurrentTimeEqualOrAboveDuration && !completed && isSetter) {
		if (isCurrentTimeAboveZero) {
			tickable.computeDeltaTime(tickablePrevTime);
			if (!muteCallbacks) tickable.onBeforeUpdate(tickable);
		}
		if (!_hasChildren) {
			const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
			const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;
			let tween = tickable._head;
			let tweenTarget;
			let tweenStyle;
			let tweenTargetTransforms;
			let tweenTargetTransformsProperties;
			let tweenTransformsNeedUpdate = 0;
			while (tween) {
				const tweenComposition = tween._composition;
				const tweenCurrentTime = tween._currentTime;
				const tweenChangeDuration = tween._changeDuration;
				const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
				const tweenNextRep = tween._nextRep;
				const tweenPrevRep = tween._prevRep;
				const tweenHasComposition = tweenComposition !== compositionTypes.none;
				if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime) && (!tweenPrevRep || tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay))) {
					const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);
					const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
					const tweenModifier = tween._modifier;
					const tweenValueType = tween._valueType;
					const tweenType = tween._tweenType;
					const tweenIsObject = tweenType === tweenTypes.OBJECT;
					const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
					const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;
					/** @type {String|Number} */
					let value;
					/** @type {Number} */
					let number;
					if (tweenIsNumber) value = number = tweenModifier(round(lerp(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
					else if (tweenValueType === valueTypes.UNIT) {
						number = tweenModifier(round(lerp(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
						value = `${number}${tween._unit}`;
					} else if (tweenValueType === valueTypes.COLOR) {
						const fn = tween._fromNumbers;
						const tn = tween._toNumbers;
						const r = round(clamp(tweenModifier(lerp(fn[0], tn[0], tweenProgress)), 0, 255), 0);
						const g = round(clamp(tweenModifier(lerp(fn[1], tn[1], tweenProgress)), 0, 255), 0);
						const b = round(clamp(tweenModifier(lerp(fn[2], tn[2], tweenProgress)), 0, 255), 0);
						const a = clamp(tweenModifier(round(lerp(fn[3], tn[3], tweenProgress), tweenPrecision)), 0, 1);
						value = `rgba(${r},${g},${b},${a})`;
						if (tweenHasComposition) {
							const ns = tween._numbers;
							ns[0] = r;
							ns[1] = g;
							ns[2] = b;
							ns[3] = a;
						}
					} else if (tweenValueType === valueTypes.COMPLEX) {
						value = tween._strings[0];
						for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
							const n = tweenModifier(round(lerp(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision));
							const s = tween._strings[j + 1];
							value += `${s ? n + s : n}`;
							if (tweenHasComposition) tween._numbers[j] = n;
						}
					}
					if (tweenHasComposition) tween._number = number;
					if (!internalRender && tweenComposition !== compositionTypes.blend) {
						const tweenProperty = tween.property;
						tweenTarget = tween.target;
						if (tweenIsObject) tweenTarget[tweenProperty] = value;
						else if (tweenType === tweenTypes.ATTRIBUTE)
 /** @type {DOMTarget} */ tweenTarget.setAttribute(tweenProperty, value);
						else {
							tweenStyle = tweenTarget.style;
							if (tweenType === tweenTypes.TRANSFORM) {
								if (tweenTarget !== tweenTargetTransforms) {
									tweenTargetTransforms = tweenTarget;
									tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
								}
								tweenTargetTransformsProperties[tweenProperty] = value;
								tweenTransformsNeedUpdate = 1;
							} else if (tweenType === tweenTypes.CSS) tweenStyle[tweenProperty] = value;
							else if (tweenType === tweenTypes.CSS_VAR) tweenStyle.setProperty(tweenProperty, value);
						}
						if (isCurrentTimeAboveZero) hasRendered = 1;
					} else tween._value = value;
				}
				if (tweenTransformsNeedUpdate && tween._renderTransforms) {
					let str = emptyString;
					for (let key$1 in tweenTargetTransformsProperties) str += `${transformsFragmentStrings[key$1]}${tweenTargetTransformsProperties[key$1]}) `;
					tweenStyle.transform = str;
					tweenTransformsNeedUpdate = 0;
				}
				tween = tween._next;
			}
			if (!muteCallbacks && hasRendered)
 /** @type {JSAnimation} */ tickable.onRender(tickable);
		}
		if (!muteCallbacks && isCurrentTimeAboveZero) tickable.onUpdate(tickable);
	}
	if (parent && isSetter) {
		if (!muteCallbacks && (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {
			tickable.onComplete(tickable);
			tickable.completed = !isRunningBackwards;
		}
	} else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
		if (iterationCount === Infinity) tickable._startTime += tickable.duration;
		else if (tickable._currentIteration >= iterationCount - 1) {
			tickable.paused = true;
			if (!completed && !_hasChildren) {
				tickable.completed = true;
				if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
					tickable.onComplete(tickable);
					tickable._resolve(tickable);
				}
			}
		}
	} else tickable.completed = false;
	return hasRendered;
};
/**
* @param  {Tickable} tickable
* @param  {Number} time
* @param  {Number} muteCallbacks
* @param  {Number} internalRender
* @param  {Number} tickMode
* @return {void}
*/
var tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
	const _currentIteration = tickable._currentIteration;
	render(tickable, time, muteCallbacks, internalRender, tickMode);
	if (tickable._hasChildren) {
		const tl = tickable;
		const tlIsRunningBackwards = tl.backwards;
		const tlChildrenTime = internalRender ? time : tl._iterationTime;
		const tlCildrenTickTime = now();
		let tlChildrenHasRendered = 0;
		let tlChildrenHaveCompleted = true;
		if (!internalRender && tl._currentIteration !== _currentIteration) {
			const tlIterationDuration = tl.iterationDuration;
			forEachChildren(tl, (child) => {
				if (!tlIsRunningBackwards) {
					if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
					child.began = false;
					child.completed = false;
				} else {
					const childDuration = child.duration;
					const childStartTime = child._offset + child._delay;
					const childEndTime = childStartTime + childDuration;
					if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) child.onComplete(child);
				}
			});
			if (!muteCallbacks) tl.onLoop(tl);
		}
		forEachChildren(tl, (child) => {
			const childTime = round((tlChildrenTime - child._offset) * child._speed, 12);
			const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
			tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
			if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
		}, tlIsRunningBackwards);
		if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(tl);
		if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {
			tl.paused = true;
			if (!tl.completed) {
				tl.completed = true;
				if (!muteCallbacks) {
					tl.onComplete(tl);
					tl._resolve(tl);
				}
			}
		}
	}
};

//#endregion
//#region node_modules/animejs/dist/modules/core/styles.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   JSAnimation,
* } from '../animation/animation.js'
*/
/**
* @import {
*   Target,
*   DOMTarget,
*   Renderable,
*   Tween,
* } from '../types/index.js'
*/
var propertyNamesCache = {};
/**
* @param  {String} propertyName
* @param  {Target} target
* @param  {tweenTypes} tweenType
* @return {String}
*/
var sanitizePropertyName = (propertyName, target, tweenType) => {
	if (tweenType === tweenTypes.TRANSFORM) {
		const t = shortTransforms.get(propertyName);
		return t ? t : propertyName;
	} else if (tweenType === tweenTypes.CSS || tweenType === tweenTypes.ATTRIBUTE && isSvg(target) && propertyName in target.style) {
		const cachedPropertyName = propertyNamesCache[propertyName];
		if (cachedPropertyName) return cachedPropertyName;
		else {
			const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
			propertyNamesCache[propertyName] = lowerCaseName;
			return lowerCaseName;
		}
	} else return propertyName;
};
/**
* @template {Renderable} T
* @param {T} renderable
* @return {T}
*/
var cleanInlineStyles = (renderable) => {
	if (renderable._hasChildren) forEachChildren(renderable, cleanInlineStyles, true);
	else {
		const animation = renderable;
		animation.pause();
		forEachChildren(animation, (tween) => {
			const tweenProperty = tween.property;
			const tweenTarget = tween.target;
			if (tweenTarget[isDomSymbol]) {
				const targetStyle = tweenTarget.style;
				const originalInlinedValue = tween._inlineValue;
				const tweenHadNoInlineValue = isNil(originalInlinedValue) || originalInlinedValue === emptyString;
				if (tween._tweenType === tweenTypes.TRANSFORM) {
					const cachedTransforms = tweenTarget[transformsSymbol];
					if (tweenHadNoInlineValue) delete cachedTransforms[tweenProperty];
					else cachedTransforms[tweenProperty] = originalInlinedValue;
					if (tween._renderTransforms) if (!Object.keys(cachedTransforms).length) targetStyle.removeProperty("transform");
					else {
						let str = emptyString;
						for (let key$1 in cachedTransforms) str += transformsFragmentStrings[key$1] + cachedTransforms[key$1] + ") ";
						targetStyle.transform = str;
					}
				} else if (tweenHadNoInlineValue) targetStyle.removeProperty(toLowerCase(tweenProperty));
				else targetStyle[tweenProperty] = originalInlinedValue;
				if (animation._tail === tween) animation.targets.forEach((t) => {
					if (t.getAttribute && t.getAttribute("style") === emptyString) t.removeAttribute("style");
				});
			}
		});
	}
	return renderable;
};

//#endregion
//#region node_modules/animejs/dist/modules/core/clock.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Tickable,
*   Tween,
* } from '../types/index.js'
*/
var Clock = class {
	/** @param {Number} [initTime] */
	constructor(initTime = 0) {
		/** @type {Number} */
		this.deltaTime = 0;
		/** @type {Number} */
		this._currentTime = initTime;
		/** @type {Number} */
		this._elapsedTime = initTime;
		/** @type {Number} */
		this._startTime = initTime;
		/** @type {Number} */
		this._lastTime = initTime;
		/** @type {Number} */
		this._scheduledTime = 0;
		/** @type {Number} */
		this._frameDuration = round(K / maxFps, 0);
		/** @type {Number} */
		this._fps = maxFps;
		/** @type {Number} */
		this._speed = 1;
		/** @type {Boolean} */
		this._hasChildren = false;
		/** @type {Tickable|Tween} */
		this._head = null;
		/** @type {Tickable|Tween} */
		this._tail = null;
	}
	get fps() {
		return this._fps;
	}
	set fps(frameRate) {
		const previousFrameDuration = this._frameDuration;
		const fr = +frameRate;
		const fps = fr < minValue ? minValue : fr;
		const frameDuration = round(K / fps, 0);
		this._fps = fps;
		this._frameDuration = frameDuration;
		this._scheduledTime += frameDuration - previousFrameDuration;
	}
	get speed() {
		return this._speed;
	}
	set speed(playbackRate) {
		const pbr = +playbackRate;
		this._speed = pbr < minValue ? minValue : pbr;
	}
	/**
	* @param  {Number} time
	* @return {tickModes}
	*/
	requestTick(time) {
		const scheduledTime = this._scheduledTime;
		const elapsedTime = this._elapsedTime;
		this._elapsedTime += time - elapsedTime;
		if (elapsedTime < scheduledTime) return tickModes.NONE;
		const frameDuration = this._frameDuration;
		const frameDelta = elapsedTime - scheduledTime;
		this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
		return tickModes.AUTO;
	}
	/**
	* @param  {Number} time
	* @return {Number}
	*/
	computeDeltaTime(time) {
		const delta = time - this._lastTime;
		this.deltaTime = delta;
		this._lastTime = time;
		return delta;
	}
};

//#endregion
//#region node_modules/animejs/dist/modules/animation/additive.js
/**
* Anime.js - animation - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
var additive = {
	animation: null,
	update: noop
};
/**
* @import {
*   Tween,
*   TweenAdditiveLookups,
* } from '../types/index.js'
*/
/**
* @typedef AdditiveAnimation
* @property {Number} duration
* @property {Number} _offset
* @property {Number} _delay
* @property {Tween} _head
* @property {Tween} _tail
*/
/**
* @param  {TweenAdditiveLookups} lookups
* @return {AdditiveAnimation}
*/
var addAdditiveAnimation = (lookups$1) => {
	let animation = additive.animation;
	if (!animation) {
		animation = {
			duration: minValue,
			computeDeltaTime: noop,
			_offset: 0,
			_delay: 0,
			_head: null,
			_tail: null
		};
		additive.animation = animation;
		additive.update = () => {
			lookups$1.forEach((propertyAnimation) => {
				for (let propertyName in propertyAnimation) {
					const tweens = propertyAnimation[propertyName];
					const lookupTween = tweens._head;
					if (lookupTween) {
						const valueType = lookupTween._valueType;
						const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
						let additiveValue = lookupTween._fromNumber;
						let tween = tweens._tail;
						while (tween && tween !== lookupTween) {
							if (additiveValues) for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
							else additiveValue += tween._number;
							tween = tween._prevAdd;
						}
						lookupTween._toNumber = additiveValue;
						lookupTween._toNumbers = additiveValues;
					}
				}
			});
			render(animation, 1, 1, 0, tickModes.FORCE);
		};
	}
	return animation;
};

//#endregion
//#region node_modules/animejs/dist/modules/engine/engine.js
/**
* Anime.js - engine - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DefaultsParams,
* } from '../types/index.js'
*/
/**
* @import {
*   Tickable,
* } from '../types/index.js'
*/
var engineTickMethod = /* @__PURE__ */ (() => isBrowser ? requestAnimationFrame : setImmediate)();
var engineCancelMethod = /* @__PURE__ */ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();
var Engine = class extends Clock {
	/** @param {Number} [initTime] */
	constructor(initTime) {
		super(initTime);
		this.useDefaultMainLoop = true;
		this.pauseOnDocumentHidden = true;
		/** @type {DefaultsParams} */
		this.defaults = defaults;
		this.paused = true;
		/** @type {Number|NodeJS.Immediate} */
		this.reqId = 0;
	}
	update() {
		const time = this._currentTime = now();
		if (this.requestTick(time)) {
			this.computeDeltaTime(time);
			const engineSpeed = this._speed;
			const engineFps = this._fps;
			let activeTickable = this._head;
			while (activeTickable) {
				const nextTickable = activeTickable._next;
				if (!activeTickable.paused) tick(activeTickable, (time - activeTickable._startTime) * activeTickable._speed * engineSpeed, 0, 0, activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO);
				else {
					removeChild(this, activeTickable);
					this._hasChildren = !!this._tail;
					activeTickable._running = false;
					if (activeTickable.completed && !activeTickable._cancelled) activeTickable.cancel();
				}
				activeTickable = nextTickable;
			}
			additive.update();
		}
	}
	wake() {
		if (this.useDefaultMainLoop && !this.reqId) {
			this.requestTick(now());
			this.reqId = engineTickMethod(tickEngine);
		}
		return this;
	}
	pause() {
		if (!this.reqId) return;
		this.paused = true;
		return killEngine();
	}
	resume() {
		if (!this.paused) return;
		this.paused = false;
		forEachChildren(this, (child) => child.resetTime());
		return this.wake();
	}
	get speed() {
		return this._speed * (globals.timeScale === 1 ? 1 : K);
	}
	set speed(playbackRate) {
		this._speed = playbackRate * globals.timeScale;
		forEachChildren(this, (child) => child.speed = child._speed);
	}
	get timeUnit() {
		return globals.timeScale === 1 ? "ms" : "s";
	}
	set timeUnit(unit) {
		const secondsScale = .001;
		const isSecond = unit === "s";
		const newScale = isSecond ? secondsScale : 1;
		if (globals.timeScale !== newScale) {
			globals.timeScale = newScale;
			globals.tickThreshold = 200 * newScale;
			const scaleFactor = isSecond ? secondsScale : K;
			/** @type {Number} */
			this.defaults.duration *= scaleFactor;
			this._speed *= scaleFactor;
		}
	}
	get precision() {
		return globals.precision;
	}
	set precision(precision) {
		globals.precision = precision;
	}
};
var engine = /* @__PURE__ */ (() => {
	const engine$1 = new Engine(now());
	if (isBrowser) {
		globalVersions.engine = engine$1;
		doc.addEventListener("visibilitychange", () => {
			if (!engine$1.pauseOnDocumentHidden) return;
			doc.hidden ? engine$1.pause() : engine$1.resume();
		});
	}
	return engine$1;
})();
var tickEngine = () => {
	if (engine._head) {
		engine.reqId = engineTickMethod(tickEngine);
		engine.update();
	} else engine.reqId = 0;
};
var killEngine = () => {
	engineCancelMethod(engine.reqId);
	engine.reqId = 0;
	return engine;
};

//#endregion
//#region node_modules/animejs/dist/modules/animation/composition.js
/**
* Anime.js - animation - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TweenReplaceLookups,
*   TweenAdditiveLookups,
*   TweenPropertySiblings,
*   Tween,
*   Target,
*   TargetsArray,
*   Renderable,
* } from '../types/index.js'
*
* @import {
*   JSAnimation,
* } from '../animation/animation.js'
*/
var lookups = {
	_rep: /* @__PURE__ */ new WeakMap(),
	_add: /* @__PURE__ */ new Map()
};
/**
* @param  {Target} target
* @param  {String} property
* @param  {String} lookup
* @return {TweenPropertySiblings}
*/
var getTweenSiblings = (target, property, lookup = "_rep") => {
	const lookupMap = lookups[lookup];
	let targetLookup = lookupMap.get(target);
	if (!targetLookup) {
		targetLookup = {};
		lookupMap.set(target, targetLookup);
	}
	return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
		_head: null,
		_tail: null
	};
};
/**
* @param  {Tween} p
* @param  {Tween} c
* @return {Number|Boolean}
*/
var addTweenSortMethod = (p, c) => {
	return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
};
/**
* @param {Tween} tween
*/
var overrideTween = (tween) => {
	tween._isOverlapped = 1;
	tween._isOverridden = 1;
	tween._changeDuration = minValue;
	tween._currentTime = minValue;
};
/**
* @param  {Tween} tween
* @param  {TweenPropertySiblings} siblings
* @return {Tween}
*/
var composeTween = (tween, siblings) => {
	const tweenCompositionType = tween._composition;
	if (tweenCompositionType === compositionTypes.replace) {
		const tweenAbsStartTime = tween._absoluteStartTime;
		addChild(siblings, tween, addTweenSortMethod, "_prevRep", "_nextRep");
		const prevSibling = tween._prevRep;
		if (prevSibling) {
			const prevParent = prevSibling.parent;
			const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;
			if (tween.parent.id !== prevParent.id && prevParent.iterationCount > 1 && prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {
				overrideTween(prevSibling);
				let prevPrevSibling = prevSibling._prevRep;
				while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
					overrideTween(prevPrevSibling);
					prevPrevSibling = prevPrevSibling._prevRep;
				}
			}
			const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;
			if (prevAbsEndTime > absoluteUpdateStartTime) {
				const prevChangeStartTime = prevSibling._startTime;
				const updatedPrevChangeDuration = round(absoluteUpdateStartTime - (prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration)) - prevChangeStartTime, 12);
				prevSibling._changeDuration = updatedPrevChangeDuration;
				prevSibling._currentTime = updatedPrevChangeDuration;
				prevSibling._isOverlapped = 1;
				if (updatedPrevChangeDuration < minValue) overrideTween(prevSibling);
			}
			let pausePrevParentAnimation = true;
			forEachChildren(prevParent, (t) => {
				if (!t._isOverlapped) pausePrevParentAnimation = false;
			});
			if (pausePrevParentAnimation) {
				const prevParentTL = prevParent.parent;
				if (prevParentTL) {
					let pausePrevParentTL = true;
					forEachChildren(prevParentTL, (a) => {
						if (a !== prevParent) forEachChildren(a, (t) => {
							if (!t._isOverlapped) pausePrevParentTL = false;
						});
					});
					if (pausePrevParentTL) prevParentTL.cancel();
				} else prevParent.cancel();
			}
		}
	} else if (tweenCompositionType === compositionTypes.blend) {
		const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, "_add");
		const additiveAnimation = addAdditiveAnimation(lookups._add);
		let lookupTween = additiveTweenSiblings._head;
		if (!lookupTween) {
			lookupTween = { ...tween };
			lookupTween._composition = compositionTypes.replace;
			lookupTween._updateDuration = minValue;
			lookupTween._startTime = 0;
			lookupTween._numbers = cloneArray(tween._fromNumbers);
			lookupTween._number = 0;
			lookupTween._next = null;
			lookupTween._prev = null;
			addChild(additiveTweenSiblings, lookupTween);
			addChild(additiveAnimation, lookupTween);
		}
		const toNumber = tween._toNumber;
		tween._fromNumber = lookupTween._fromNumber - toNumber;
		tween._toNumber = 0;
		tween._numbers = cloneArray(tween._fromNumbers);
		tween._number = 0;
		lookupTween._fromNumber = toNumber;
		if (tween._toNumbers) {
			const toNumbers = cloneArray(tween._toNumbers);
			if (toNumbers) toNumbers.forEach((value, i) => {
				tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
				tween._toNumbers[i] = 0;
			});
			lookupTween._fromNumbers = toNumbers;
		}
		addChild(additiveTweenSiblings, tween, null, "_prevAdd", "_nextAdd");
	}
	return tween;
};
/**
* @param  {Tween} tween
* @return {Tween}
*/
var removeTweenSliblings = (tween) => {
	const tweenComposition = tween._composition;
	if (tweenComposition !== compositionTypes.none) {
		const tweenTarget = tween.target;
		const tweenProperty = tween.property;
		const tweenReplaceSiblings = lookups._rep.get(tweenTarget)[tweenProperty];
		removeChild(tweenReplaceSiblings, tween, "_prevRep", "_nextRep");
		if (tweenComposition === compositionTypes.blend) {
			const addTweensLookup = lookups._add;
			const addTargetProps = addTweensLookup.get(tweenTarget);
			if (!addTargetProps) return;
			const additiveTweenSiblings = addTargetProps[tweenProperty];
			const additiveAnimation = additive.animation;
			removeChild(additiveTweenSiblings, tween, "_prevAdd", "_nextAdd");
			const lookupTween = additiveTweenSiblings._head;
			if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
				removeChild(additiveTweenSiblings, lookupTween, "_prevAdd", "_nextAdd");
				removeChild(additiveAnimation, lookupTween);
				let shouldClean = true;
				for (let prop in addTargetProps) if (addTargetProps[prop]._head) {
					shouldClean = false;
					break;
				}
				if (shouldClean) addTweensLookup.delete(tweenTarget);
			}
		}
	}
	return tween;
};
/**
* @param  {TargetsArray} targetsArray
* @param  {JSAnimation} animation
* @param  {String} [propertyName]
* @return {Boolean}
*/
var removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {
	let tweensMatchesTargets = false;
	forEachChildren(animation, (tween) => {
		const tweenTarget = tween.target;
		if (targetsArray.includes(tweenTarget)) {
			const tweenName = tween.property;
			const tweenType = tween._tweenType;
			const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
			if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
				if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) tween._prev._renderTransforms = 1;
				removeChild(animation, tween);
				removeTweenSliblings(tween);
				tweensMatchesTargets = true;
			}
		}
	}, true);
	return tweensMatchesTargets;
};
/**
* @param  {TargetsArray} targetsArray
* @param  {Renderable} [renderable]
* @param  {String} [propertyName]
*/
var removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {
	const parent = renderable ? renderable : engine;
	let removeMatches;
	if (parent._hasChildren) {
		let iterationDuration = 0;
		forEachChildren(parent, (child) => {
			if (!child._hasChildren) {
				removeMatches = removeTargetsFromJSAnimation(targetsArray, child, propertyName);
				if (removeMatches && !child._head) {
					child.cancel();
					removeChild(parent, child);
				} else {
					const childDur = child._offset + child._delay + child.duration;
					if (childDur > iterationDuration) iterationDuration = childDur;
				}
			}
			if (child._head) removeTargetsFromRenderable(targetsArray, child, propertyName);
			else child._hasChildren = false;
		}, true);
		if (!isUnd(
			/** @type {Renderable} */
			parent.iterationDuration
		))
 /** @type {Renderable} */ parent.iterationDuration = iterationDuration;
	} else removeMatches = removeTargetsFromJSAnimation(targetsArray, parent, propertyName);
	if (removeMatches && !parent._head) {
		parent._hasChildren = false;
		if (parent.cancel) /** @type {Renderable} */ parent.cancel();
	}
};

//#endregion
//#region node_modules/animejs/dist/modules/timer/timer.js
/**
* Anime.js - timer - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Callback,
*   TimerParams,
*   Renderable,
*   Tween,
* } from '../types/index.js'
*/
/**
* @import {
*   ScrollObserver,
* } from '../events/scroll.js'
*/
/**
* @import {
*   Timeline,
* } from '../timeline/timeline.js'
*/
/**
* @param  {Timer} timer
* @return {Timer}
*/
var resetTimerProperties = (timer) => {
	timer.paused = true;
	timer.began = false;
	timer.completed = false;
	return timer;
};
/**
* @param  {Timer} timer
* @return {Timer}
*/
var reviveTimer = (timer) => {
	if (!timer._cancelled) return timer;
	if (timer._hasChildren) forEachChildren(timer, reviveTimer);
	else forEachChildren(timer, (tween) => {
		if (tween._composition !== compositionTypes.none) composeTween(tween, getTweenSiblings(tween.target, tween.property));
	});
	timer._cancelled = 0;
	return timer;
};
var timerId = 0;
/**
* Base class used to create Timers, Animations and Timelines
*/
var Timer = class extends Clock {
	/**
	* @param {TimerParams} [parameters]
	* @param {Timeline} [parent]
	* @param {Number} [parentPosition]
	*/
	constructor(parameters = {}, parent = null, parentPosition = 0) {
		super(0);
		const { id, delay, duration, reversed, alternate, loop, loopDelay, autoplay, frameRate, playbackRate, onComplete, onLoop, onPause, onBegin, onBeforeUpdate, onUpdate } = parameters;
		if (scope.current) scope.current.register(this);
		const timerInitTime = parent ? 0 : engine._elapsedTime;
		const timerDefaults = parent ? parent.defaults : globals.defaults;
		const timerDelay = isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay;
		const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
		const timerLoop = setValue(loop, timerDefaults.loop);
		const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
		const timerIterationCount = timerLoop === true || timerLoop === Infinity || timerLoop < 0 ? Infinity : timerLoop + 1;
		let offsetPosition = 0;
		if (parent) offsetPosition = parentPosition;
		else {
			if (!engine.reqId) engine.requestTick(now());
			offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;
		}
		this.id = !isUnd(id) ? id : ++timerId;
		/** @type {Timeline} */
		this.parent = parent;
		this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;
		/** @type {Boolean} */
		this.backwards = false;
		/** @type {Boolean} */
		this.paused = true;
		/** @type {Boolean} */
		this.began = false;
		/** @type {Boolean} */
		this.completed = false;
		/** @type {Callback<this>} */
		this.onBegin = onBegin || timerDefaults.onBegin;
		/** @type {Callback<this>} */
		this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
		/** @type {Callback<this>} */
		this.onUpdate = onUpdate || timerDefaults.onUpdate;
		/** @type {Callback<this>} */
		this.onLoop = onLoop || timerDefaults.onLoop;
		/** @type {Callback<this>} */
		this.onPause = onPause || timerDefaults.onPause;
		/** @type {Callback<this>} */
		this.onComplete = onComplete || timerDefaults.onComplete;
		/** @type {Number} */
		this.iterationDuration = timerDuration;
		/** @type {Number} */
		this.iterationCount = timerIterationCount;
		/** @type {Boolean|ScrollObserver} */
		this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
		/** @type {Number} */
		this._offset = offsetPosition;
		/** @type {Number} */
		this._delay = timerDelay;
		/** @type {Number} */
		this._loopDelay = timerLoopDelay;
		/** @type {Number} */
		this._iterationTime = 0;
		/** @type {Number} */
		this._currentIteration = 0;
		/** @type {Function} */
		this._resolve = noop;
		/** @type {Boolean} */
		this._running = false;
		/** @type {Number} */
		this._reversed = +setValue(reversed, timerDefaults.reversed);
		/** @type {Number} */
		this._reverse = this._reversed;
		/** @type {Number} */
		this._cancelled = 0;
		/** @type {Boolean} */
		this._alternate = setValue(alternate, timerDefaults.alternate);
		/** @type {Renderable} */
		this._prev = null;
		/** @type {Renderable} */
		this._next = null;
		/** @type {Number} */
		this._elapsedTime = timerInitTime;
		/** @type {Number} */
		this._startTime = timerInitTime;
		/** @type {Number} */
		this._lastTime = timerInitTime;
		/** @type {Number} */
		this._fps = setValue(frameRate, timerDefaults.frameRate);
		/** @type {Number} */
		this._speed = setValue(playbackRate, timerDefaults.playbackRate);
	}
	get cancelled() {
		return !!this._cancelled;
	}
	set cancelled(cancelled) {
		cancelled ? this.cancel() : this.reset(true).play();
	}
	get currentTime() {
		return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);
	}
	set currentTime(time) {
		const paused = this.paused;
		this.pause().seek(+time);
		if (!paused) this.resume();
	}
	get iterationCurrentTime() {
		return round(this._iterationTime, globals.precision);
	}
	set iterationCurrentTime(time) {
		this.currentTime = this.iterationDuration * this._currentIteration + time;
	}
	get progress() {
		return clamp(round(this._currentTime / this.duration, 10), 0, 1);
	}
	set progress(progress) {
		this.currentTime = this.duration * progress;
	}
	get iterationProgress() {
		return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);
	}
	set iterationProgress(progress) {
		const iterationDuration = this.iterationDuration;
		this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;
	}
	get currentIteration() {
		return this._currentIteration;
	}
	set currentIteration(iterationCount) {
		this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);
	}
	get reversed() {
		return !!this._reversed;
	}
	set reversed(reverse) {
		reverse ? this.reverse() : this.play();
	}
	get speed() {
		return super.speed;
	}
	set speed(playbackRate) {
		super.speed = playbackRate;
		this.resetTime();
	}
	/**
	* @param  {Boolean} [softReset]
	* @return {this}
	*/
	reset(softReset = false) {
		reviveTimer(this);
		if (this._reversed && !this._reverse) this.reversed = false;
		this._iterationTime = this.iterationDuration;
		tick(this, 0, 1, ~~softReset, tickModes.FORCE);
		resetTimerProperties(this);
		if (this._hasChildren) forEachChildren(this, resetTimerProperties);
		return this;
	}
	/**
	* @param  {Boolean} internalRender
	* @return {this}
	*/
	init(internalRender = false) {
		this.fps = this._fps;
		this.speed = this._speed;
		if (!internalRender && this._hasChildren) tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);
		this.reset(internalRender);
		const autoplay = this._autoplay;
		if (autoplay === true) this.resume();
		else if (autoplay && !isUnd(
			/** @type {ScrollObserver} */
			autoplay.linked
		))
 /** @type {ScrollObserver} */ autoplay.link(this);
		return this;
	}
	/** @return {this} */
	resetTime() {
		const timeScale = 1 / (this._speed * engine._speed);
		this._startTime = now() - (this._currentTime + this._delay) * timeScale;
		return this;
	}
	/** @return {this} */
	pause() {
		if (this.paused) return this;
		this.paused = true;
		this.onPause(this);
		return this;
	}
	/** @return {this} */
	resume() {
		if (!this.paused) return this;
		this.paused = false;
		if (this.duration <= minValue && !this._hasChildren) tick(this, minValue, 0, 0, tickModes.FORCE);
		else {
			if (!this._running) {
				addChild(engine, this);
				engine._hasChildren = true;
				this._running = true;
			}
			this.resetTime();
			this._startTime -= 12;
			engine.wake();
		}
		return this;
	}
	/** @return {this} */
	restart() {
		return this.reset().resume();
	}
	/**
	* @param  {Number} time
	* @param  {Boolean|Number} [muteCallbacks]
	* @param  {Boolean|Number} [internalRender]
	* @return {this}
	*/
	seek(time, muteCallbacks = 0, internalRender = 0) {
		reviveTimer(this);
		this.completed = false;
		const isPaused = this.paused;
		this.paused = true;
		tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
		return isPaused ? this : this.resume();
	}
	/** @return {this} */
	alternate() {
		const reversed = this._reversed;
		const count = this.iterationCount;
		const duration = this.iterationDuration;
		const iterations = count === Infinity ? floor(maxValue / duration) : count;
		this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
		if (count === Infinity) this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
		else this.seek(duration * iterations - this._currentTime);
		this.resetTime();
		return this;
	}
	/** @return {this} */
	play() {
		if (this._reversed) this.alternate();
		return this.resume();
	}
	/** @return {this} */
	reverse() {
		if (!this._reversed) this.alternate();
		return this.resume();
	}
	/** @return {this} */
	cancel() {
		if (this._hasChildren) forEachChildren(this, (child) => child.cancel(), true);
		else forEachChildren(this, removeTweenSliblings);
		this._cancelled = 1;
		return this.pause();
	}
	/**
	* @param  {Number} newDuration
	* @return {this}
	*/
	stretch(newDuration) {
		const currentDuration = this.duration;
		const normlizedDuration = normalizeTime(newDuration);
		if (currentDuration === normlizedDuration) return this;
		const timeScale = newDuration / currentDuration;
		const isSetter = newDuration <= minValue;
		this.duration = isSetter ? minValue : normlizedDuration;
		this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);
		this._offset *= timeScale;
		this._delay *= timeScale;
		this._loopDelay *= timeScale;
		return this;
	}
	/**
	* Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
	* @return {this}
	*/
	revert() {
		tick(this, 0, 1, 0, tickModes.AUTO);
		const ap = this._autoplay;
		if (ap && ap.linked && ap.linked === this) ap.revert();
		return this.cancel();
	}
	/**
	* Imediatly completes the timer, cancels it and triggers the onComplete callback
	* @return {this}
	*/
	complete() {
		return this.seek(this.duration).cancel();
	}
	/**
	* @typedef {this & {then: null}} ResolvedTimer
	*/
	/**
	* @param  {Callback<ResolvedTimer>} [callback]
	* @return Promise<this>
	*/
	then(callback = noop) {
		const then = this.then;
		const onResolve = () => {
			this.then = null;
			callback(this);
			this.then = then;
			this._resolve = noop;
		};
		return new Promise((r) => {
			this._resolve = () => r(onResolve());
			if (this.completed) this._resolve();
			return this;
		});
	}
};
/**
* @param {TimerParams} [parameters]
* @return {Timer}
*/
var createTimer = (parameters) => new Timer(parameters, null, 0).init();

//#endregion
//#region node_modules/animejs/dist/modules/core/targets.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DOMTarget,
*   DOMTargetsParam,
*   JSTargetsArray,
*   TargetsParam,
*   JSTargetsParam,
*   TargetsArray,
*   DOMTargetsArray,
* } from '../types/index.js'
*/
/**
* @param  {DOMTargetsParam|TargetsParam} v
* @return {NodeList|HTMLCollection}
*/
function getNodeList(v) {
	const n = isStr(v) ? scope.root.querySelectorAll(v) : v;
	if (n instanceof NodeList || n instanceof HTMLCollection) return n;
}
/**
* @overload
* @param  {DOMTargetsParam} targets
* @return {DOMTargetsArray}
*
* @overload
* @param  {JSTargetsParam} targets
* @return {JSTargetsArray}
*
* @overload
* @param  {TargetsParam} targets
* @return {TargetsArray}
*
* @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
*/
function parseTargets(targets) {
	if (isNil(targets)) return [];
	if (!isBrowser) return isArr(targets) && targets.flat(Infinity) || [targets];
	if (isArr(targets)) {
		const flattened = targets.flat(Infinity);
		/** @type {TargetsArray} */
		const parsed = [];
		for (let i = 0, l = flattened.length; i < l; i++) {
			const item = flattened[i];
			if (!isNil(item)) {
				const nodeList$1 = getNodeList(item);
				if (nodeList$1) for (let j = 0, jl = nodeList$1.length; j < jl; j++) {
					const subItem = nodeList$1[j];
					if (!isNil(subItem)) {
						let isDuplicate = false;
						for (let k = 0, kl = parsed.length; k < kl; k++) if (parsed[k] === subItem) {
							isDuplicate = true;
							break;
						}
						if (!isDuplicate) parsed.push(subItem);
					}
				}
				else {
					let isDuplicate = false;
					for (let j = 0, jl = parsed.length; j < jl; j++) if (parsed[j] === item) {
						isDuplicate = true;
						break;
					}
					if (!isDuplicate) parsed.push(item);
				}
			}
		}
		return parsed;
	}
	const nodeList = getNodeList(targets);
	if (nodeList) return Array.from(nodeList);
	return [targets];
}
/**
* @overload
* @param  {DOMTargetsParam} targets
* @return {DOMTargetsArray}
*
* @overload
* @param  {JSTargetsParam} targets
* @return {JSTargetsArray}
*
* @overload
* @param  {TargetsParam} targets
* @return {TargetsArray}
*
* @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
*/
function registerTargets(targets) {
	const parsedTargetsArray = parseTargets(targets);
	const parsedTargetsLength = parsedTargetsArray.length;
	if (parsedTargetsLength) for (let i = 0; i < parsedTargetsLength; i++) {
		const target = parsedTargetsArray[i];
		if (!target[isRegisteredTargetSymbol]) {
			target[isRegisteredTargetSymbol] = true;
			const isSvgType = isSvg(target);
			if (target.nodeType || isSvgType) {
				target[isDomSymbol] = true;
				target[isSvgSymbol] = isSvgType;
				target[transformsSymbol] = {};
			}
		}
	}
	return parsedTargetsArray;
}

//#endregion
//#region node_modules/animejs/dist/modules/core/units.js
/**
* Anime.js - core - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
var angleUnitsMap = {
	"deg": 1,
	"rad": 180 / PI,
	"turn": 360
};
var convertedValuesCache = {};
/**
* @import {
*   DOMTarget,
*   TweenDecomposedValue,
* } from '../types/index.js'
*/
/**
* @param  {DOMTarget} el
* @param  {TweenDecomposedValue} decomposedValue
* @param  {String} unit
* @param  {Boolean} [force]
* @return {TweenDecomposedValue}
*/
var convertValueUnit = (el, decomposedValue, unit, force = false) => {
	const currentUnit = decomposedValue.u;
	const currentNumber = decomposedValue.n;
	if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) return decomposedValue;
	const cachedKey = currentNumber + currentUnit + unit;
	const cached = convertedValuesCache[cachedKey];
	if (!isUnd(cached) && !force) decomposedValue.n = cached;
	else {
		let convertedValue;
		if (currentUnit in angleUnitsMap) convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
		else {
			const baseline = 100;
			const tempEl = el.cloneNode();
			const parentNode = el.parentNode;
			const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;
			parentEl.appendChild(tempEl);
			const elStyle = tempEl.style;
			elStyle.width = baseline + currentUnit;
			const currentUnitWidth = tempEl.offsetWidth || baseline;
			elStyle.width = baseline + unit;
			const factor = currentUnitWidth / (tempEl.offsetWidth || baseline);
			parentEl.removeChild(tempEl);
			convertedValue = factor * currentNumber;
		}
		decomposedValue.n = convertedValue;
		convertedValuesCache[cachedKey] = convertedValue;
	}
	decomposedValue.t, valueTypes.UNIT;
	decomposedValue.u = unit;
	return decomposedValue;
};

//#endregion
//#region node_modules/animejs/dist/modules/easings/none.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
* } from '../types/index.js'
*/
/** @type {EasingFunction} */
var none = (t) => t;

//#endregion
//#region node_modules/animejs/dist/modules/easings/eases/parser.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
*   EasingFunctionWithParams,
*   EasingParam,
*   BackEasing,
*   ElasticEasing,
*   PowerEasing,
* } from '../../types/index.js'
*/
/** @type {PowerEasing} */
var easeInPower = (p = 1.68) => (t) => pow(t, +p);
/**
* @callback EaseType
* @param {EasingFunction} Ease
* @return {EasingFunction}
*/
/** @type {Record<String, EaseType>} */
var easeTypes = {
	in: (easeIn) => (t) => easeIn(t),
	out: (easeIn) => (t) => 1 - easeIn(1 - t),
	inOut: (easeIn) => (t) => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
	outIn: (easeIn) => (t) => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2
};
/**
* Easing functions adapted and simplified from https://robertpenner.com/easing/
* (c) 2001 Robert Penner
*/
var halfPI = PI / 2;
var doublePI = PI * 2;
/** @type {Record<String, EasingFunctionWithParams|EasingFunction>} */
var easeInFunctions = {
	[emptyString]: easeInPower,
	Quad: easeInPower(2),
	Cubic: easeInPower(3),
	Quart: easeInPower(4),
	Quint: easeInPower(5),
	Sine: (t) => 1 - cos(t * halfPI),
	Circ: (t) => 1 - sqrt(1 - t * t),
	Expo: (t) => t ? pow(2, 10 * t - 10) : 0,
	Bounce: (t) => {
		let pow2, b = 4;
		while (t < ((pow2 = pow(2, --b)) - 1) / 11);
		return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
	},
	Back: (overshoot = 1.7) => (t) => (+overshoot + 1) * t * t * t - +overshoot * t * t,
	Elastic: (amplitude = 1, period = .3) => {
		const a = clamp(+amplitude, 1, 10);
		const p = clamp(+period, minValue, 2);
		const s = p / doublePI * asin(1 / a);
		const e = doublePI / p;
		return (t) => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin((1 - t - s) * e);
	}
};
/**
* @typedef  {Object} EasesFunctions
* @property {typeof none} linear
* @property {typeof none} none
* @property {PowerEasing} in
* @property {PowerEasing} out
* @property {PowerEasing} inOut
* @property {PowerEasing} outIn
* @property {EasingFunction} inQuad
* @property {EasingFunction} outQuad
* @property {EasingFunction} inOutQuad
* @property {EasingFunction} outInQuad
* @property {EasingFunction} inCubic
* @property {EasingFunction} outCubic
* @property {EasingFunction} inOutCubic
* @property {EasingFunction} outInCubic
* @property {EasingFunction} inQuart
* @property {EasingFunction} outQuart
* @property {EasingFunction} inOutQuart
* @property {EasingFunction} outInQuart
* @property {EasingFunction} inQuint
* @property {EasingFunction} outQuint
* @property {EasingFunction} inOutQuint
* @property {EasingFunction} outInQuint
* @property {EasingFunction} inSine
* @property {EasingFunction} outSine
* @property {EasingFunction} inOutSine
* @property {EasingFunction} outInSine
* @property {EasingFunction} inCirc
* @property {EasingFunction} outCirc
* @property {EasingFunction} inOutCirc
* @property {EasingFunction} outInCirc
* @property {EasingFunction} inExpo
* @property {EasingFunction} outExpo
* @property {EasingFunction} inOutExpo
* @property {EasingFunction} outInExpo
* @property {EasingFunction} inBounce
* @property {EasingFunction} outBounce
* @property {EasingFunction} inOutBounce
* @property {EasingFunction} outInBounce
* @property {BackEasing} inBack
* @property {BackEasing} outBack
* @property {BackEasing} inOutBack
* @property {BackEasing} outInBack
* @property {ElasticEasing} inElastic
* @property {ElasticEasing} outElastic
* @property {ElasticEasing} inOutElastic
* @property {ElasticEasing} outInElastic
*/
var eases = /* @__PURE__ */ (() => {
	const list = {
		linear: none,
		none
	};
	for (let type in easeTypes) for (let name in easeInFunctions) {
		const easeIn = easeInFunctions[name];
		const easeType = easeTypes[type];
		list[type + name] = name === emptyString || name === "Back" || name === "Elastic" ? (a, b) => easeType(
			/** @type {EasingFunctionWithParams} */
			easeIn(a, b)
		) : easeType(easeIn);
	}
	return list;
})();
/** @type {Record<String, EasingFunction>} */
var easesLookups = {
	linear: none,
	none
};
/**
* @param  {String} string
* @return {EasingFunction}
*/
var parseEaseString = (string) => {
	if (easesLookups[string]) return easesLookups[string];
	if (string.indexOf("(") <= -1) {
		const parsedFn = easeTypes[string] || string.includes("Back") || string.includes("Elastic") ? eases[string]() : eases[string];
		return parsedFn ? easesLookups[string] = parsedFn : none;
	} else {
		const split = string.slice(0, -1).split("(");
		const parsedFn = eases[split[0]];
		return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(",")) : none;
	}
};
var deprecated = [
	"steps(",
	"irregular(",
	"linear(",
	"cubicBezier("
];
/**
* @param  {EasingParam} ease
* @return {EasingFunction}
*/
var parseEase = (ease) => {
	if (isStr(ease)) {
		for (let i = 0, l = deprecated.length; i < l; i++) if (stringStartsWith(ease, deprecated[i])) {
			console.warn(`String syntax for \`ease: "${ease}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${ease}\``);
			return none;
		}
	}
	return isFnc(ease) ? ease : isStr(ease) ? parseEaseString(ease) : none;
};

//#endregion
//#region node_modules/animejs/dist/modules/animation/animation.js
/**
* Anime.js - animation - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Tween,
*   TweenKeyValue,
*   TweenParamsOptions,
*   TweenValues,
*   DurationKeyframes,
*   PercentageKeyframes,
*   AnimationParams,
*   TweenPropValue,
*   ArraySyntaxValue,
*   TargetsParam,
*   TimerParams,
*   TweenParamValue,
*   DOMTarget,
*   TargetsArray,
*   Callback,
*   EasingFunction,
* } from '../types/index.js'
*
* @import {
*   Timeline,
* } from '../timeline/timeline.js'
*
* @import {
*   Spring,
* } from '../easings/spring/index.js'
*/
var fromTargetObject = createDecomposedValueTargetObject();
var toTargetObject = createDecomposedValueTargetObject();
var inlineStylesStore = {};
var toFunctionStore = { func: null };
var keyframesTargetArray = [null];
var fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
var keyObjectTarget = { to: null };
var tweenId = 0;
var keyframes;
/** @type {TweenParamsOptions & TweenValues} */
var key;
/**
* @param {DurationKeyframes | PercentageKeyframes} keyframes
* @param {AnimationParams} parameters
* @return {AnimationParams}
*/
var generateKeyframes = (keyframes$1, parameters) => {
	/** @type {AnimationParams} */
	const properties = {};
	if (isArr(keyframes$1)) {
		const propertyNames = [].concat(...keyframes$1.map((key$1) => Object.keys(key$1))).filter(isKey);
		for (let i = 0, l = propertyNames.length; i < l; i++) {
			const propName = propertyNames[i];
			properties[propName] = keyframes$1.map((key$1) => {
				/** @type {TweenKeyValue} */
				const newKey = {};
				for (let p in key$1) {
					const keyValue = key$1[p];
					if (isKey(p)) {
						if (p === propName) newKey.to = keyValue;
					} else newKey[p] = keyValue;
				}
				return newKey;
			});
		}
	} else {
		const totalDuration = setValue(parameters.duration, globals.defaults.duration);
		Object.keys(keyframes$1).map((key$1) => {
			return {
				o: parseFloat(key$1) / 100,
				p: keyframes$1[key$1]
			};
		}).sort((a, b) => a.o - b.o).forEach((key$1) => {
			const offset = key$1.o;
			const prop = key$1.p;
			for (let name in prop) if (isKey(name)) {
				let propArray = properties[name];
				if (!propArray) propArray = properties[name] = [];
				const duration = offset * totalDuration;
				let length = propArray.length;
				let prevKey = propArray[length - 1];
				const keyObj = { to: prop[name] };
				let durProgress = 0;
				for (let i = 0; i < length; i++) durProgress += propArray[i].duration;
				if (length === 1) keyObj.from = prevKey.to;
				if (prop.ease) keyObj.ease = prop.ease;
				keyObj.duration = duration - (length ? durProgress : 0);
				propArray.push(keyObj);
			}
			return key$1;
		});
		for (let name in properties) {
			const propArray = properties[name];
			let prevEase;
			for (let i = 0, l = propArray.length; i < l; i++) {
				const prop = propArray[i];
				const currentEase = prop.ease;
				prop.ease = prevEase ? prevEase : void 0;
				prevEase = currentEase;
			}
			if (!propArray[0].duration) propArray.shift();
		}
	}
	return properties;
};
var JSAnimation = class extends Timer {
	/**
	* @param {TargetsParam} targets
	* @param {AnimationParams} parameters
	* @param {Timeline} [parent]
	* @param {Number} [parentPosition]
	* @param {Boolean} [fastSet=false]
	* @param {Number} [index=0]
	* @param {Number} [length=0]
	*/
	constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0) {
		super(parameters, parent, parentPosition);
		const parsedTargets = registerTargets(targets);
		const targetsLength = parsedTargets.length;
		const kfParams = parameters.keyframes;
		const params = kfParams ? mergeObjects(generateKeyframes(kfParams, parameters), parameters) : parameters;
		const { delay, duration, ease, playbackEase, modifier, composition, onRender } = params;
		const animDefaults = parent ? parent.defaults : globals.defaults;
		const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
		const animEase = animaPlaybackEase ? parseEase(animaPlaybackEase) : null;
		const hasSpring = !isUnd(ease) && !isUnd(
			/** @type {Spring} */
			ease.ease
		);
		const tEasing = hasSpring ? ease.ease : setValue(ease, animEase ? "linear" : animDefaults.ease);
		const tDuration = hasSpring ? ease.settlingDuration : setValue(duration, animDefaults.duration);
		const tDelay = setValue(delay, animDefaults.delay);
		const tModifier = modifier || animDefaults.modifier;
		const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
		const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
		if (hasSpring) /** @type {Spring} */ ease.parent = this;
		let iterationDuration = NaN;
		let iterationDelay = NaN;
		let animationAnimationLength = 0;
		let shouldTriggerRender = 0;
		for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {
			const target = parsedTargets[targetIndex];
			const ti = index || targetIndex;
			const tl = length || targetsLength;
			let lastTransformGroupIndex = NaN;
			let lastTransformGroupLength = NaN;
			for (let p in params) if (isKey(p)) {
				const tweenType = getTweenType(target, p);
				const propName = sanitizePropertyName(p, target, tweenType);
				let propValue = params[p];
				const isPropValueArray = isArr(propValue);
				if (fastSet && !isPropValueArray) {
					fastSetValuesArray[0] = propValue;
					fastSetValuesArray[1] = propValue;
					propValue = fastSetValuesArray;
				}
				if (isPropValueArray) {
					const arrayLength = propValue.length;
					const isNotObjectValue = !isObj(propValue[0]);
					if (arrayLength === 2 && isNotObjectValue) {
						keyObjectTarget.to = propValue;
						keyframesTargetArray[0] = keyObjectTarget;
						keyframes = keyframesTargetArray;
					} else if (arrayLength > 2 && isNotObjectValue) {
						keyframes = [];
						/** @type {Array.<Number>} */ propValue.forEach((v, i) => {
							if (!i) fastSetValuesArray[0] = v;
							else if (i === 1) {
								fastSetValuesArray[1] = v;
								keyframes.push(fastSetValuesArray);
							} else keyframes.push(v);
						});
					} else keyframes = propValue;
				} else {
					keyframesTargetArray[0] = propValue;
					keyframes = keyframesTargetArray;
				}
				let siblings = null;
				let prevTween = null;
				let firstTweenChangeStartTime = NaN;
				let lastTweenChangeEndTime = 0;
				let tweenIndex = 0;
				for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {
					const keyframe = keyframes[tweenIndex];
					if (isObj(keyframe)) key = keyframe;
					else {
						keyObjectTarget.to = keyframe;
						key = keyObjectTarget;
					}
					toFunctionStore.func = null;
					const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);
					let tweenToValue;
					if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
						key = computedToValue;
						tweenToValue = computedToValue.to;
					} else tweenToValue = computedToValue;
					const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
					const keyEasing = key.ease;
					const hasSpring$1 = !isUnd(keyEasing) && !isUnd(
						/** @type {Spring} */
						keyEasing.ease
					);
					const tweenEasing = hasSpring$1 ? keyEasing.ease : keyEasing || tEasing;
					const tweenDuration = hasSpring$1 ? keyEasing.settlingDuration : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);
					const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);
					const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
					const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
					const tweenModifier = key.modifier || tModifier;
					const hasFromvalue = !isUnd(tweenFromValue);
					const hasToValue = !isUnd(tweenToValue);
					const isFromToArray = isArr(tweenToValue);
					const isFromToValue = isFromToArray || hasFromvalue && hasToValue;
					const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
					const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);
					if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;
					let prevSibling = prevTween;
					if (tweenComposition !== compositionTypes.none) {
						if (!siblings) siblings = getTweenSiblings(target, propName);
						let nextSibling = siblings._head;
						while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
							prevSibling = nextSibling;
							nextSibling = nextSibling._nextRep;
							if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) while (nextSibling) {
								overrideTween(nextSibling);
								nextSibling = nextSibling._nextRep;
							}
						}
					}
					if (isFromToValue) {
						decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
						decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
						if (fromTargetObject.t === valueTypes.NUMBER) if (prevSibling) {
							if (prevSibling._valueType === valueTypes.UNIT) {
								fromTargetObject.t = valueTypes.UNIT;
								fromTargetObject.u = prevSibling._unit;
							}
						} else {
							decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), decomposedOriginalValue);
							if (decomposedOriginalValue.t === valueTypes.UNIT) {
								fromTargetObject.t = valueTypes.UNIT;
								fromTargetObject.u = decomposedOriginalValue.u;
							}
						}
					} else {
						if (hasToValue) decomposeRawValue(tweenToValue, toTargetObject);
						else if (prevTween) decomposeTweenValue(prevTween, toTargetObject);
						else decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);
						if (hasFromvalue) decomposeRawValue(tweenFromValue, fromTargetObject);
						else if (prevTween) decomposeTweenValue(prevTween, fromTargetObject);
						else decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);
					}
					if (fromTargetObject.o) fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);
					if (toTargetObject.o) toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
					if (fromTargetObject.t !== toTargetObject.t) {
						if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
							const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
							const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
							notComplexValue.t = valueTypes.COMPLEX;
							notComplexValue.s = cloneArray(complexValue.s);
							notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
						} else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
							const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
							const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
							notUnitValue.t = valueTypes.UNIT;
							notUnitValue.u = unitValue.u;
						} else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
							const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
							const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
							notColorValue.t = valueTypes.COLOR;
							notColorValue.s = colorValue.s;
							notColorValue.d = [
								0,
								0,
								0,
								1
							];
						}
					}
					if (fromTargetObject.u !== toTargetObject.u) {
						let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
						valueToConvert = convertValueUnit(target, valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
					}
					if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {
						const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
						const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
						shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
						shortestValue.s = cloneArray(longestValue.s);
					}
					const tweenUpdateDuration = round(+tweenDuration || minValue, 12);
					let inlineValue = inlineStylesStore[propName];
					if (!isNil(inlineValue)) inlineStylesStore[propName] = null;
					/** @type {Tween} */
					const tween = {
						parent: this,
						id: tweenId++,
						property: propName,
						target,
						_value: null,
						_func: toFunctionStore.func,
						_ease: parseEase(tweenEasing),
						_fromNumbers: cloneArray(fromTargetObject.d),
						_toNumbers: cloneArray(toTargetObject.d),
						_strings: cloneArray(toTargetObject.s),
						_fromNumber: fromTargetObject.n,
						_toNumber: toTargetObject.n,
						_numbers: cloneArray(fromTargetObject.d),
						_number: fromTargetObject.n,
						_unit: toTargetObject.u,
						_modifier: tweenModifier,
						_currentTime: 0,
						_startTime: tweenStartTime,
						_delay: +tweenDelay,
						_updateDuration: tweenUpdateDuration,
						_changeDuration: tweenUpdateDuration,
						_absoluteStartTime: absoluteStartTime,
						_tweenType: tweenType,
						_valueType: toTargetObject.t,
						_composition: tweenComposition,
						_isOverlapped: 0,
						_isOverridden: 0,
						_renderTransforms: 0,
						_inlineValue: inlineValue,
						_prevRep: null,
						_nextRep: null,
						_prevAdd: null,
						_nextAdd: null,
						_prev: null,
						_next: null
					};
					if (tweenComposition !== compositionTypes.none) composeTween(tween, siblings);
					if (isNaN(firstTweenChangeStartTime)) firstTweenChangeStartTime = tween._startTime;
					lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);
					prevTween = tween;
					animationAnimationLength++;
					addChild(this, tween);
				}
				if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) iterationDelay = firstTweenChangeStartTime;
				if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) iterationDuration = lastTweenChangeEndTime;
				if (tweenType === tweenTypes.TRANSFORM) {
					lastTransformGroupIndex = animationAnimationLength - tweenIndex;
					lastTransformGroupLength = animationAnimationLength;
				}
			}
			if (!isNaN(lastTransformGroupIndex)) {
				let i = 0;
				forEachChildren(this, (tween) => {
					if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
						tween._renderTransforms = 1;
						if (tween._composition === compositionTypes.blend) forEachChildren(additive.animation, (additiveTween) => {
							if (additiveTween.id === tween.id) additiveTween._renderTransforms = 1;
						});
					}
					i++;
				});
			}
		}
		if (!targetsLength) console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
		if (iterationDelay) {
			forEachChildren(this, (tween) => {
				if (!(tween._startTime - tween._delay)) tween._delay -= iterationDelay;
				tween._startTime -= iterationDelay;
			});
			iterationDuration -= iterationDelay;
		} else iterationDelay = 0;
		if (!iterationDuration) {
			iterationDuration = minValue;
			this.iterationCount = 0;
		}
		/** @type {TargetsArray} */
		this.targets = parsedTargets;
		/** @type {Number} */
		this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;
		/** @type {Callback<this>} */
		this.onRender = onRender || animDefaults.onRender;
		/** @type {EasingFunction} */
		this._ease = animEase;
		/** @type {Number} */
		this._delay = iterationDelay;
		/** @type {Number} */
		this.iterationDuration = iterationDuration;
		if (!this._autoplay && shouldTriggerRender) this.onRender(this);
	}
	/**
	* @param  {Number} newDuration
	* @return {this}
	*/
	stretch(newDuration) {
		const currentDuration = this.duration;
		if (currentDuration === normalizeTime(newDuration)) return this;
		const timeScale = newDuration / currentDuration;
		forEachChildren(this, (tween) => {
			tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
			tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
			tween._currentTime *= timeScale;
			tween._startTime *= timeScale;
			tween._absoluteStartTime *= timeScale;
		});
		return super.stretch(newDuration);
	}
	/**
	* @return {this}
	*/
	refresh() {
		forEachChildren(this, (tween) => {
			const tweenFunc = tween._func;
			if (tweenFunc) {
				decomposeRawValue(getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType), decomposedOriginalValue);
				decomposeRawValue(tweenFunc(), toTargetObject);
				tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
				tween._fromNumber = decomposedOriginalValue.n;
				tween._toNumbers = cloneArray(toTargetObject.d);
				tween._strings = cloneArray(toTargetObject.s);
				tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
			}
		});
		if (this.duration === minValue) this.restart();
		return this;
	}
	/**
	* Cancel the animation and revert all the values affected by this animation to their original state
	* @return {this}
	*/
	revert() {
		super.revert();
		return cleanInlineStyles(this);
	}
	/**
	* @typedef {this & {then: null}} ResolvedJSAnimation
	*/
	/**
	* @param  {Callback<ResolvedJSAnimation>} [callback]
	* @return Promise<this>
	*/
	then(callback) {
		return super.then(callback);
	}
};
/**
* @param {TargetsParam} targets
* @param {AnimationParams} parameters
* @return {JSAnimation}
*/
var animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();

//#endregion
//#region node_modules/animejs/dist/modules/animatable/animatable.js
/**
* Anime.js - animatable - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
* TargetsParam,
* AnimatableParams,
* AnimationParams,
* TweenParamsOptions,
* Tween,
* AnimatableProperty,
* AnimatableObject,
* } from '../types/index.js';
*/
var Animatable = class {
	/**
	* @param {TargetsParam} targets
	* @param {AnimatableParams} parameters
	*/
	constructor(targets, parameters) {
		if (scope.current) scope.current.register(this);
		const beginHandler = () => {
			if (this.callbacks.completed) this.callbacks.reset();
			this.callbacks.play();
		};
		const pauseHandler = () => {
			if (this.callbacks.completed) return;
			let paused = true;
			for (let name in this.animations) if (!this.animations[name].paused && paused) {
				paused = false;
				break;
			}
			if (paused) this.callbacks.complete();
		};
		/** @type {AnimationParams} */
		const globalParams = {
			onBegin: beginHandler,
			onComplete: pauseHandler,
			onPause: pauseHandler
		};
		/** @type {AnimationParams} */
		const callbacksAnimationParams = {
			v: 1,
			autoplay: false
		};
		const properties = {};
		this.targets = [];
		this.animations = {};
		/** @type {JSAnimation|null} */
		this.callbacks = null;
		if (isUnd(targets) || isUnd(parameters)) return;
		for (let propName in parameters) {
			const paramValue = parameters[propName];
			if (isKey(propName)) properties[propName] = paramValue;
			else if (stringStartsWith(propName, "on")) callbacksAnimationParams[propName] = paramValue;
			else globalParams[propName] = paramValue;
		}
		this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);
		for (let propName in properties) {
			const propValue = properties[propName];
			const isObjValue = isObj(propValue);
			/** @type {TweenParamsOptions} */
			let propParams = {};
			let to = "+=0";
			if (isObjValue) {
				const unit = propValue.unit;
				if (isStr(unit)) to += unit;
			} else propParams.duration = propValue;
			propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
			const animParams = mergeObjects(globalParams, propParams);
			animParams.composition = compositionTypes.replace;
			animParams.autoplay = false;
			const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
			if (!this.targets.length) this.targets.push(...animation.targets);
			/** @type {AnimatableProperty} */
			this[propName] = (to$1, duration, ease) => {
				const tween = animation._head;
				if (isUnd(to$1) && tween) {
					const numbers = tween._numbers;
					if (numbers && numbers.length) return numbers;
					else return tween._modifier(tween._number);
				} else {
					forEachChildren(animation, (tween$1) => {
						if (isArr(to$1)) {
							for (let i = 0, l = to$1.length; i < l; i++) if (!isUnd(tween$1._numbers[i])) {
								tween$1._fromNumbers[i] = tween$1._modifier(tween$1._numbers[i]);
								tween$1._toNumbers[i] = to$1[i];
							}
						} else {
							tween$1._fromNumber = tween$1._modifier(tween$1._number);
							tween$1._toNumber = to$1;
						}
						if (!isUnd(ease)) tween$1._ease = parseEase(ease);
						tween$1._currentTime = 0;
					});
					if (!isUnd(duration)) animation.stretch(duration);
					animation.reset(true).resume();
					return this;
				}
			};
		}
	}
	revert() {
		for (let propName in this.animations) {
			this[propName] = noop;
			this.animations[propName].revert();
		}
		this.animations = {};
		this.targets.length = 0;
		if (this.callbacks) this.callbacks.revert();
		return this;
	}
};
/**
* @param {TargetsParam} targets
* @param {AnimatableParams} parameters
* @return {AnimatableObject}
*/
var createAnimatable = (targets, parameters) => new Animatable(targets, parameters);

//#endregion
//#region node_modules/animejs/dist/modules/utils/number.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
var number_exports = /* @__PURE__ */ __export({
	clamp: () => clamp,
	damp: () => damp,
	degToRad: () => degToRad,
	lerp: () => lerp,
	mapRange: () => mapRange,
	padEnd: () => padEnd,
	padStart: () => padStart,
	radToDeg: () => radToDeg,
	round: () => round,
	roundPad: () => roundPad,
	snap: () => snap,
	wrap: () => wrap
});
/**
* Rounds a number to fixed decimal places
* @param  {Number|String} v - Value to round
* @param  {Number} decimalLength - Number of decimal places
* @return {String}
*/
var roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);
/**
* Pads the start of a value with a string
* @param  {Number} v - Value to pad
* @param  {Number} totalLength - Target length
* @param  {String} padString - String to pad with
* @return {String}
*/
var padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);
/**
* Pads the end of a value with a string
* @param  {Number} v - Value to pad
* @param  {Number} totalLength - Target length
* @param  {String} padString - String to pad with
* @return {String}
*/
var padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);
/**
* Wraps a value within a range
* @param  {Number} v - Value to wrap
* @param  {Number} min - Minimum boundary
* @param  {Number} max - Maximum boundary
* @return {Number}
*/
var wrap = (v, min, max$1) => ((v - min) % (max$1 - min) + (max$1 - min)) % (max$1 - min) + min;
/**
* Maps a value from one range to another
* @param  {Number} value - Input value
* @param  {Number} inLow - Input range minimum
* @param  {Number} inHigh - Input range maximum
* @param  {Number} outLow - Output range minimum
* @param  {Number} outHigh - Output range maximum
* @return {Number}
*/
var mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + (value - inLow) / (inHigh - inLow) * (outHigh - outLow);
/**
* Converts degrees to radians
* @param  {Number} degrees - Angle in degrees
* @return {Number}
*/
var degToRad = (degrees) => degrees * Math.PI / 180;
/**
* Converts radians to degrees
* @param  {Number} radians - Angle in radians
* @return {Number}
*/
var radToDeg = (radians) => radians * 180 / Math.PI;
/**
* Frame rate independent damped lerp
* Based on: https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
*
* @param  {Number} start - Starting value
* @param  {Number} end - Target value
* @param  {Number} deltaTime - Delta time in ms
* @param  {Number} factor - Interpolation factor in the range [0, 1]
* @return {Number} The interpolated value
*/
var damp = (start, end, deltaTime, factor) => {
	return !factor ? start : factor === 1 ? end : lerp(start, end, 1 - Math.exp(-factor * deltaTime * .1));
};

//#endregion
//#region node_modules/animejs/dist/modules/easings/spring/index.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   JSAnimation,
* } from '../../animation/animation.js'
*/
/**
* @import {
*   EasingFunction,
*   SpringParams,
*   Callback,
* } from '../../types/index.js'
*/
var maxSpringParamValue = K * 10;
var Spring = class {
	/**
	* @param {SpringParams} [parameters]
	*/
	constructor(parameters = {}) {
		const hasBounceOrDuration = !isUnd(parameters.bounce) || !isUnd(parameters.duration);
		this.timeStep = .02;
		this.restThreshold = 5e-4;
		this.restDuration = 200;
		this.maxDuration = 6e4;
		this.maxRestSteps = this.restDuration / this.timeStep / K;
		this.maxIterations = this.maxDuration / this.timeStep / K;
		this.bn = clamp(setValue(parameters.bounce, .5), -1, 1);
		this.pd = clamp(setValue(parameters.duration, 628), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale);
		this.m = clamp(setValue(parameters.mass, 1), 1, maxSpringParamValue);
		this.s = clamp(setValue(parameters.stiffness, 100), minValue, maxSpringParamValue);
		this.d = clamp(setValue(parameters.damping, 10), minValue, maxSpringParamValue);
		this.v = clamp(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);
		this.w0 = 0;
		this.zeta = 0;
		this.wd = 0;
		this.b = 0;
		this.completed = false;
		this.solverDuration = 0;
		this.settlingDuration = 0;
		/** @type {JSAnimation} */
		this.parent = null;
		/** @type {Callback<JSAnimation>} */
		this.onComplete = parameters.onComplete || noop;
		if (hasBounceOrDuration) this.calculateSDFromBD();
		this.compute();
		/** @type {EasingFunction} */
		this.ease = (t) => {
			const currentTime = t * this.settlingDuration;
			const completed = this.completed;
			const perceivedTime = this.pd;
			if (currentTime >= perceivedTime && !completed) {
				this.completed = true;
				this.onComplete(this.parent);
			}
			if (currentTime < perceivedTime && completed) this.completed = false;
			return t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);
		};
	}
	/** @type {EasingFunction} */
	solve(time) {
		const { zeta, w0, wd, b } = this;
		let t = time;
		if (zeta < 1) t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));
		else if (zeta === 1) t = (1 + b * t) * exp(-t * w0);
		else t = ((1 + b) * exp((-zeta * w0 + wd) * t) + (1 - b) * exp((-zeta * w0 - wd) * t)) / 2;
		return 1 - t;
	}
	calculateSDFromBD() {
		const pds = globals.timeScale === 1 ? this.pd / K : this.pd;
		this.m = 1;
		this.v = 0;
		this.s = pow(2 * PI / pds, 2);
		if (this.bn >= 0) this.d = (1 - this.bn) * 4 * PI / pds;
		else this.d = 4 * PI / (pds * (1 + this.bn));
		this.s = round(clamp(this.s, minValue, maxSpringParamValue), 3);
		this.d = round(clamp(this.d, minValue, 300), 3);
	}
	calculateBDFromSD() {
		const pds = 2 * PI / sqrt(this.s);
		this.pd = pds * (globals.timeScale === 1 ? K : 1);
		if (this.d / (2 * sqrt(this.s)) <= 1) this.bn = 1 - this.d * pds / (4 * PI);
		else this.bn = 4 * PI / (this.d * pds) - 1;
		this.bn = round(clamp(this.bn, -1, 1), 3);
		this.pd = round(clamp(this.pd, 10 * globals.timeScale, maxSpringParamValue * globals.timeScale), 3);
	}
	compute() {
		const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;
		const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);
		const bouncedZeta = this.zeta = d / (2 * sqrt(s * m));
		if (bouncedZeta < 1) {
			this.wd = w0 * sqrt(1 - bouncedZeta * bouncedZeta);
			this.b = (bouncedZeta * w0 + -v) / this.wd;
		} else if (bouncedZeta === 1) {
			this.wd = 0;
			this.b = -v + w0;
		} else {
			this.wd = w0 * sqrt(bouncedZeta * bouncedZeta - 1);
			this.b = (bouncedZeta * w0 + -v) / this.wd;
		}
		let solverTime = 0;
		let restSteps = 0;
		let iterations = 0;
		while (restSteps <= maxRestSteps && iterations <= maxIterations) {
			if (abs(1 - this.solve(solverTime)) < restThreshold) restSteps++;
			else restSteps = 0;
			this.solverDuration = solverTime;
			solverTime += timeStep;
			iterations++;
		}
		this.settlingDuration = round(this.solverDuration * K, 0) * globals.timeScale;
	}
	get bounce() {
		return this.bn;
	}
	set bounce(v) {
		this.bn = clamp(setValue(v, 1), -1, 1);
		this.calculateSDFromBD();
		this.compute();
	}
	get duration() {
		return this.pd;
	}
	set duration(v) {
		this.pd = clamp(setValue(v, 1), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale);
		this.calculateSDFromBD();
		this.compute();
	}
	get stiffness() {
		return this.s;
	}
	set stiffness(v) {
		this.s = clamp(setValue(v, 100), minValue, maxSpringParamValue);
		this.calculateBDFromSD();
		this.compute();
	}
	get damping() {
		return this.d;
	}
	set damping(v) {
		this.d = clamp(setValue(v, 10), minValue, maxSpringParamValue);
		this.calculateBDFromSD();
		this.compute();
	}
	get mass() {
		return this.m;
	}
	set mass(v) {
		this.m = clamp(setValue(v, 1), 1, maxSpringParamValue);
		this.compute();
	}
	get velocity() {
		return this.v;
	}
	set velocity(v) {
		this.v = clamp(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);
		this.compute();
	}
};
/**
* @param {SpringParams} [parameters]
* @returns {Spring}
*/
var spring = (parameters) => new Spring(parameters);
/**
* @deprecated createSpring() is deprecated use spring() instead
*
* @param {SpringParams} [parameters]
* @returns {Spring}
*/
var createSpring = (parameters) => {
	console.warn("createSpring() is deprecated use spring() instead");
	return new Spring(parameters);
};

//#endregion
//#region node_modules/animejs/dist/modules/waapi/composition.js
/**
* Anime.js - waapi - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DOMTarget,
* } from '../types/index.js'
*/
/**
* @import {
*   WAAPIAnimation,
* } from '../waapi/waapi.js'
*/
var WAAPIAnimationsLookups = {
	_head: null,
	_tail: null
};
/**
* @param {DOMTarget} $el
* @param {String} [property]
* @param {WAAPIAnimation} [parent]
* @return {globalThis.Animation}
*/
var removeWAAPIAnimation = ($el, property, parent) => {
	let nextLookup = WAAPIAnimationsLookups._head;
	let anim;
	while (nextLookup) {
		const next = nextLookup._next;
		const matchTarget = nextLookup.$el === $el;
		const matchProperty = !property || nextLookup.property === property;
		const matchParent = !parent || nextLookup.parent === parent;
		if (matchTarget && matchProperty && matchParent) {
			anim = nextLookup.animation;
			try {
				anim.commitStyles();
			} catch {}
			anim.cancel();
			removeChild(WAAPIAnimationsLookups, nextLookup);
			const lookupParent = nextLookup.parent;
			if (lookupParent) {
				lookupParent._completed++;
				if (lookupParent.animations.length === lookupParent._completed) {
					lookupParent.completed = true;
					lookupParent.paused = true;
					if (!lookupParent.muteCallbacks) {
						lookupParent.onComplete(lookupParent);
						lookupParent._resolve(lookupParent);
					}
				}
			}
		}
		nextLookup = next;
	}
	return anim;
};
/**
* @param {WAAPIAnimation} parent
* @param {DOMTarget} $el
* @param {String} property
* @param {PropertyIndexedKeyframes} keyframes
* @param {KeyframeAnimationOptions} params
* @retun {globalThis.Animation}
*/
var addWAAPIAnimation = (parent, $el, property, keyframes$1, params) => {
	const animation = $el.animate(keyframes$1, params);
	const animTotalDuration = params.delay + +params.duration * params.iterations;
	animation.playbackRate = parent._speed;
	if (parent.paused) animation.pause();
	if (parent.duration < animTotalDuration) {
		parent.duration = animTotalDuration;
		parent.controlAnimation = animation;
	}
	parent.animations.push(animation);
	removeWAAPIAnimation($el, property);
	addChild(WAAPIAnimationsLookups, {
		parent,
		animation,
		$el,
		property,
		_next: null,
		_prev: null
	});
	const handleRemove = () => {
		removeWAAPIAnimation($el, property, parent);
	};
	animation.oncancel = handleRemove;
	animation.onremove = handleRemove;
	if (!parent.persist) animation.onfinish = handleRemove;
	return animation;
};

//#endregion
//#region node_modules/animejs/dist/modules/utils/target.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Renderable,
*   DOMTargetSelector,
*   JSTargetsParam,
*   DOMTargetsParam,
*   TargetsParam,
*   DOMTarget,
*   AnimationParams,
*   TargetsArray,
* } from '../types/index.js'
*/
/**
* @import {
*   WAAPIAnimation
* } from '../waapi/waapi.js'
*/
/**
* @overload
* @param  {DOMTargetSelector} targetSelector
* @param  {String} propName
* @return {String}
*
* @overload
* @param  {JSTargetsParam} targetSelector
* @param  {String} propName
* @return {Number|String}
*
* @overload
* @param  {DOMTargetsParam} targetSelector
* @param  {String} propName
* @param  {String} unit
* @return {String}
*
* @overload
* @param  {TargetsParam} targetSelector
* @param  {String} propName
* @param  {Boolean} unit
* @return {Number}
*
* @param  {TargetsParam} targetSelector
* @param  {String} propName
* @param  {String|Boolean} [unit]
*/
function get(targetSelector, propName, unit) {
	const targets = registerTargets(targetSelector);
	if (!targets.length) return;
	const [target] = targets;
	let originalValue = getOriginalAnimatableValue(target, sanitizePropertyName(propName, target, getTweenType(target, propName)));
	if (isUnd(unit)) return originalValue;
	else {
		decomposeRawValue(originalValue, decomposedOriginalValue);
		if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) if (unit === false) return decomposedOriginalValue.n;
		else {
			const convertedValue = convertValueUnit(target, decomposedOriginalValue, unit, false);
			return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;
		}
	}
}
/**
* @param  {TargetsParam} targets
* @param  {AnimationParams} parameters
* @return {JSAnimation}
*/
var set = (targets, parameters) => {
	if (isUnd(parameters)) return;
	parameters.duration = minValue;
	parameters.composition = setValue(parameters.composition, compositionTypes.none);
	return new JSAnimation(targets, parameters, null, 0, true).resume();
};
/**
* @param  {TargetsParam} targets
* @param  {Renderable|WAAPIAnimation} [renderable]
* @param  {String} [propertyName]
* @return {TargetsArray}
*/
var remove = (targets, renderable, propertyName) => {
	const targetsArray = parseTargets(targets);
	for (let i = 0, l = targetsArray.length; i < l; i++) removeWAAPIAnimation(targetsArray[i], propertyName, renderable && renderable.controlAnimation && renderable);
	removeTargetsFromRenderable(targetsArray, renderable, propertyName);
	return targetsArray;
};

//#endregion
//#region node_modules/animejs/dist/modules/draggable/draggable.js
/**
* Anime.js - draggable - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   DOMTarget,
*   DOMTargetSelector,
*   DraggableCursorParams,
*   DraggableDragThresholdParams,
*   TargetsParam,
*   DraggableParams,
*   EasingFunction,
*   Callback,
*   AnimatableParams,
*   DraggableAxisParam,
*   AnimatableObject,
*   EasingParam,
* } from '../types/index.js'
*/
/**
* @import {
*   Spring,
* } from '../easings/spring/index.js'
*/
/**
* @param {Event} e
*/
var preventDefault = (e) => {
	if (e.cancelable) e.preventDefault();
};
var DOMProxy = class {
	/** @param {Object} el */
	constructor(el) {
		this.el = el;
		this.zIndex = 0;
		this.parentElement = null;
		this.classList = {
			add: noop,
			remove: noop
		};
	}
	get x() {
		return this.el.x || 0;
	}
	set x(v) {
		this.el.x = v;
	}
	get y() {
		return this.el.y || 0;
	}
	set y(v) {
		this.el.y = v;
	}
	get width() {
		return this.el.width || 0;
	}
	set width(v) {
		this.el.width = v;
	}
	get height() {
		return this.el.height || 0;
	}
	set height(v) {
		this.el.height = v;
	}
	getBoundingClientRect() {
		return {
			top: this.y,
			right: this.x,
			bottom: this.y + this.height,
			left: this.x + this.width
		};
	}
};
var Transforms = class {
	/**
	* @param {DOMTarget|DOMProxy} $el
	*/
	constructor($el) {
		this.$el = $el;
		this.inlineTransforms = [];
		this.point = new DOMPoint();
		this.inversedMatrix = this.getMatrix().inverse();
	}
	/**
	* @param {Number} x
	* @param {Number} y
	* @return {DOMPoint}
	*/
	normalizePoint(x, y) {
		this.point.x = x;
		this.point.y = y;
		return this.point.matrixTransform(this.inversedMatrix);
	}
	/**
	* @callback TraverseParentsCallback
	* @param {DOMTarget} $el
	* @param {Number} i
	*/
	/**
	* @param {TraverseParentsCallback} cb
	*/
	traverseUp(cb) {
		let $el = this.$el.parentElement, i = 0;
		while ($el && $el !== doc) {
			cb($el, i);
			$el = $el.parentElement;
			i++;
		}
	}
	getMatrix() {
		const matrix = new DOMMatrix();
		this.traverseUp(($el) => {
			const transformValue = getComputedStyle($el).transform;
			if (transformValue) {
				const elMatrix = new DOMMatrix(transformValue);
				matrix.preMultiplySelf(elMatrix);
			}
		});
		return matrix;
	}
	remove() {
		this.traverseUp(($el, i) => {
			this.inlineTransforms[i] = $el.style.transform;
			$el.style.transform = "none";
		});
	}
	revert() {
		this.traverseUp(($el, i) => {
			const ct = this.inlineTransforms[i];
			if (ct === "") $el.style.removeProperty("transform");
			else $el.style.transform = ct;
		});
	}
};
/**
* @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams|DraggableDragThresholdParams} T
* @param {T | ((draggable: Draggable) => T)} value
* @param {Draggable} draggable
* @return {T}
*/
var parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? value(draggable) : value;
var zIndex = 0;
var Draggable = class {
	/**
	* @param {TargetsParam} target
	* @param {DraggableParams} [parameters]
	*/
	constructor(target, parameters = {}) {
		if (!target) return;
		if (scope.current) scope.current.register(this);
		const paramX = parameters.x;
		const paramY = parameters.y;
		const trigger = parameters.trigger;
		const modifier = parameters.modifier;
		const ease = parameters.releaseEase;
		const customEase = ease && parseEase(ease);
		const hasSpring = !isUnd(ease) && !isUnd(
			/** @type {Spring} */
			ease.ease
		);
		const xProp = isObj(paramX) && !isUnd(
			/** @type {Object} */
			paramX.mapTo
		) ? paramX.mapTo : "translateX";
		const yProp = isObj(paramY) && !isUnd(
			/** @type {Object} */
			paramY.mapTo
		) ? paramY.mapTo : "translateY";
		const container = parseDraggableFunctionParameter(parameters.container, this);
		this.containerArray = isArr(container) ? container : null;
		this.$container = container && !this.containerArray ? parseTargets(container)[0] : doc.body;
		this.useWin = this.$container === doc.body;
		/** @type {Window | HTMLElement} */
		this.$scrollContainer = this.useWin ? win : this.$container;
		this.$target = isObj(target) ? new DOMProxy(target) : parseTargets(target)[0];
		this.$trigger = parseTargets(trigger ? trigger : target)[0];
		this.fixed = get(this.$target, "position") === "fixed";
		this.isFinePointer = true;
		/** @type {[Number, Number, Number, Number]} */
		this.containerPadding = [
			0,
			0,
			0,
			0
		];
		/** @type {Number} */
		this.containerFriction = 0;
		/** @type {Number} */
		this.releaseContainerFriction = 0;
		/** @type {Number|Array<Number>} */
		this.snapX = 0;
		/** @type {Number|Array<Number>} */
		this.snapY = 0;
		/** @type {Number} */
		this.scrollSpeed = 0;
		/** @type {Number} */
		this.scrollThreshold = 0;
		/** @type {Number} */
		this.dragSpeed = 0;
		/** @type {Number} */
		this.dragThreshold = 3;
		/** @type {Number} */
		this.maxVelocity = 0;
		/** @type {Number} */
		this.minVelocity = 0;
		/** @type {Number} */
		this.velocityMultiplier = 0;
		/** @type {Boolean|DraggableCursorParams} */
		this.cursor = false;
		/** @type {Spring} */
		this.releaseXSpring = hasSpring ? ease : spring({
			mass: setValue(parameters.releaseMass, 1),
			stiffness: setValue(parameters.releaseStiffness, 80),
			damping: setValue(parameters.releaseDamping, 20)
		});
		/** @type {Spring} */
		this.releaseYSpring = hasSpring ? ease : spring({
			mass: setValue(parameters.releaseMass, 1),
			stiffness: setValue(parameters.releaseStiffness, 80),
			damping: setValue(parameters.releaseDamping, 20)
		});
		/** @type {EasingFunction} */
		this.releaseEase = customEase || eases.outQuint;
		/** @type {Boolean} */
		this.hasReleaseSpring = hasSpring;
		/** @type {Callback<this>} */
		this.onGrab = parameters.onGrab || noop;
		/** @type {Callback<this>} */
		this.onDrag = parameters.onDrag || noop;
		/** @type {Callback<this>} */
		this.onRelease = parameters.onRelease || noop;
		/** @type {Callback<this>} */
		this.onUpdate = parameters.onUpdate || noop;
		/** @type {Callback<this>} */
		this.onSettle = parameters.onSettle || noop;
		/** @type {Callback<this>} */
		this.onSnap = parameters.onSnap || noop;
		/** @type {Callback<this>} */
		this.onResize = parameters.onResize || noop;
		/** @type {Callback<this>} */
		this.onAfterResize = parameters.onAfterResize || noop;
		/** @type {[Number, Number]} */
		this.disabled = [0, 0];
		/** @type {AnimatableParams} */
		const animatableParams = {};
		if (modifier) animatableParams.modifier = modifier;
		if (isUnd(paramX) || paramX === true) animatableParams[xProp] = 0;
		else if (isObj(paramX)) {
			const paramXObject = paramX;
			const animatableXParams = {};
			if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;
			if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;
			animatableParams[xProp] = animatableXParams;
		} else if (paramX === false) {
			animatableParams[xProp] = 0;
			this.disabled[0] = 1;
		}
		if (isUnd(paramY) || paramY === true) animatableParams[yProp] = 0;
		else if (isObj(paramY)) {
			const paramYObject = paramY;
			const animatableYParams = {};
			if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;
			if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;
			animatableParams[yProp] = animatableYParams;
		} else if (paramY === false) {
			animatableParams[yProp] = 0;
			this.disabled[1] = 1;
		}
		/** @type {AnimatableObject} */
		this.animate = new Animatable(this.$target, animatableParams);
		this.xProp = xProp;
		this.yProp = yProp;
		this.destX = 0;
		this.destY = 0;
		this.deltaX = 0;
		this.deltaY = 0;
		this.scroll = {
			x: 0,
			y: 0
		};
		/** @type {[Number, Number, Number, Number]} */
		this.coords = [
			this.x,
			this.y,
			0,
			0
		];
		/** @type {[Number, Number]} */
		this.snapped = [0, 0];
		/** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
		this.pointer = [
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		];
		/** @type {[Number, Number]} */
		this.scrollView = [0, 0];
		/** @type {[Number, Number, Number, Number]} */
		this.dragArea = [
			0,
			0,
			0,
			0
		];
		/** @type {[Number, Number, Number, Number]} */
		this.containerBounds = [
			-maxValue,
			maxValue,
			maxValue,
			-maxValue
		];
		/** @type {[Number, Number, Number, Number]} */
		this.scrollBounds = [
			0,
			0,
			0,
			0
		];
		/** @type {[Number, Number, Number, Number]} */
		this.targetBounds = [
			0,
			0,
			0,
			0
		];
		/** @type {[Number, Number]} */
		this.window = [0, 0];
		/** @type {[Number, Number, Number]} */
		this.velocityStack = [
			0,
			0,
			0
		];
		/** @type {Number} */
		this.velocityStackIndex = 0;
		/** @type {Number} */
		this.velocityTime = now();
		/** @type {Number} */
		this.velocity = 0;
		/** @type {Number} */
		this.angle = 0;
		/** @type {JSAnimation} */
		this.cursorStyles = null;
		/** @type {JSAnimation} */
		this.triggerStyles = null;
		/** @type {JSAnimation} */
		this.bodyStyles = null;
		/** @type {JSAnimation} */
		this.targetStyles = null;
		/** @type {JSAnimation} */
		this.touchActionStyles = null;
		this.transforms = new Transforms(this.$target);
		this.overshootCoords = {
			x: 0,
			y: 0
		};
		this.overshootTicker = new Timer({
			autoplay: false,
			onUpdate: () => {
				this.updated = true;
				this.manual = true;
				if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);
				if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);
			},
			onComplete: () => {
				this.manual = false;
				if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);
				if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);
			}
		}, null, 0).init();
		this.updateTicker = new Timer({
			autoplay: false,
			onUpdate: () => this.update()
		}, null, 0).init();
		this.contained = !isUnd(container);
		this.manual = false;
		this.grabbed = false;
		this.dragged = false;
		this.updated = false;
		this.released = false;
		this.canScroll = false;
		this.enabled = false;
		this.initialized = false;
		this.activeProp = this.disabled[1] ? xProp : yProp;
		this.animate.callbacks.onRender = () => {
			const hasUpdated = this.updated;
			const hasReleased = !(this.grabbed && hasUpdated) && this.released;
			const x = this.x;
			const y = this.y;
			const dx = x - this.coords[2];
			const dy = y - this.coords[3];
			this.deltaX = dx;
			this.deltaY = dy;
			this.coords[2] = x;
			this.coords[3] = y;
			if (hasUpdated && (dx || dy)) this.onUpdate(this);
			if (!hasReleased) this.updated = false;
			else {
				this.computeVelocity(dx, dy);
				this.angle = atan2(dy, dx);
			}
		};
		this.animate.callbacks.onComplete = () => {
			if (!this.grabbed && this.released) this.released = false;
			if (!this.manual) {
				this.deltaX = 0;
				this.deltaY = 0;
				this.velocity = 0;
				this.velocityStack[0] = 0;
				this.velocityStack[1] = 0;
				this.velocityStack[2] = 0;
				this.velocityStackIndex = 0;
				this.onSettle(this);
			}
		};
		this.resizeTicker = new Timer({
			autoplay: false,
			duration: 150 * globals.timeScale,
			onComplete: () => {
				this.onResize(this);
				this.refresh();
				this.onAfterResize(this);
			}
		}).init();
		this.parameters = parameters;
		this.resizeObserver = new ResizeObserver(() => {
			if (this.initialized) this.resizeTicker.restart();
			else this.initialized = true;
		});
		this.enable();
		this.refresh();
		this.resizeObserver.observe(this.$container);
		if (!isObj(target)) this.resizeObserver.observe(this.$target);
	}
	/**
	* @param  {Number} dx
	* @param  {Number} dy
	* @return {Number}
	*/
	computeVelocity(dx, dy) {
		const prevTime = this.velocityTime;
		const curTime = now();
		const elapsed = curTime - prevTime;
		if (elapsed < 17) return this.velocity;
		this.velocityTime = curTime;
		const velocityStack = this.velocityStack;
		const vMul = this.velocityMultiplier;
		const minV = this.minVelocity;
		const maxV = this.maxVelocity;
		const vi = this.velocityStackIndex;
		velocityStack[vi] = round(clamp(sqrt(dx * dx + dy * dy) / elapsed * vMul, minV, maxV), 5);
		const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
		this.velocity = velocity;
		this.velocityStackIndex = (vi + 1) % 3;
		return velocity;
	}
	/**
	* @param {Number}  x
	* @param {Boolean} [muteUpdateCallback]
	* @return {this}
	*/
	setX(x, muteUpdateCallback = false) {
		if (this.disabled[0]) return;
		const v = round(x, 5);
		this.overshootTicker.pause();
		this.manual = true;
		this.updated = !muteUpdateCallback;
		this.destX = v;
		this.snapped[0] = snap(v, this.snapX);
		this.animate[this.xProp](v, 0);
		this.manual = false;
		return this;
	}
	/**
	* @param {Number}  y
	* @param {Boolean} [muteUpdateCallback]
	* @return {this}
	*/
	setY(y, muteUpdateCallback = false) {
		if (this.disabled[1]) return;
		const v = round(y, 5);
		this.overshootTicker.pause();
		this.manual = true;
		this.updated = !muteUpdateCallback;
		this.destY = v;
		this.snapped[1] = snap(v, this.snapY);
		this.animate[this.yProp](v, 0);
		this.manual = false;
		return this;
	}
	get x() {
		return round(this.animate[this.xProp](), globals.precision);
	}
	set x(x) {
		this.setX(x, false);
	}
	get y() {
		return round(this.animate[this.yProp](), globals.precision);
	}
	set y(y) {
		this.setY(y, false);
	}
	get progressX() {
		return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
	}
	set progressX(x) {
		this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
	}
	get progressY() {
		return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
	}
	set progressY(y) {
		this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
	}
	updateScrollCoords() {
		const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
		const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
		const [cpt, cpr, cpb, cpl] = this.containerPadding;
		const threshold = this.scrollThreshold;
		this.scroll.x = sx;
		this.scroll.y = sy;
		this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
		this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
		this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
		this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
	}
	updateBoundingValues() {
		const $container = this.$container;
		if (!$container) return;
		const cx = this.x;
		const cy = this.y;
		const cx2 = this.coords[2];
		const cy2 = this.coords[3];
		this.coords[2] = 0;
		this.coords[3] = 0;
		this.setX(0, true);
		this.setY(0, true);
		this.transforms.remove();
		const iw = this.window[0] = win.innerWidth;
		const ih = this.window[1] = win.innerHeight;
		const uw = this.useWin;
		const sw = $container.scrollWidth;
		const sh = $container.scrollHeight;
		const fx = this.fixed;
		const transformContainerRect = $container.getBoundingClientRect();
		const [cpt, cpr, cpb, cpl] = this.containerPadding;
		this.dragArea[0] = uw ? 0 : transformContainerRect.left;
		this.dragArea[1] = uw ? 0 : transformContainerRect.top;
		this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;
		this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;
		this.updateScrollCoords();
		const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
		this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);
		this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);
		const containerOverflow = get($container, "overflow");
		const visibleOverflow = containerOverflow === "visible";
		const hiddenOverflow = containerOverflow === "hidden";
		this.canScroll = fx ? false : this.contained && ($container === doc.body && visibleOverflow || !hiddenOverflow && !visibleOverflow) && (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) && (!this.containerArray || this.containerArray && !isArr(this.containerArray));
		if (this.contained) {
			const sx = this.scroll.x;
			const sy = this.scroll.y;
			const canScroll = this.canScroll;
			const targetRect = this.$target.getBoundingClientRect();
			const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
			const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
			const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
			const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
			this.targetBounds[0] = round(targetRect.top + sy - (uw ? 0 : top), 0);
			this.targetBounds[1] = round(targetRect.right + sx - (uw ? iw : right), 0);
			this.targetBounds[2] = round(targetRect.bottom + sy - (uw ? ih : bottom), 0);
			this.targetBounds[3] = round(targetRect.left + sx - (uw ? 0 : left), 0);
			if (this.containerArray) {
				this.containerBounds[0] = this.containerArray[0] + cpt;
				this.containerBounds[1] = this.containerArray[1] - cpr;
				this.containerBounds[2] = this.containerArray[2] - cpb;
				this.containerBounds[3] = this.containerArray[3] + cpl;
			} else {
				this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);
				this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);
				this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
				this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);
			}
		}
		this.transforms.revert();
		this.coords[2] = cx2;
		this.coords[3] = cy2;
		this.setX(cx, true);
		this.setY(cy, true);
	}
	/**
	* @param  {Array} bounds
	* @param  {Number} x
	* @param  {Number} y
	* @return {Number}
	*/
	isOutOfBounds(bounds, x, y) {
		if (!this.contained) return 0;
		const [bt, br, bb, bl] = bounds;
		const [dx, dy] = this.disabled;
		const obx = !dx && x < bl || !dx && x > br;
		const oby = !dy && y < bt || !dy && y > bb;
		return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
	}
	refresh() {
		const params = this.parameters;
		const paramX = params.x;
		const paramY = params.y;
		const container = parseDraggableFunctionParameter(params.container, this);
		const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
		const containerPadding = isArr(cp) ? cp : [
			cp,
			cp,
			cp,
			cp
		];
		const cx = this.x;
		const cy = this.y;
		const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
		const cursorStyles = {
			onHover: "grab",
			onGrab: "grabbing"
		};
		if (parsedCursorStyles) {
			const { onHover, onGrab } = parsedCursorStyles;
			if (onHover) cursorStyles.onHover = onHover;
			if (onGrab) cursorStyles.onGrab = onGrab;
		}
		const parsedDragThreshold = parseDraggableFunctionParameter(params.dragThreshold, this);
		const dragThreshold = {
			mouse: 3,
			touch: 7
		};
		if (isNum(parsedDragThreshold)) {
			dragThreshold.mouse = parsedDragThreshold;
			dragThreshold.touch = parsedDragThreshold;
		} else if (parsedDragThreshold) {
			const { mouse, touch } = parsedDragThreshold;
			if (!isUnd(mouse)) dragThreshold.mouse = mouse;
			if (!isUnd(touch)) dragThreshold.touch = touch;
		}
		this.containerArray = isArr(container) ? container : null;
		this.$container = container && !this.containerArray ? parseTargets(container)[0] : doc.body;
		this.useWin = this.$container === doc.body;
		/** @type {Window | HTMLElement} */
		this.$scrollContainer = this.useWin ? win : this.$container;
		this.isFinePointer = matchMedia("(pointer:fine)").matches;
		this.containerPadding = setValue(containerPadding, [
			0,
			0,
			0,
			0
		]);
		this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
		this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
		this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
		this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
		this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
		this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
		this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
		this.dragThreshold = this.isFinePointer ? dragThreshold.mouse : dragThreshold.touch;
		this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
		this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
		this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
		this.cursor = parsedCursorStyles === false ? false : cursorStyles;
		this.updateBoundingValues();
		const [bt, br, bb, bl] = this.containerBounds;
		this.setX(clamp(cx, bl, br), true);
		this.setY(clamp(cy, bt, bb), true);
	}
	update() {
		this.updateScrollCoords();
		if (this.canScroll) {
			const [cpt, cpr, cpb, cpl] = this.containerPadding;
			const [sw, sh] = this.scrollView;
			const daw = this.dragArea[2];
			const dah = this.dragArea[3];
			const csx = this.scroll.x;
			const csy = this.scroll.y;
			const nsw = this.$container.scrollWidth;
			const nsh = this.$container.scrollHeight;
			const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;
			const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;
			const swd = sw - csw;
			const shd = sh - csh;
			if (this.dragged && swd > 0) {
				this.coords[0] -= swd;
				this.scrollView[0] = csw;
			}
			if (this.dragged && shd > 0) {
				this.coords[1] -= shd;
				this.scrollView[1] = csh;
			}
			const s = this.scrollSpeed * 10;
			const threshold = this.scrollThreshold;
			const [x, y] = this.coords;
			const [st, sr, sb, sl] = this.scrollBounds;
			const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);
			const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);
			const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);
			const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);
			if (t || b || l || r) {
				const [nx, ny] = this.disabled;
				let scrollX = csx;
				let scrollY = csy;
				if (!nx) {
					scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);
					this.coords[0] -= csx - scrollX;
				}
				if (!ny) {
					scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);
					this.coords[1] -= csy - scrollY;
				}
				if (this.useWin) this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
				else this.$scrollContainer.scrollTo(scrollX, scrollY);
			}
		}
		const [ct, cr, cb, cl] = this.containerBounds;
		const [px1, py1, px2, py2, px3, py3] = this.pointer;
		this.coords[0] += (px1 - px3) * this.dragSpeed;
		this.coords[1] += (py1 - py3) * this.dragSpeed;
		this.pointer[4] = px1;
		this.pointer[5] = py1;
		const [cx, cy] = this.coords;
		const [sx, sy] = this.snapped;
		const cf = (1 - this.containerFriction) * this.dragSpeed;
		this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
		this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
		this.computeVelocity(px1 - px3, py1 - py3);
		this.angle = atan2(py1 - py2, px1 - px2);
		const [nsx, nsy] = this.snapped;
		if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) this.onSnap(this);
	}
	stop() {
		this.updateTicker.pause();
		this.overshootTicker.pause();
		for (let prop in this.animate.animations) this.animate.animations[prop].pause();
		removeTargetsFromRenderable([this], null, "x");
		removeTargetsFromRenderable([this], null, "y");
		removeTargetsFromRenderable([this], null, "progressX");
		removeTargetsFromRenderable([this], null, "progressY");
		removeTargetsFromRenderable([this.scroll]);
		removeTargetsFromRenderable([this.overshootCoords]);
		return this;
	}
	/**
	* @param {Number} [duration]
	* @param {Number} [gap]
	* @param {EasingParam} [ease]
	* @return {this}
	*/
	scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
		this.updateScrollCoords();
		const x = this.destX;
		const y = this.destY;
		const scroll = this.scroll;
		const scrollBounds = this.scrollBounds;
		const canScroll = this.canScroll;
		if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
			const [st, sr, sb, sl] = scrollBounds;
			const t = round(clamp(y - st, -maxValue, 0), 0);
			const r = round(clamp(x - sr, 0, maxValue), 0);
			const b = round(clamp(y - sb, 0, maxValue), 0);
			const l = round(clamp(x - sl, -maxValue, 0), 0);
			new JSAnimation(scroll, {
				x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
				y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
				duration: isUnd(duration) ? 350 * globals.timeScale : duration,
				ease,
				onUpdate: () => {
					this.canScroll = false;
					this.$scrollContainer.scrollTo(scroll.x, scroll.y);
				}
			}).init().then(() => {
				this.canScroll = canScroll;
			});
		}
		return this;
	}
	handleHover() {
		if (this.isFinePointer && this.cursor && !this.cursorStyles) this.cursorStyles = set(this.$trigger, { cursor: this.cursor.onHover });
	}
	/**
	* @param  {Number} [duration]
	* @param  {Number} [gap]
	* @param  {EasingParam} [ease]
	* @return {this}
	*/
	animateInView(duration, gap = 0, ease = eases.inOutQuad) {
		this.stop();
		this.updateBoundingValues();
		const x = this.x;
		const y = this.y;
		const [cpt, cpr, cpb, cpl] = this.containerPadding;
		const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
		const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
		const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
		const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
		const ob = this.isOutOfBounds([
			bt,
			br,
			bb,
			bl
		], x, y);
		if (ob) {
			const [disabledX, disabledY] = this.disabled;
			const destX = clamp(snap(x, this.snapX), bl, br);
			const destY = clamp(snap(y, this.snapY), bt, bb);
			const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
			if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);
			if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);
		}
		return this;
	}
	/**
	* @param {MouseEvent|TouchEvent} e
	*/
	handleDown(e) {
		const $eTarget = e.target;
		if (this.grabbed || $eTarget.type === "range") return;
		e.stopPropagation();
		this.grabbed = true;
		this.released = false;
		this.stop();
		this.updateBoundingValues();
		const touches = e.changedTouches;
		const eventX = touches ? touches[0].clientX : e.clientX;
		const eventY = touches ? touches[0].clientY : e.clientY;
		const { x, y } = this.transforms.normalizePoint(eventX, eventY);
		const [ct, cr, cb, cl] = this.containerBounds;
		const cf = (1 - this.containerFriction) * this.dragSpeed;
		const cx = this.x;
		const cy = this.y;
		this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
		this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
		this.pointer[0] = x;
		this.pointer[1] = y;
		this.pointer[2] = x;
		this.pointer[3] = y;
		this.pointer[4] = x;
		this.pointer[5] = y;
		this.pointer[6] = x;
		this.pointer[7] = y;
		this.deltaX = 0;
		this.deltaY = 0;
		this.velocity = 0;
		this.velocityStack[0] = 0;
		this.velocityStack[1] = 0;
		this.velocityStack[2] = 0;
		this.velocityStackIndex = 0;
		this.angle = 0;
		if (this.targetStyles) {
			this.targetStyles.revert();
			this.targetStyles = null;
		}
		const z = get(this.$target, "zIndex", false);
		zIndex = (z > zIndex ? z : zIndex) + 1;
		this.targetStyles = set(this.$target, { zIndex });
		if (this.triggerStyles) {
			this.triggerStyles.revert();
			this.triggerStyles = null;
		}
		if (this.cursorStyles) {
			this.cursorStyles.revert();
			this.cursorStyles = null;
		}
		if (this.isFinePointer && this.cursor) this.bodyStyles = set(doc.body, { cursor: this.cursor.onGrab });
		this.scrollInView(100, 0, eases.out(3));
		this.onGrab(this);
		doc.addEventListener("touchmove", this);
		doc.addEventListener("touchend", this);
		doc.addEventListener("touchcancel", this);
		doc.addEventListener("mousemove", this);
		doc.addEventListener("mouseup", this);
		doc.addEventListener("selectstart", this);
	}
	/**
	* @param {MouseEvent|TouchEvent} e
	*/
	handleMove(e) {
		if (!this.grabbed) return;
		const touches = e.changedTouches;
		const eventX = touches ? touches[0].clientX : e.clientX;
		const eventY = touches ? touches[0].clientY : e.clientY;
		const { x, y } = this.transforms.normalizePoint(eventX, eventY);
		const movedX = x - this.pointer[6];
		const movedY = y - this.pointer[7];
		let $parent = e.target;
		let isAtTop = false;
		let isAtBottom = false;
		let canTouchScroll = false;
		while (touches && $parent && $parent !== this.$trigger) {
			const overflowY = get($parent, "overflow-y");
			if (overflowY !== "hidden" && overflowY !== "visible") {
				const { scrollTop, scrollHeight, clientHeight } = $parent;
				if (scrollHeight > clientHeight) {
					canTouchScroll = true;
					isAtTop = scrollTop <= 3;
					isAtBottom = scrollTop >= scrollHeight - clientHeight - 3;
					break;
				}
			}
			$parent = $parent.parentElement;
		}
		if (canTouchScroll && (!isAtTop && !isAtBottom || isAtTop && movedY < 0 || isAtBottom && movedY > 0)) {
			this.pointer[0] = x;
			this.pointer[1] = y;
			this.pointer[2] = x;
			this.pointer[3] = y;
			this.pointer[4] = x;
			this.pointer[5] = y;
			this.pointer[6] = x;
			this.pointer[7] = y;
		} else {
			preventDefault(e);
			if (!this.triggerStyles) this.triggerStyles = set(this.$trigger, { pointerEvents: "none" });
			this.$trigger.addEventListener("touchstart", preventDefault, { passive: false });
			this.$trigger.addEventListener("touchmove", preventDefault, { passive: false });
			this.$trigger.addEventListener("touchend", preventDefault);
			if (this.dragged || !this.disabled[0] && abs(movedX) > this.dragThreshold || !this.disabled[1] && abs(movedY) > this.dragThreshold) {
				this.updateTicker.resume();
				this.pointer[2] = this.pointer[0];
				this.pointer[3] = this.pointer[1];
				this.pointer[0] = x;
				this.pointer[1] = y;
				this.dragged = true;
				this.released = false;
				this.onDrag(this);
			}
		}
	}
	handleUp() {
		if (!this.grabbed) return;
		this.updateTicker.pause();
		if (this.triggerStyles) {
			this.triggerStyles.revert();
			this.triggerStyles = null;
		}
		if (this.bodyStyles) {
			this.bodyStyles.revert();
			this.bodyStyles = null;
		}
		const [disabledX, disabledY] = this.disabled;
		const [px1, py1, px2, py2, px3, py3] = this.pointer;
		const [ct, cr, cb, cl] = this.containerBounds;
		const [sx, sy] = this.snapped;
		const springX = this.releaseXSpring;
		const springY = this.releaseYSpring;
		const releaseEase = this.releaseEase;
		const hasReleaseSpring = this.hasReleaseSpring;
		const overshootCoords = this.overshootCoords;
		const cx = this.x;
		const cy = this.y;
		const pv = this.computeVelocity(px1 - px3, py1 - py3);
		const pa = this.angle = atan2(py1 - py2, px1 - px2);
		const ds = pv * 150;
		const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
		const nx = cx + cos(pa) * ds;
		const ny = cy + sin(pa) * ds;
		const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
		const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
		const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);
		const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);
		const ob = this.isOutOfBounds(this.containerBounds, nx, ny);
		let durationX = 0;
		let durationY = 0;
		let easeX = releaseEase;
		let easeY = releaseEase;
		let longestReleaseDuration = 0;
		overshootCoords.x = cx;
		overshootCoords.y = cy;
		if (!disabledX) {
			const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
			const distanceX = round(cx - dx, 0);
			springX.velocity = disabledY && hasReleaseSpring ? distanceX ? ds * directionX / abs(distanceX) : 0 : pv;
			const { ease, settlingDuration, restDuration } = springX;
			durationX = cx === dx ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - restDuration * globals.timeScale;
			if (hasReleaseSpring) easeX = ease;
			if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;
		}
		if (!disabledY) {
			const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
			const distanceY = round(cy - dy, 0);
			springY.velocity = disabledX && hasReleaseSpring ? distanceY ? ds * directionY / abs(distanceY) : 0 : pv;
			const { ease, settlingDuration, restDuration } = springY;
			durationY = cy === dy ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - restDuration * globals.timeScale;
			if (hasReleaseSpring) easeY = ease;
			if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;
		}
		if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {
			const composition = compositionTypes.blend;
			new JSAnimation(overshootCoords, {
				x: {
					to: bx,
					duration: durationX * .65
				},
				y: {
					to: by,
					duration: durationY * .65
				},
				ease: releaseEase,
				composition
			}).init();
			new JSAnimation(overshootCoords, {
				x: {
					to: dx,
					duration: durationX
				},
				y: {
					to: dy,
					duration: durationY
				},
				ease: releaseEase,
				composition
			}).init();
			this.overshootTicker.stretch(max(durationX, durationY)).restart();
		} else {
			if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);
			if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);
		}
		this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);
		let hasSnapped = false;
		if (dx !== sx) {
			this.snapped[0] = dx;
			if (this.snapX) hasSnapped = true;
		}
		if (dy !== sy && this.snapY) {
			this.snapped[1] = dy;
			if (this.snapY) hasSnapped = true;
		}
		if (hasSnapped) this.onSnap(this);
		this.grabbed = false;
		this.dragged = false;
		this.updated = true;
		this.released = true;
		this.onRelease(this);
		this.$trigger.removeEventListener("touchstart", preventDefault);
		this.$trigger.removeEventListener("touchmove", preventDefault);
		this.$trigger.removeEventListener("touchend", preventDefault);
		doc.removeEventListener("touchmove", this);
		doc.removeEventListener("touchend", this);
		doc.removeEventListener("touchcancel", this);
		doc.removeEventListener("mousemove", this);
		doc.removeEventListener("mouseup", this);
		doc.removeEventListener("selectstart", this);
	}
	reset() {
		this.stop();
		this.resizeTicker.pause();
		this.grabbed = false;
		this.dragged = false;
		this.updated = false;
		this.released = false;
		this.canScroll = false;
		this.setX(0, true);
		this.setY(0, true);
		this.coords[0] = 0;
		this.coords[1] = 0;
		this.pointer[0] = 0;
		this.pointer[1] = 0;
		this.pointer[2] = 0;
		this.pointer[3] = 0;
		this.pointer[4] = 0;
		this.pointer[5] = 0;
		this.pointer[6] = 0;
		this.pointer[7] = 0;
		this.velocity = 0;
		this.velocityStack[0] = 0;
		this.velocityStack[1] = 0;
		this.velocityStack[2] = 0;
		this.velocityStackIndex = 0;
		this.angle = 0;
		return this;
	}
	enable() {
		if (!this.enabled) {
			this.enabled = true;
			this.$target.classList.remove("is-disabled");
			this.touchActionStyles = set(this.$trigger, { touchAction: this.disabled[0] ? "pan-x" : this.disabled[1] ? "pan-y" : "none" });
			this.$trigger.addEventListener("touchstart", this, { passive: true });
			this.$trigger.addEventListener("mousedown", this, { passive: true });
			this.$trigger.addEventListener("mouseenter", this);
		}
		return this;
	}
	disable() {
		this.enabled = false;
		this.grabbed = false;
		this.dragged = false;
		this.updated = false;
		this.released = false;
		this.canScroll = false;
		this.touchActionStyles.revert();
		if (this.cursorStyles) {
			this.cursorStyles.revert();
			this.cursorStyles = null;
		}
		if (this.triggerStyles) {
			this.triggerStyles.revert();
			this.triggerStyles = null;
		}
		if (this.bodyStyles) {
			this.bodyStyles.revert();
			this.bodyStyles = null;
		}
		if (this.targetStyles) {
			this.targetStyles.revert();
			this.targetStyles = null;
		}
		this.$target.classList.add("is-disabled");
		this.$trigger.removeEventListener("touchstart", this);
		this.$trigger.removeEventListener("mousedown", this);
		this.$trigger.removeEventListener("mouseenter", this);
		doc.removeEventListener("touchmove", this);
		doc.removeEventListener("touchend", this);
		doc.removeEventListener("touchcancel", this);
		doc.removeEventListener("mousemove", this);
		doc.removeEventListener("mouseup", this);
		doc.removeEventListener("selectstart", this);
		return this;
	}
	revert() {
		this.reset();
		this.disable();
		this.$target.classList.remove("is-disabled");
		this.updateTicker.revert();
		this.overshootTicker.revert();
		this.resizeTicker.revert();
		this.animate.revert();
		this.resizeObserver.disconnect();
		return this;
	}
	/**
	* @param {Event} e
	*/
	handleEvent(e) {
		switch (e.type) {
			case "mousedown":
				this.handleDown(e);
				break;
			case "touchstart":
				this.handleDown(e);
				break;
			case "mousemove":
				this.handleMove(e);
				break;
			case "touchmove":
				this.handleMove(e);
				break;
			case "mouseup":
				this.handleUp();
				break;
			case "touchend":
				this.handleUp();
				break;
			case "touchcancel":
				this.handleUp();
				break;
			case "mouseenter":
				this.handleHover();
				break;
			case "selectstart":
				preventDefault(e);
				break;
		}
	}
};
/**
* @param {TargetsParam} target
* @param {DraggableParams} [parameters]
* @return {Draggable}
*/
var createDraggable = (target, parameters) => new Draggable(target, parameters);

//#endregion
export { lerp as $, decomposedOriginalValue as A, clamp as B, Timer as C, shortTransforms as Ct, cleanInlineStyles as D, unitsExecRgx as Dt, engine as E, transformsSymbol as Et, PI as F, isFnc as G, floor as H, abs as I, isNum as J, isKey as K, addChild as L, getOriginalAnimatableValue as M, getRelativeValue as N, tick as O, validTransforms as Ot, setValue as P, isUnd as Q, atan2 as R, registerTargets as S, relativeValuesExecRgx as St, removeTargetsFromRenderable as T, transformsFragmentStrings as Tt, forEachChildren as U, clampInfinity as V, isArr as W, isStr as X, isObj as Y, isSvg as Z, parseEaseString as _, isSvgSymbol as _t, set as a, round as at, getNodeList as b, noop as bt, createSpring as c, toLowerCase as ct, Animatable as d, K as dt, max as et, createAnimatable as f, compositionTypes as ft, parseEase as g, isDomSymbol as gt, eases as h, isBrowser as ht, remove as i, removeChild as it, getFunctionValue as j, decomposeRawValue as k, win as kt, spring as l, globals as lt, animate as m, emptyString as mt, createDraggable as n, normalizeTime as nt, addWAAPIAnimation as o, sqrt as ot, JSAnimation as p, doc as pt, isNil as q, get as r, parseNumber as rt, Spring as s, stringStartsWith as st, Draggable as t, mergeObjects as tt, number_exports as u, scope as ut, none as v, minValue as vt, createTimer as w, tickModes as wt, parseTargets as x, proxyTargetSymbol as xt, convertValueUnit as y, morphPointsSymbol as yt, ceil as z };
//# sourceMappingURL=draggable-D1wNpi7L.js.map