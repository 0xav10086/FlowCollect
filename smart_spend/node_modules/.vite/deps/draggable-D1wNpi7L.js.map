{"version":3,"file":"draggable-D1wNpi7L.js","names":["max","key","key","engine","nodeList","keyframes","key","hasSpring","to","tween","max","keyframes"],"sources":["../../animejs/dist/modules/core/consts.js","../../animejs/dist/modules/core/globals.js","../../animejs/dist/modules/core/helpers.js","../../animejs/dist/modules/core/transforms.js","../../animejs/dist/modules/core/colors.js","../../animejs/dist/modules/core/values.js","../../animejs/dist/modules/core/render.js","../../animejs/dist/modules/core/styles.js","../../animejs/dist/modules/core/clock.js","../../animejs/dist/modules/animation/additive.js","../../animejs/dist/modules/engine/engine.js","../../animejs/dist/modules/animation/composition.js","../../animejs/dist/modules/timer/timer.js","../../animejs/dist/modules/core/targets.js","../../animejs/dist/modules/core/units.js","../../animejs/dist/modules/easings/none.js","../../animejs/dist/modules/easings/eases/parser.js","../../animejs/dist/modules/animation/animation.js","../../animejs/dist/modules/animatable/animatable.js","../../animejs/dist/modules/utils/number.js","../../animejs/dist/modules/easings/spring/index.js","../../animejs/dist/modules/waapi/composition.js","../../animejs/dist/modules/utils/target.js","../../animejs/dist/modules/draggable/draggable.js"],"sourcesContent":["/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\n// Environments\n\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = typeof window !== 'undefined';\n\n/** @type {Window & {AnimeJS: Array}|null} */\nconst win = isBrowser ? /** @type {Window & {AnimeJS: Array}} */(/** @type {unknown} */(window)) : null;\n\n/** @type {Document|null} */\nconst doc = isBrowser ? document : null;\n\n// Enums\n\n/** @enum {Number} */\nconst tweenTypes = {\n  OBJECT: 0,\n  ATTRIBUTE: 1,\n  CSS: 2,\n  TRANSFORM: 3,\n  CSS_VAR: 4,\n};\n\n/** @enum {Number} */\nconst valueTypes = {\n  NUMBER: 0,\n  UNIT: 1,\n  COLOR: 2,\n  COMPLEX: 3,\n};\n\n/** @enum {Number} */\nconst tickModes = {\n  NONE: 0,\n  AUTO: 1,\n  FORCE: 2,\n};\n\n/** @enum {Number} */\nconst compositionTypes = {\n  replace: 0,\n  none: 1,\n  blend: 2,\n};\n\n// Cache symbols\n\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n\n// Numbers\n\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n\n// Strings\n\nconst emptyString = '';\nconst cssVarPrefix = 'var(';\n\nconst shortTransforms = /*#__PURE__*/ (() => {\n  const map = new Map();\n  map.set('x', 'translateX');\n  map.set('y', 'translateY');\n  map.set('z', 'translateZ');\n  return map;\n})();\n\nconst validTransforms = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'scaleZ',\n  'skew',\n  'skewX',\n  'skewY',\n  'matrix',\n  'matrix3d',\n  'perspective',\n];\n\nconst transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});\n\n// Functions\n\n/** @return {void} */\nconst noop = () => {};\n\n// Regex\n\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\nconst cssVariableMatchRgx = /var\\(\\s*(--[\\w-]+)(?:\\s*,\\s*([^)]+))?\\s*\\)/;\n\nexport { K, compositionTypes, cssVarPrefix, cssVariableMatchRgx, digitWithExponentRgx, doc, emptyString, hexTestRgx, hslExecRgx, hslaExecRgx, isBrowser, isDomSymbol, isRegisteredTargetSymbol, isSvgSymbol, lowerCaseRgx, maxFps, maxValue, minValue, morphPointsSymbol, noop, proxyTargetSymbol, relativeValuesExecRgx, rgbExecRgx, rgbaExecRgx, shortTransforms, tickModes, transformsExecRgx, transformsFragmentStrings, transformsSymbol, tweenTypes, unitsExecRgx, validTransforms, valueTypes, win };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isBrowser, win, noop, maxFps, K, compositionTypes, doc } from './consts.js';\n\n/**\n * @import {\n *   DefaultsParams,\n *   DOMTarget,\n * } from '../types/index.js'\n *\n * @import {\n *   Scope,\n * } from '../scope/index.js'\n*/\n\n/** @type {DefaultsParams} */\nconst defaults = {\n  id: null,\n  keyframes: null,\n  playbackEase: null,\n  playbackRate: 1,\n  frameRate: maxFps,\n  loop: 0,\n  reversed: false,\n  alternate: false,\n  autoplay: true,\n  persist: false,\n  duration: K,\n  delay: 0,\n  loopDelay: 0,\n  ease: 'out(2)',\n  composition: compositionTypes.replace,\n  modifier: v => v,\n  onBegin: noop,\n  onBeforeUpdate: noop,\n  onUpdate: noop,\n  onLoop: noop,\n  onPause: noop,\n  onComplete: noop,\n  onRender: noop,\n};\n\nconst scope = {\n  /** @type {Scope} */\n  current: null,\n  /** @type {Document|DOMTarget} */\n  root: doc,\n};\n\nconst globals = {\n  /** @type {DefaultsParams} */\n  defaults,\n  /** @type {Number} */\n  precision: 4,\n  /** @type {Number} equals 1 in ms mode, 0.001 in s mode */\n  timeScale: 1,\n  /** @type {Number} */\n  tickThreshold: 200,\n};\n\nconst globalVersions = { version: '4.2.2', engine: null };\n\nif (isBrowser) {\n  if (!win.AnimeJS) win.AnimeJS = [];\n  win.AnimeJS.push(globalVersions);\n}\n\nexport { defaults, globalVersions, globals, scope };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isBrowser, maxValue, minValue, hexTestRgx, lowerCaseRgx } from './consts.js';\nimport { globals } from './globals.js';\n\n/**\n * @import {\n *   Target,\n *   DOMTarget,\n * } from '../types/index.js'\n*/\n\n// Strings\n\n/**\n * @param  {String} str\n * @return {String}\n */\nconst toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();\n\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */\nconst stringStartsWith = (str, sub) => str.indexOf(sub) === 0;\n\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n\n// Types checkers\n\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */\nconst isObj = a => a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */\nconst isNum = a => typeof a === 'number' && !isNaN(a);\n/**@param {any} a @return {a is String} */\nconst isStr = a => typeof a === 'string';\n/**@param {any} a @return {a is Function} */\nconst isFnc = a => typeof a === 'function';\n/**@param {any} a @return {a is undefined} */\nconst isUnd = a => typeof a === 'undefined';\n/**@param {any} a @return {a is null | undefined} */\nconst isNil = a => isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */\nconst isSvg = a => isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */\nconst isHex = a => hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */\nconst isRgb = a => stringStartsWith(a, 'rgb');\n/**@param {any} a @return {Boolean} */\nconst isHsl = a => stringStartsWith(a, 'hsl');\n/**@param {any} a @return {Boolean} */\nconst isCol = a => isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */\nconst isKey = a => !globals.defaults.hasOwnProperty(a);\n\n// SVG\n\n// Consider the following as CSS animation\n// CSS opacity animation has better default values (opacity: 1 instead of 0))\n// rotate is more commonly intended to be used as a transform\nconst svgCssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];\n\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */\nconst isValidSVGAttribute = (el, propertyName) => {\n  if (svgCssReservedProperties.includes(propertyName)) return false;\n  if (el.getAttribute(propertyName) || propertyName in el) {\n    if (propertyName === 'scale') { // Scale\n      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);\n      // Only consider scale as a valid SVG attribute on filter element\n      return elParentNode && elParentNode.tagName === 'filter';\n    }\n    return true;\n  }\n};\n\n// Number\n\n/**\n * @param  {Number|String} str\n * @return {Number}\n */\nconst parseNumber = str => isStr(str) ?\n  parseFloat(/** @type {String} */(str)) :\n  /** @type {Number} */(str);\n\n// Math\n\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n\n/**\n * Clamps a value between min and max bounds\n *\n * @param  {Number} v - Value to clamp\n * @param  {Number} min - Minimum boundary\n * @param  {Number} max - Maximum boundary\n * @return {Number}\n */\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\n\nconst powCache = {};\n\n/**\n * Rounds a number to specified decimal places\n *\n * @param  {Number} v - Value to round\n * @param  {Number} decimalLength - Number of decimal places\n * @return {Number}\n */\nconst round = (v, decimalLength) => {\n  if (decimalLength < 0) return v;\n  if (!decimalLength) return _round(v);\n  let p = powCache[decimalLength];\n  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n  return _round(v * p) / p;\n};\n\n/**\n * Snaps a value to nearest increment or array value\n *\n * @param  {Number} v - Value to snap\n * @param  {Number|Array<Number>} increment - Step size or array of snap points\n * @return {Number}\n */\nconst snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;\n\n/**\n * Linear interpolation between two values\n *\n * @param  {Number} start - Starting value\n * @param  {Number} end - Ending value\n * @param  {Number} factor - Interpolation factor in the range [0, 1]\n * @return {Number} The interpolated value\n */\nconst lerp = (start, end, factor) => start + (end - start) * factor;\n\n/**\n * Replaces infinity with maximum safe value\n *\n * @param  {Number} v - Value to check\n * @return {Number}\n */\nconst clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;\n\n/**\n * Normalizes time value with minimum threshold\n *\n * @param  {Number} v - Time value to normalize\n * @return {Number}\n */\nconst normalizeTime = v => v <= minValue ? minValue : clampInfinity(round(v, 11));\n\n// Arrays\n\n/**\n * @template T\n * @param    {T[]} a\n * @return   {T[]}\n */\nconst cloneArray = a => isArr(a) ? [ ...a ] : a;\n\n// Objects\n\n/**\n * @template T\n * @template U\n * @param    {T} o1\n * @param    {U} o2\n * @return   {T & U}\n */\nconst mergeObjects = (o1, o2) => {\n  const merged = /** @type {T & U} */({ ...o1 });\n  for (let p in o2) {\n    const o1p = /** @type {T & U} */(o1)[p];\n    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;\n  }  return merged;\n};\n\n// Linked lists\n\n/**\n * @param  {Object} parent\n * @param  {Function} callback\n * @param  {Boolean} [reverse]\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {\n  let next = parent._head;\n  let adjustedNextProp = nextProp;\n  if (reverse) {\n    next = parent._tail;\n    adjustedNextProp = prevProp;\n  }\n  while (next) {\n    const currentNext = next[adjustedNextProp];\n    callback(next);\n    next = currentNext;\n  }\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {\n  const prev = child[prevProp];\n  const next = child[nextProp];\n  prev ? prev[nextProp] = next : parent._head = next;\n  next ? next[prevProp] = prev : parent._tail = prev;\n  child[prevProp] = null;\n  child[nextProp] = null;\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */\nconst addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {\n  let prev = parent._tail;\n  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];\n  const next = prev ? prev[nextProp] : parent._head;\n  prev ? prev[nextProp] = child : parent._head = child;\n  next ? next[prevProp] = child : parent._tail = child;\n  child[prevProp] = prev;\n  child[nextProp] = next;\n};\n\nexport { PI, _round, abs, addChild, asin, atan2, ceil, clamp, clampInfinity, cloneArray, cos, exp, floor, forEachChildren, isArr, isCol, isFnc, isHex, isHsl, isKey, isNil, isNum, isObj, isRgb, isStr, isSvg, isUnd, isValidSVGAttribute, lerp, max, mergeObjects, normalizeTime, now, parseNumber, pow, removeChild, round, sin, snap, sqrt, stringStartsWith, toLowerCase };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { transformsSymbol, transformsExecRgx } from './consts.js';\nimport { isUnd, stringStartsWith } from './helpers.js';\n\n/**\n* @import {\n*   DOMTarget,\n* } from '../types/index.js'\n*/\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst parseInlineTransforms = (target, propName, animationInlineStyles) => {\n  const inlineTransforms = target.style.transform;\n  let inlinedStylesPropertyValue;\n  if (inlineTransforms) {\n    const cachedTransforms = target[transformsSymbol];\n    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {\n      const inlinePropertyName = t[1];\n      // const inlinePropertyValue = t[2];\n      const inlinePropertyValue = t[2].slice(1, -1);\n      cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n      if (inlinePropertyName === propName) {\n        inlinedStylesPropertyValue = inlinePropertyValue;\n        // Store the new parsed inline styles if animationInlineStyles is provided\n        if (animationInlineStyles) {\n          animationInlineStyles[propName] = inlinePropertyValue;\n        }\n      }\n    }\n  }\n  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :\n    stringStartsWith(propName, 'scale') ? '1' :\n    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';\n};\n\nexport { parseInlineTransforms };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { rgbExecRgx, rgbaExecRgx, hslExecRgx, hslaExecRgx } from './consts.js';\nimport { isRgb, isHex, isHsl, isUnd, round } from './helpers.js';\n\n/**\n * @import {\n *   ColorArray,\n * } from '../types/index.js'\n*/\n\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */\nconst rgbToRgba = rgbValue => {\n  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n  return [\n    +rgba[1],\n    +rgba[2],\n    +rgba[3],\n    a\n  ]\n};\n\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */\nconst hexToRgba = hexValue => {\n  const hexLength = hexValue.length;\n  const isShort = hexLength === 4 || hexLength === 5;\n  return [\n    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),\n    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)\n  ]\n};\n\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */\nconst hue2rgb = (p, q, t) => {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  return t < 1 / 6 ? p + (q - p) * 6 * t :\n         t < 1 / 2 ? q :\n         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\n         p;\n};\n\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */\nconst hslToRgba = hslValue => {\n  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n  const h = +hsla[1] / 360;\n  const s = +hsla[2] / 100;\n  const l = +hsla[3] / 100;\n  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const q = l < .5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n    g = round(hue2rgb(p, q, h) * 255, 0);\n    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n  }\n  return [r, g, b, a];\n};\n\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */\nconst convertColorStringValuesToRgbaArray = colorString => {\n  return isRgb(colorString) ? rgbToRgba(colorString) :\n         isHex(colorString) ? hexToRgba(colorString) :\n         isHsl(colorString) ? hslToRgba(colorString) :\n         [0, 0, 0, 1];\n};\n\nexport { convertColorStringValuesToRgbaArray };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { tweenTypes, isDomSymbol, isSvgSymbol, validTransforms, shortTransforms, valueTypes, unitsExecRgx, digitWithExponentRgx, proxyTargetSymbol, cssVarPrefix, cssVariableMatchRgx, emptyString } from './consts.js';\nimport { isUnd, isValidSVGAttribute, stringStartsWith, isCol, isFnc, isStr, cloneArray } from './helpers.js';\nimport { parseInlineTransforms } from './transforms.js';\nimport { convertColorStringValuesToRgbaArray } from './colors.js';\n\n/**\n* @import {\n*   Target,\n*   DOMTarget,\n*   Tween,\n*   TweenPropValue,\n*   TweenDecomposedValue,\n* } from '../types/index.js'\n*/\n\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */\nconst setValue = (targetValue, defaultValue) => {\n  return isUnd(targetValue) ? defaultValue : targetValue;\n};\n\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */\nconst getFunctionValue = (value, target, index, total, store) => {\n  let func;\n  if (isFnc(value)) {\n    func = () => {\n      const computed = /** @type {Function} */(value)(target, index, total);\n      // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n      return !isNaN(+computed) ? +computed : computed || 0;\n    };\n  } else if (isStr(value) && stringStartsWith(value, cssVarPrefix)) {\n    func = () => {\n      const match = value.match(cssVariableMatchRgx);\n      const cssVarName = match[1];\n      const fallbackValue = match[2];\n      let computed = getComputedStyle(/** @type {HTMLElement} */(target))?.getPropertyValue(cssVarName);\n      // Use fallback if CSS variable is not set or empty\n      if ((!computed || computed.trim() === emptyString) && fallbackValue) {\n        computed = fallbackValue.trim();\n      }\n      return computed || 0;\n    };\n  } else {\n    return value;\n  }\n  if (store) store.func = func;\n  return func();\n};\n\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */\nconst getTweenType = (target, prop) => {\n  return !target[isDomSymbol] ? tweenTypes.OBJECT :\n    // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :\n    // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :\n    // CSS variables\n    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :\n    // All other CSS properties\n    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :\n    // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT :\n    tweenTypes.ATTRIBUTE;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst getCSSValue = (target, propName, animationInlineStyles) => {\n  const inlineStyles = target.style[propName];\n  if (inlineStyles && animationInlineStyles) {\n    animationInlineStyles[propName] = inlineStyles;\n  }\n  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n  return value === 'auto' ? '0' : value;\n};\n\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */\nconst getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {\n  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n  return type === tweenTypes.OBJECT ? target[propName] || 0 :\n         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :\n         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :\n         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :\n         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);\n};\n\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */\nconst getRelativeValue = (x, y, operator) => {\n  return operator === '-' ? x - y :\n         operator === '+' ? x + y :\n         x * y;\n};\n\n/** @return {TweenDecomposedValue} */\nconst createDecomposedValueTargetObject = () => {\n  return {\n    /** @type {valueTypes} */\n    t: valueTypes.NUMBER,\n    n: 0,\n    u: null,\n    o: null,\n    d: null,\n    s: null,\n  }\n};\n\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeRawValue = (rawValue, targetObject) => {\n  /** @type {valueTypes} */\n  targetObject.t = valueTypes.NUMBER;\n  targetObject.n = 0;\n  targetObject.u = null;\n  targetObject.o = null;\n  targetObject.d = null;\n  targetObject.s = null;\n  if (!rawValue) return targetObject;\n  const num = +rawValue;\n  if (!isNaN(num)) {\n    // It's a number\n    targetObject.n = num;\n    return targetObject;\n  } else {\n    // let str = /** @type {String} */(rawValue).trim();\n    let str = /** @type {String} */(rawValue);\n    // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n    if (str[1] === '=') {\n      targetObject.o = str[0];\n      str = str.slice(2);\n    }\n    // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);\n    if (unitMatch) {\n      // Has a number and a unit\n      targetObject.t = valueTypes.UNIT;\n      targetObject.n = +unitMatch[1];\n      targetObject.u = unitMatch[2];\n      return targetObject;\n    } else if (targetObject.o) {\n      // Has an operator (+=, -=, *=)\n      targetObject.n = +str;\n      return targetObject;\n    } else if (isCol(str)) {\n      // Is a color\n      targetObject.t = valueTypes.COLOR;\n      targetObject.d = convertColorStringValuesToRgbaArray(str);\n      return targetObject;\n    } else {\n      // Is a more complex string (generally svg coords, calc() or filters CSS values)\n      const matchedNumbers = str.match(digitWithExponentRgx);\n      targetObject.t = valueTypes.COMPLEX;\n      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n      targetObject.s = str.split(digitWithExponentRgx) || [];\n      return targetObject;\n    }\n  }\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeTweenValue = (tween, targetObject) => {\n  targetObject.t = tween._valueType;\n  targetObject.n = tween._toNumber;\n  targetObject.u = tween._unit;\n  targetObject.o = null;\n  targetObject.d = cloneArray(tween._toNumbers);\n  targetObject.s = cloneArray(tween._strings);\n  return targetObject;\n};\n\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\n\nexport { createDecomposedValueTargetObject, decomposeRawValue, decomposeTweenValue, decomposedOriginalValue, getFunctionValue, getOriginalAnimatableValue, getRelativeValue, getTweenType, setValue };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from './globals.js';\nimport { minValue, tickModes, valueTypes, compositionTypes, tweenTypes, transformsSymbol, transformsFragmentStrings, emptyString } from './consts.js';\nimport { forEachChildren, round, now, clamp, lerp } from './helpers.js';\n\n/**\n *   @import {\n *   Tickable,\n *   Renderable,\n *   CallbackArgument,\n *   Tween,\n *   DOMTarget,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */(tickable)._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */(tickable));\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */(tickable));\n  }\n\n  if (\n    forcedTick ||\n    tickMode === tickModes.AUTO && (\n      time >= tickableDelay && time <= tickableEndTime || // Normal render\n      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) ||\n    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||\n    iterationTime <= tickableDelay && tickablePrevTime > 0 ||\n    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n\n      while (tween) {\n\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n\n        if ((forcedRender || (\n            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&\n            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)\n          )) && (!tweenHasComposition || (\n            !tween._isOverridden &&\n            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&\n            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&\n            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))\n          ))\n        ) {\n\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[0], tn[0], tweenProgress))), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[1], tn[1], tweenProgress))), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */(tweenModifier(lerp(fn[2], tn[2], tweenProgress))), 0, 255), 0);\n            const a = clamp(/** @type {Number} */(tweenModifier(round(lerp(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */(tweenModifier(round(lerp(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));\n            } else {\n              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));\n              }\n            }\n\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n\n        tween = tween._next;\n      }\n\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));\n      }\n    }\n\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n      // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues\n      // see: https://github.com/juliangarnier/anime/issues/1088\n      (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed) ||\n      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)\n    )) {\n      tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n      tickable.completed = !isRunningBackwards;\n    }\n  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n          tickable._resolve(/** @type {CallbackArgument} */(tickable));\n        }\n      }\n    }\n  // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */(tickable);\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));\n    }\n\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */(tl));\n          tl._resolve(/** @type {CallbackArgument} */(tl));\n        }\n      }\n    }\n  }\n};\n\nexport { render, tick };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { tweenTypes, shortTransforms, isDomSymbol, transformsSymbol, transformsFragmentStrings, emptyString } from './consts.js';\nimport { forEachChildren, isSvg, toLowerCase, isNil } from './helpers.js';\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n* @import {\n*   Target,\n*   DOMTarget,\n*   Renderable,\n*   Tween,\n* } from '../types/index.js'\n*/\n\nconst propertyNamesCache = {};\n\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */\nconst sanitizePropertyName = (propertyName, target, tweenType) => {\n  if (tweenType === tweenTypes.TRANSFORM) {\n    const t = shortTransforms.get(propertyName);\n    return t ? t : propertyName;\n  } else if (\n    tweenType === tweenTypes.CSS ||\n    // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))\n  ) {\n    const cachedPropertyName = propertyNamesCache[propertyName];\n    if (cachedPropertyName) {\n      return cachedPropertyName;\n    } else {\n      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n      propertyNamesCache[propertyName] = lowerCaseName;\n      return lowerCaseName;\n    }\n  } else {\n    return propertyName;\n  }\n};\n\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */\nconst cleanInlineStyles = renderable => {\n  // Allow cleanInlineStyles() to be called on timelines\n  if (renderable._hasChildren) {\n    forEachChildren(renderable, cleanInlineStyles, true);\n  } else {\n    const animation = /** @type {JSAnimation} */(renderable);\n    animation.pause();\n    forEachChildren(animation, (/** @type {Tween} */tween) => {\n      const tweenProperty = tween.property;\n      const tweenTarget = tween.target;\n      if (tweenTarget[isDomSymbol]) {\n        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;\n        const originalInlinedValue = tween._inlineValue;\n        const tweenHadNoInlineValue = isNil(originalInlinedValue) || originalInlinedValue === emptyString;\n        if (tween._tweenType === tweenTypes.TRANSFORM) {\n          const cachedTransforms = tweenTarget[transformsSymbol];\n          if (tweenHadNoInlineValue) {\n            delete cachedTransforms[tweenProperty];\n          } else {\n            cachedTransforms[tweenProperty] = originalInlinedValue;\n          }\n          if (tween._renderTransforms) {\n            if (!Object.keys(cachedTransforms).length) {\n              targetStyle.removeProperty('transform');\n            } else {\n              let str = emptyString;\n              for (let key in cachedTransforms) {\n                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';\n              }\n              targetStyle.transform = str;\n            }\n          }\n        } else {\n          if (tweenHadNoInlineValue) {\n            targetStyle.removeProperty(toLowerCase(tweenProperty));\n          } else {\n            targetStyle[tweenProperty] = originalInlinedValue;\n          }\n        }\n        if (animation._tail === tween) {\n          animation.targets.forEach(t => {\n            if (t.getAttribute && t.getAttribute('style') === emptyString) {\n              t.removeAttribute('style');\n            }          });\n        }\n      }\n    });\n  }\n  return renderable;\n};\n\nexport { cleanInlineStyles, sanitizePropertyName };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { K, maxFps, minValue, tickModes } from './consts.js';\nimport { round } from './helpers.js';\n\n/**\n * @import {\n *   Tickable,\n *   Tween,\n * } from '../types/index.js'\n*/\n\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */\nclass Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime = 0) {\n    /** @type {Number} */\n    this.deltaTime = 0;\n    /** @type {Number} */\n    this._currentTime = initTime;\n    /** @type {Number} */\n    this._elapsedTime = initTime;\n    /** @type {Number} */\n    this._startTime = initTime;\n    /** @type {Number} */\n    this._lastTime = initTime;\n    /** @type {Number} */\n    this._scheduledTime = 0;\n    /** @type {Number} */\n    this._frameDuration = round(K / maxFps, 0);\n    /** @type {Number} */\n    this._fps = maxFps;\n    /** @type {Number} */\n    this._speed = 1;\n    /** @type {Boolean} */\n    this._hasChildren = false;\n    /** @type {Tickable|Tween} */\n    this._head = null;\n    /** @type {Tickable|Tween} */\n    this._tail = null;\n  }\n\n  get fps() {\n    return this._fps;\n  }\n\n  set fps(frameRate) {\n    const previousFrameDuration = this._frameDuration;\n    const fr = +frameRate;\n    const fps = fr < minValue ? minValue : fr;\n    const frameDuration = round(K / fps, 0);\n    this._fps = fps;\n    this._frameDuration = frameDuration;\n    this._scheduledTime += frameDuration - previousFrameDuration;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  set speed(playbackRate) {\n    const pbr = +playbackRate;\n    this._speed = pbr < minValue ? minValue : pbr;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */\n  requestTick(time) {\n    const scheduledTime = this._scheduledTime;\n    const elapsedTime = this._elapsedTime;\n    this._elapsedTime += (time - elapsedTime);\n    // If the elapsed time is lower than the scheduled time\n    // this means not enough time has passed to hit one frameDuration\n    // so skip that frame\n    if (elapsedTime < scheduledTime) return tickModes.NONE;\n    const frameDuration = this._frameDuration;\n    const frameDelta = elapsedTime - scheduledTime;\n    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n    // Skips ahead if the actual elapsed time is higher.\n    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n    return tickModes.AUTO;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {Number}\n   */\n  computeDeltaTime(time) {\n    const delta = time - this._lastTime;\n    this.deltaTime = delta;\n    this._lastTime = time;\n    return delta;\n  }\n\n}\n\nexport { Clock };\n","/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop, minValue, valueTypes, tickModes } from '../core/consts.js';\nimport { cloneArray } from '../core/helpers.js';\nimport { render } from '../core/render.js';\n\nconst additive = {\n  animation: null,\n  update: noop,\n};\n\n/**\n * @import {\n *   Tween,\n *   TweenAdditiveLookups,\n * } from '../types/index.js'\n */\n\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */\n\n/**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */\nconst addAdditiveAnimation = lookups => {\n  let animation = additive.animation;\n  if (!animation) {\n    animation = {\n      duration: minValue,\n      computeDeltaTime: noop,\n      _offset: 0,\n      _delay: 0,\n      _head: null,\n      _tail: null,\n    };\n    additive.animation = animation;\n    additive.update = () => {\n      lookups.forEach(propertyAnimation => {\n        for (let propertyName in propertyAnimation) {\n          const tweens = propertyAnimation[propertyName];\n          const lookupTween = tweens._head;\n          if (lookupTween) {\n            const valueType = lookupTween._valueType;\n            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n            let additiveValue = lookupTween._fromNumber;\n            let tween = tweens._tail;\n            while (tween && tween !== lookupTween) {\n              if (additiveValues) {\n                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];\n              } else {\n                additiveValue += tween._number;\n              }\n              tween = tween._prevAdd;\n            }\n            lookupTween._toNumber = additiveValue;\n            lookupTween._toNumbers = additiveValues;\n          }\n        }\n      });\n      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n      render(animation, 1, 1, 0, tickModes.FORCE);\n    };\n  }\n  return animation;\n};\n\nexport { addAdditiveAnimation, additive };\n","/**\n * Anime.js - engine - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globalVersions, defaults, globals } from '../core/globals.js';\nimport { isBrowser, doc, tickModes, K } from '../core/consts.js';\nimport { now, removeChild, forEachChildren } from '../core/helpers.js';\nimport { Clock } from '../core/clock.js';\nimport { tick } from '../core/render.js';\nimport { additive } from '../animation/additive.js';\n\n/**\n * @import {\n *   DefaultsParams,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Tickable,\n * } from '../types/index.js'\n*/\n\nconst engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();\nconst engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();\n\nclass Engine extends Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime) {\n    super(initTime);\n    this.useDefaultMainLoop = true;\n    this.pauseOnDocumentHidden = true;\n    /** @type {DefaultsParams} */\n    this.defaults = defaults;\n    // this.paused = isBrowser && doc.hidden ? true  : false;\n    this.paused = true;\n    /** @type {Number|NodeJS.Immediate} */\n    this.reqId = 0;\n  }\n\n  update() {\n    const time = this._currentTime = now();\n    if (this.requestTick(time)) {\n      this.computeDeltaTime(time);\n      const engineSpeed = this._speed;\n      const engineFps = this._fps;\n      let activeTickable = /** @type {Tickable} */(this._head);\n      while (activeTickable) {\n        const nextTickable = activeTickable._next;\n        if (!activeTickable.paused) {\n          tick(\n            activeTickable,\n            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,\n            0, // !muteCallbacks\n            0, // !internalRender\n            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO\n          );\n        } else {\n          removeChild(this, activeTickable);\n          this._hasChildren = !!this._tail;\n          activeTickable._running = false;\n          if (activeTickable.completed && !activeTickable._cancelled) {\n            activeTickable.cancel();\n          }\n        }\n        activeTickable = nextTickable;\n      }\n      additive.update();\n    }\n  }\n\n  wake() {\n    if (this.useDefaultMainLoop && !this.reqId) {\n      // Imediatly request a tick to update engine._elapsedTime and get accurate offsetPosition calculation in timer.js\n      this.requestTick(now());\n      this.reqId = engineTickMethod(tickEngine);\n    }\n    return this;\n  }\n\n  pause() {\n    if (!this.reqId) return;\n    this.paused = true;\n    return killEngine();\n  }\n\n  resume() {\n    if (!this.paused) return;\n    this.paused = false;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());\n    return this.wake();\n  }\n\n  // Getter and setter for speed\n  get speed() {\n    return this._speed * (globals.timeScale === 1 ? 1 : K);\n  }\n\n  set speed(playbackRate) {\n    this._speed = playbackRate * globals.timeScale;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);\n  }\n\n  // Getter and setter for timeUnit\n  get timeUnit() {\n    return globals.timeScale === 1 ? 'ms' : 's';\n  }\n\n  set timeUnit(unit) {\n    const secondsScale = 0.001;\n    const isSecond = unit === 's';\n    const newScale = isSecond ? secondsScale : 1;\n    if (globals.timeScale !== newScale) {\n      globals.timeScale = newScale;\n      globals.tickThreshold = 200 * newScale;\n      const scaleFactor = isSecond ? secondsScale : K;\n      /** @type {Number} */\n      (this.defaults.duration) *= scaleFactor;\n      this._speed *= scaleFactor;\n    }\n  }\n\n  // Getter and setter for precision\n  get precision() {\n    return globals.precision;\n  }\n\n  set precision(precision) {\n    globals.precision = precision;\n  }\n\n}\n\nconst engine = /*#__PURE__*/(() => {\n  const engine = new Engine(now());\n  if (isBrowser) {\n    globalVersions.engine = engine;\n    doc.addEventListener('visibilitychange', () => {\n      if (!engine.pauseOnDocumentHidden) return;\n      doc.hidden ? engine.pause() : engine.resume();\n    });\n  }\n  return engine;\n})();\n\n\nconst tickEngine = () => {\n  if (engine._head) {\n    engine.reqId = engineTickMethod(tickEngine);\n    engine.update();\n  } else {\n    engine.reqId = 0;\n  }\n};\n\nconst killEngine = () => {\n  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));\n  engine.reqId = 0;\n  return engine;\n};\n\nexport { engine };\n","/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, compositionTypes, tweenTypes } from '../core/consts.js';\nimport { forEachChildren, removeChild, isUnd, addChild, round, cloneArray } from '../core/helpers.js';\nimport { sanitizePropertyName } from '../core/styles.js';\nimport { engine } from '../engine/engine.js';\nimport { addAdditiveAnimation, additive } from './additive.js';\n\n/**\n * @import {\n *   TweenReplaceLookups,\n *   TweenAdditiveLookups,\n *   TweenPropertySiblings,\n *   Tween,\n *   Target,\n *   TargetsArray,\n *   Renderable,\n * } from '../types/index.js'\n *\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map(),\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null,\n  }\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n\n    const tweenAbsStartTime = tween._absoluteStartTime;\n\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n        // Check if the previous tween is from a different animation\n        tween.parent.id !== prevParent.id &&\n        // Check if the animation has loops\n        prevParent.iterationCount> 1 &&\n        // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime\n      ) {\n\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n\n      }\n\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        // Rounding is necessary here to minimize floating point errors when working in seconds\n        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);\n\n        prevSibling._changeDuration = updatedPrevChangeDuration;\n        prevSibling._currentTime = updatedPrevChangeDuration;\n        prevSibling._isOverlapped = 1;\n\n        // Override the previous tween if its new _changeDuration is lower than minValue\n        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough\n        if (updatedPrevChangeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separately\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n  // Handle additive tweens composition\n\n  } else if (tweenCompositionType === compositionTypes.blend) {\n\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n\n    let lookupTween = additiveTweenSiblings._head;\n\n    if (!lookupTween) {\n      lookupTween = { ...tween };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n\n  }\n\n  return tween;\n\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation} animation\n * @param  {String} [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween &&\n            tween._tweenType === tweenTypes.TRANSFORM &&\n            tween._prev &&\n            tween._prev._tweenType === tweenTypes.TRANSFORM\n        ) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {Renderable} [renderable]\n * @param  {String} [propertyName]\n */\nconst removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {\n  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        removeTargetsFromRenderable(targetsArray, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {\n      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromJSAnimation(\n      targetsArray,\n      /** @type {JSAnimation} */(parent),\n      propertyName\n    );\n  }\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();\n  }\n};\n\nexport { composeTween, getTweenSiblings, overrideTween, removeTargetsFromRenderable, removeTweenSliblings };\n","/**\n * Anime.js - timer - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { minValue, noop, maxValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { isFnc, isUnd, now, clampInfinity, clamp, round, forEachChildren, addChild, normalizeTime, floor } from '../core/helpers.js';\nimport { globals, scope } from '../core/globals.js';\nimport { setValue } from '../core/values.js';\nimport { tick } from '../core/render.js';\nimport { removeTweenSliblings, composeTween, getTweenSiblings } from '../animation/composition.js';\nimport { Clock } from '../core/clock.js';\nimport { engine } from '../engine/engine.js';\n\n/**\n * @import {\n *   Callback,\n *   TimerParams,\n *   Renderable,\n *   Tween,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   ScrollObserver,\n * } from '../events/scroll.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween */tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\n\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n\n    super(0);\n\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate,\n    } = parameters;\n\n    if (scope.current) scope.current.register(this);\n\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true ||\n                                timerLoop === Infinity ||\n                                /** @type {Number} */(timerLoop) < 0 ? Infinity :\n                                /** @type {Number} */(timerLoop) + 1;\n\n    let offsetPosition = 0;\n\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime\n      // to avoid big gaps with the following offsetPosition calculation\n      if (!engine.reqId) engine.requestTick(now());\n      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit\n      offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(true).play();\n  }\n\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  set iterationCurrentTime(time) {\n    this.currentTime = (this.iterationDuration * this._currentIteration) + time;\n  }\n\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);\n  }\n\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  set currentIteration(iterationCount) {\n    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));\n  }\n\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n\n  get speed() {\n    return super.speed;\n  }\n\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Boolean} [softReset]\n   * @return {this}\n   */\n  reset(softReset = false) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, ~~softReset, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Boolean} internalRender\n   * @return {this}\n   */\n  init(internalRender = false) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, ~~internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {\n      /** @type {ScrollObserver} */(autoplay).link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    // TODO: See if we can safely use engine._elapsedTime here\n    // if (!engine.reqId) engine.requestTick(now())\n    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset().resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek((duration * iterations) - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */(this._autoplay);\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimer\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimer>} [callback]\n   * @return Promise<this>\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(/** @type {ResolvedTimer} */(this));\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\nexport { Timer, createTimer };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { scope } from './globals.js';\nimport { isRegisteredTargetSymbol, isDomSymbol, isSvgSymbol, transformsSymbol, isBrowser } from './consts.js';\nimport { isSvg, isNil, isArr, isStr } from './helpers.js';\n\n/**\n* @import {\n*   DOMTarget,\n*   DOMTargetsParam,\n*   JSTargetsArray,\n*   TargetsParam,\n*   JSTargetsParam,\n*   TargetsArray,\n*   DOMTargetsArray,\n* } from '../types/index.js'\n*/\n\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */\nfunction getNodeList(v) {\n  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;\n  if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction parseTargets(targets) {\n  if (isNil(targets)) return /** @type {TargetsArray} */([]);\n  if (!isBrowser) return /** @type {JSTargetsArray} */(isArr(targets) && targets.flat(Infinity) || [targets]);\n  if (isArr(targets)) {\n    const flattened = targets.flat(Infinity);\n    /** @type {TargetsArray} */\n    const parsed = [];\n    for (let i = 0, l = flattened.length; i < l; i++) {\n      const item = flattened[i];\n      if (!isNil(item)) {\n        const nodeList = getNodeList(item);\n        if (nodeList) {\n          for (let j = 0, jl = nodeList.length; j < jl; j++) {\n            const subItem = nodeList[j];\n            if (!isNil(subItem)) {\n              let isDuplicate = false;\n              for (let k = 0, kl = parsed.length; k < kl; k++) {\n                if (parsed[k] === subItem) {\n                  isDuplicate = true;\n                  break;\n                }\n              }\n              if (!isDuplicate) {\n                parsed.push(subItem);\n              }\n            }\n          }\n        } else {\n          let isDuplicate = false;\n          for (let j = 0, jl = parsed.length; j < jl; j++) {\n            if (parsed[j] === item) {\n              isDuplicate = true;\n              break;\n            }\n          }\n          if (!isDuplicate) {\n            parsed.push(item);\n          }\n        }\n      }\n    }\n    return parsed;\n  }\n  const nodeList = getNodeList(targets);\n  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));\n  return /** @type {TargetsArray} */([targets]);\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction registerTargets(targets) {\n  const parsedTargetsArray = parseTargets(targets);\n  const parsedTargetsLength = parsedTargetsArray.length;\n  if (parsedTargetsLength) {\n    for (let i = 0; i < parsedTargetsLength; i++) {\n      const target = parsedTargetsArray[i];\n      if (!target[isRegisteredTargetSymbol]) {\n        target[isRegisteredTargetSymbol] = true;\n        const isSvgType = isSvg(target);\n        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;\n        if (isDom) {\n          target[isDomSymbol] = true;\n          target[isSvgSymbol] = isSvgType;\n          target[transformsSymbol] = {};\n        }\n      }\n    }\n  }\n  return parsedTargetsArray;\n}\n\nexport { getNodeList, parseTargets, registerTargets };\n","/**\n * Anime.js - core - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { valueTypes, doc } from './consts.js';\nimport { isUnd, PI } from './helpers.js';\n\nconst angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };\nconst convertedValuesCache = {};\n\n/**\n* @import {\n*   DOMTarget,\n*   TweenDecomposedValue,\n* } from '../types/index.js'\n*/\n\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */\nconst convertValueUnit = (el, decomposedValue, unit, force = false) => {\n  const currentUnit = decomposedValue.u;\n  const currentNumber = decomposedValue.n;\n  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary\n    return decomposedValue;\n  }\n  const cachedKey = currentNumber + currentUnit + unit;\n  const cached = convertedValuesCache[cachedKey];\n  if (!isUnd(cached) && !force) {\n    decomposedValue.n = cached;\n  } else {\n    let convertedValue;\n    if (currentUnit in angleUnitsMap) {\n      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n    } else {\n      const baseline = 100;\n      const tempEl = /** @type {DOMTarget} */(el.cloneNode());\n      const parentNode = el.parentNode;\n      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;\n      parentEl.appendChild(tempEl);\n      const elStyle = tempEl.style;\n      elStyle.width = baseline + currentUnit;\n      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      elStyle.width = baseline + unit;\n      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      const factor = currentUnitWidth / newUnitWidth;\n      parentEl.removeChild(tempEl);\n      convertedValue = factor * currentNumber;\n    }\n    decomposedValue.n = convertedValue;\n    convertedValuesCache[cachedKey] = convertedValue;\n  }\n  decomposedValue.t === valueTypes.UNIT;\n  decomposedValue.u = unit;\n  return decomposedValue;\n};\n\nexport { convertValueUnit };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\n/**\n * @import {\n *   EasingFunction,\n * } from '../types/index.js'\n*/\n\n/** @type {EasingFunction} */\nconst none = t => t;\n\nexport { none };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { emptyString, minValue } from '../../core/consts.js';\nimport { pow, sin, sqrt, cos, isStr, stringStartsWith, isFnc, clamp, asin, PI } from '../../core/helpers.js';\nimport { none } from '../none.js';\n\n/**\n * @import {\n *   EasingFunction,\n *   EasingFunctionWithParams,\n *   EasingParam,\n *   BackEasing,\n *   ElasticEasing,\n *   PowerEasing,\n * } from '../../types/index.js'\n*/\n\n\n/** @type {PowerEasing} */\nconst easeInPower = (p = 1.68) => t => pow(t, +p);\n\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */\n\n/** @type {Record<String, EaseType>} */\nconst easeTypes = {\n  in: easeIn => t => easeIn(t),\n  out: easeIn => t => 1 - easeIn(1 - t),\n  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,\n};\n\n/**\n * Easing functions adapted and simplified from https://robertpenner.com/easing/\n * (c) 2001 Robert Penner\n */\n\nconst halfPI = PI / 2;\nconst doublePI = PI * 2;\n\n/** @type {Record<String, EasingFunctionWithParams|EasingFunction>} */\nconst easeInFunctions = {\n  [emptyString]: easeInPower,\n  Quad: easeInPower(2),\n  Cubic: easeInPower(3),\n  Quart: easeInPower(4),\n  Quint: easeInPower(5),\n  /** @type {EasingFunction} */\n  Sine: t => 1 - cos(t * halfPI),\n  /** @type {EasingFunction} */\n  Circ: t => 1 - sqrt(1 - t * t),\n  /** @type {EasingFunction} */\n  Expo: t => t ? pow(2, 10 * t - 10) : 0,\n  /** @type {EasingFunction} */\n  Bounce: t => {\n    let pow2, b = 4;\n    while (t < ((pow2 = pow(2, --b)) - 1) / 11);\n    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n  },\n  /** @type {BackEasing} */\n  Back: (overshoot = 1.7) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,\n  /** @type {ElasticEasing} */\n  Elastic: (amplitude = 1, period = .3) => {\n    const a = clamp(+amplitude, 1, 10);\n    const p = clamp(+period, minValue, 2);\n    const s = (p / doublePI) * asin(1 / a);\n    const e = doublePI / p;\n    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);\n  }\n};\n\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof none} linear\n * @property {typeof none} none\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */\n\nconst eases = (/*#__PURE__ */ (() => {\n  const list = { linear: none, none: none };\n  for (let type in easeTypes) {\n    for (let name in easeInFunctions) {\n      const easeIn = easeInFunctions[name];\n      const easeType = easeTypes[type];\n      list[type + name] = /** @type {EasingFunctionWithParams|EasingFunction} */(\n        name === emptyString || name === 'Back' || name === 'Elastic' ?\n        (a, b) => easeType(/** @type {EasingFunctionWithParams} */(easeIn)(a, b)) :\n        easeType(/** @type {EasingFunction} */(easeIn))\n      );\n    }\n  }\n  return /** @type {EasesFunctions} */(list);\n})());\n\n/** @type {Record<String, EasingFunction>} */\nconst easesLookups = { linear: none, none: none };\n\n/**\n * @param  {String} string\n * @return {EasingFunction}\n */\nconst parseEaseString = (string) => {\n  if (easesLookups[string]) return easesLookups[string];\n  if (string.indexOf('(') <= -1) {\n    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');\n    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasingFunctionWithParams} */(eases[string])() : eases[string]);\n    return parsedFn ? easesLookups[string] = parsedFn : none;\n  } else {\n    const split = string.slice(0, -1).split('(');\n    const parsedFn = /** @type {EasingFunctionWithParams} */(eases[split[0]]);\n    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;\n  }\n};\n\nconst deprecated = ['steps(', 'irregular(', 'linear(', 'cubicBezier('];\n\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */\nconst parseEase = ease => {\n  if (isStr(ease)) {\n    for (let i = 0, l = deprecated.length; i < l; i++) {\n      if (stringStartsWith(ease, deprecated[i])) {\n        console.warn(`String syntax for \\`ease: \"${ease}\"\\` has been removed from the core and replaced by importing and passing the easing function directly: \\`ease: ${ease}\\``);\n        return none;\n      }\n    }\n  }\n  const easeFunc = isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */(ease)) : none;\n  return easeFunc;\n};\n\nexport { easeInPower, easeTypes, eases, parseEase, parseEaseString };\n","/**\n * Anime.js - animation - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { K, compositionTypes, valueTypes, minValue, tweenTypes } from '../core/consts.js';\nimport { mergeObjects, isUnd, isKey, isObj, round, cloneArray, isNil, addChild, forEachChildren, clampInfinity, normalizeTime, isArr, isNum } from '../core/helpers.js';\nimport { globals } from '../core/globals.js';\nimport { registerTargets } from '../core/targets.js';\nimport { setValue, getTweenType, getFunctionValue, decomposeRawValue, createDecomposedValueTargetObject, getOriginalAnimatableValue, decomposedOriginalValue, getRelativeValue, decomposeTweenValue } from '../core/values.js';\nimport { sanitizePropertyName, cleanInlineStyles } from '../core/styles.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { Timer } from '../timer/timer.js';\nimport { getTweenSiblings, overrideTween, composeTween } from './composition.js';\nimport { additive } from './additive.js';\n\n/**\n * @import {\n *   Tween,\n *   TweenKeyValue,\n *   TweenParamsOptions,\n *   TweenValues,\n *   DurationKeyframes,\n *   PercentageKeyframes,\n *   AnimationParams,\n *   TweenPropValue,\n *   ArraySyntaxValue,\n *   TargetsParam,\n *   TimerParams,\n *   TweenParamValue,\n *   DOMTarget,\n *   TargetsArray,\n *   Callback,\n *   EasingFunction,\n * } from '../types/index.js'\n *\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n *\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n */\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst inlineStylesStore = {};\nconst toFunctionStore = { func: null };\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = { to: null };\n\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */(key[p]);\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);\n    }\n\n  } else {\n    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));\n    const keys = Object.keys(keyframes)\n    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })\n    .sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */(properties[name]);\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = { to: prop[name] };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n\n    for (let name in properties) {\n      const propArray = /** @type {Array} */(properties[name]);\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n\n  }\n\n  return properties;\n};\n\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(\n    targets,\n    parameters,\n    parent,\n    parentPosition,\n    fastSet = false,\n    index = 0,\n    length = 0\n  ) {\n\n    super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;\n    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);\n\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender,\n    } = params;\n\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEase(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */(ease).settlingDuration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n    // This allows targeting the current animation in the spring onComplete callback\n    if (hasSpring) /** @type {Spring} */(ease).parent = this;\n\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n\n      for (let p in params) {\n\n        if (isKey(p)) {\n\n          const tweenType = getTweenType(target, p);\n\n          const propName = sanitizePropertyName(p, target, tweenType);\n\n          let propValue = params[p];\n\n          const isPropValueArray = isArr(propValue);\n\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */(propValue).length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n            // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n\n            const keyframe = keyframes[tweenIndex];\n\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);\n              key = keyObjectTarget;\n            }\n\n            toFunctionStore.func = null;\n\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n\n            let prevSibling = prevTween;\n\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(\n                    getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),\n                    decomposedOriginalValue\n                  );\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(\n                !prevSibling ? decomposeRawValue(\n                  getOriginalAnimatableValue(target, propName, tweenType, inlineStylesStore),\n                  decomposedOriginalValue\n                ).n : prevSibling._toNumber,\n                fromTargetObject.n,\n                fromTargetObject.o\n              );\n            }\n\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets\n            let inlineValue = inlineStylesStore[propName];\n            if (!isNil(inlineValue)) inlineStylesStore[propName] = null;\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEase(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables\n              _number: fromTargetObject.n, // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _inlineValue: inlineValue,\n              _prevRep: null, // For replaced tween\n              _nextRep: null, // For replaced tween\n              _prevAdd: null, // For additive tween\n              _nextAdd: null, // For additive tween\n              _prev: null,\n              _next: null,\n            };\n\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n\n            addChild(this, tween);\n\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n\n        }\n\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n\n    }\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        // TODO: Check for from / to Array based values here,\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    // This forces setter animations to render once\n    if (this.duration === minValue) this.restart();\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedJSAnimation\n   */\n\n  /**\n   * @param  {Callback<ResolvedJSAnimation>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\nexport { JSAnimation, animate };\n","/**\n * Anime.js - animatable - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { compositionTypes, noop } from '../core/consts.js';\nimport { scope } from '../core/globals.js';\nimport { isUnd, isKey, stringStartsWith, isObj, mergeObjects, forEachChildren, isStr, isArr } from '../core/helpers.js';\nimport { JSAnimation } from '../animation/animation.js';\nimport { parseEase } from '../easings/eases/parser.js';\n\n/**\n * @import {\n * TargetsParam,\n * AnimatableParams,\n * AnimationParams,\n * TweenParamsOptions,\n * Tween,\n * AnimatableProperty,\n * AnimatableObject,\n * } from '../types/index.js';\n */\n\nclass Animatable {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */\n  constructor(targets, parameters) {\n    if (scope.current) scope.current.register(this);\n    const beginHandler = () => {\n      if (this.callbacks.completed) this.callbacks.reset();\n      this.callbacks.play();\n    };\n    const pauseHandler = () => {\n      if (this.callbacks.completed) return;\n      let paused = true;\n      for (let name in this.animations) {\n        const anim = this.animations[name];\n        if (!anim.paused && paused) {\n          paused = false;\n          break;\n        }\n      }\n      if (paused) {\n        this.callbacks.complete();\n      }\n    };\n    /** @type {AnimationParams} */\n    const globalParams = {\n      onBegin: beginHandler,\n      onComplete: pauseHandler,\n      onPause: pauseHandler,\n    };\n    /** @type {AnimationParams} */\n    const callbacksAnimationParams = { v: 1, autoplay: false };\n    const properties = {};\n    this.targets = [];\n    this.animations = {};\n    /** @type {JSAnimation|null} */\n    this.callbacks = null;\n    if (isUnd(targets) || isUnd(parameters)) return;\n    for (let propName in parameters) {\n      const paramValue = parameters[propName];\n      if (isKey(propName)) {\n        properties[propName] = paramValue;\n      } else if (stringStartsWith(propName, 'on')) {\n        callbacksAnimationParams[propName] = paramValue;\n      } else {\n        globalParams[propName] = paramValue;\n      }\n    }\n    this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);\n    for (let propName in properties) {\n      const propValue = properties[propName];\n      const isObjValue = isObj(propValue);\n      /** @type {TweenParamsOptions} */\n      let propParams = {};\n      let to = '+=0';\n      if (isObjValue) {\n        const unit = propValue.unit;\n        if (isStr(unit)) to += unit;\n      } else {\n        propParams.duration = propValue;\n      }\n      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;\n      const animParams = mergeObjects(globalParams, propParams);\n      animParams.composition = compositionTypes.replace;\n      animParams.autoplay = false;\n      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n      if (!this.targets.length) this.targets.push(...animation.targets);\n      /** @type {AnimatableProperty} */\n      this[propName] = (to, duration, ease) => {\n        const tween = /** @type {Tween} */(animation._head);\n        if (isUnd(to) && tween) {\n          const numbers = tween._numbers;\n          if (numbers && numbers.length) {\n            return numbers;\n          } else {\n            return tween._modifier(tween._number);\n          }\n        } else {\n          forEachChildren(animation, (/** @type {Tween} */tween) => {\n            if (isArr(to)) {\n              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {\n                if (!isUnd(tween._numbers[i])) {\n                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));\n                  tween._toNumbers[i] = to[i];\n                }\n              }\n            } else {\n              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));\n              tween._toNumber = /** @type {Number} */(to);\n            }\n            if (!isUnd(ease)) tween._ease = parseEase(ease);\n            tween._currentTime = 0;\n          });\n          if (!isUnd(duration)) animation.stretch(duration);\n          animation.reset(true).resume();\n          return this;\n        }\n      };\n    }\n  }\n\n  revert() {\n    for (let propName in this.animations) {\n      this[propName] = noop;\n      this.animations[propName].revert();\n    }\n    this.animations = {};\n    this.targets.length = 0;\n    if (this.callbacks) this.callbacks.revert();\n    return this;\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */\nconst createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));\n\nexport { Animatable, createAnimatable };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { lerp } from '../core/helpers.js';\nexport { clamp, round, snap } from '../core/helpers.js';\n\n/**\n * Rounds a number to fixed decimal places\n * @param  {Number|String} v - Value to round\n * @param  {Number} decimalLength - Number of decimal places\n * @return {String}\n */\nconst roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);\n\n/**\n * Pads the start of a value with a string\n * @param  {Number} v - Value to pad\n * @param  {Number} totalLength - Target length\n * @param  {String} padString - String to pad with\n * @return {String}\n */\nconst padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);\n\n/**\n * Pads the end of a value with a string\n * @param  {Number} v - Value to pad\n * @param  {Number} totalLength - Target length\n * @param  {String} padString - String to pad with\n * @return {String}\n */\nconst padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);\n\n/**\n * Wraps a value within a range\n * @param  {Number} v - Value to wrap\n * @param  {Number} min - Minimum boundary\n * @param  {Number} max - Maximum boundary\n * @return {Number}\n */\nconst wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;\n\n/**\n * Maps a value from one range to another\n * @param  {Number} value - Input value\n * @param  {Number} inLow - Input range minimum\n * @param  {Number} inHigh - Input range maximum\n * @param  {Number} outLow - Output range minimum\n * @param  {Number} outHigh - Output range maximum\n * @return {Number}\n */\nconst mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);\n\n/**\n * Converts degrees to radians\n * @param  {Number} degrees - Angle in degrees\n * @return {Number}\n */\nconst degToRad = degrees => degrees * Math.PI / 180;\n\n/**\n * Converts radians to degrees\n * @param  {Number} radians - Angle in radians\n * @return {Number}\n */\nconst radToDeg = radians => radians * 180 / Math.PI;\n\n/**\n * Frame rate independent damped lerp\n * Based on: https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n *\n * @param  {Number} start - Starting value\n * @param  {Number} end - Target value\n * @param  {Number} deltaTime - Delta time in ms\n * @param  {Number} factor - Interpolation factor in the range [0, 1]\n * @return {Number} The interpolated value\n */\nconst damp = (start, end, deltaTime, factor) => {\n  return !factor ? start : factor === 1 ? end : lerp(start, end, 1 - Math.exp(-factor * deltaTime * .1));\n};\n\nexport { damp, degToRad, lerp, mapRange, padEnd, padStart, radToDeg, roundPad, wrap };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { K, minValue, noop } from '../../core/consts.js';\nimport { globals } from '../../core/globals.js';\nimport { isUnd, clamp, pow, PI, round, sqrt, abs, exp, cos, sin } from '../../core/helpers.js';\nimport { setValue } from '../../core/values.js';\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../../animation/animation.js'\n */\n\n/**\n * @import {\n *   EasingFunction,\n *   SpringParams,\n *   Callback,\n * } from '../../types/index.js'\n*/\n\n/*\n * Spring easing solver adapted from https://webkit.org/demos/spring/spring.js\n * (c) 2016 Webkit - Apple Inc\n */\n\nconst maxSpringParamValue = K * 10;\n\nclass Spring {\n  /**\n   * @param {SpringParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    const hasBounceOrDuration = !isUnd(parameters.bounce) || !isUnd(parameters.duration);\n    this.timeStep = .02; // Interval fed to the solver to calculate duration\n    this.restThreshold = .0005; // Values below this threshold are considered resting position\n    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n    this.bn = clamp(setValue(parameters.bounce, .5), -1, 1); // The bounce percentage between -1 and 1.\n    this.pd = clamp(setValue(parameters.duration, 628), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale); // The perceived duration\n    this.m = clamp(setValue(parameters.mass, 1), 1, maxSpringParamValue);\n    this.s = clamp(setValue(parameters.stiffness, 100), minValue, maxSpringParamValue);\n    this.d = clamp(setValue(parameters.damping, 10), minValue, maxSpringParamValue);\n    this.v = clamp(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.w0 = 0;\n    this.zeta = 0;\n    this.wd = 0;\n    this.b = 0;\n    this.completed = false;\n    this.solverDuration = 0;\n    this.settlingDuration = 0;\n    /** @type {JSAnimation} */\n    this.parent = null;\n    /** @type {Callback<JSAnimation>} */\n    this.onComplete = parameters.onComplete || noop;\n    if (hasBounceOrDuration) this.calculateSDFromBD();\n    this.compute();\n    /** @type {EasingFunction} */\n    this.ease = t => {\n      const currentTime = t * this.settlingDuration;\n      const completed = this.completed;\n      const perceivedTime = this.pd;\n      if (currentTime >= perceivedTime && !completed) {\n        this.completed = true;\n        this.onComplete(this.parent);\n      }\n      if (currentTime < perceivedTime && completed) {\n        this.completed = false;\n      }\n      return t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n    };\n  }\n\n  /** @type {EasingFunction} */\n  solve(time) {\n    const { zeta, w0, wd, b } = this;\n    let t = time;\n    if (zeta < 1) {\n      // Underdamped\n      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n    } else if (zeta === 1) {\n      // Critically damped\n      t = (1 + b * t) * exp(-t * w0);\n    } else {\n      // Overdamped\n      // Using exponential instead of cosh and sinh functions to prevent Infinity\n      // Original exp(-zeta * w0 * t) * (cosh(wd * t) + b * sinh(wd * t))\n      t = ((1 + b) * exp((-zeta * w0 + wd) * t) + (1 - b) * exp((-zeta * w0 - wd) * t)) / 2;\n    }\n    return 1 - t;\n  }\n\n  calculateSDFromBD() {\n    // Apple's SwiftUI perceived spring duration implementation https://developer.apple.com/videos/play/wwdc2023/10158/?time=1010\n    // Equations taken from Kevin Grajeda's article https://www.kvin.me/posts/effortless-ui-spring-animations\n    const pds = globals.timeScale === 1 ? this.pd / K : this.pd;\n    // Mass and velocity should be set to their default values\n    this.m = 1;\n    this.v = 0;\n    // Stiffness = (2  perceptualDuration)\n    this.s = pow((2 * PI) / pds, 2);\n    if (this.bn >= 0) {\n      // For bounce  0 (critically damped to underdamped)\n      // damping = ((1 - bounce)  4)  perceptualDuration\n      this.d = ((1 - this.bn) * 4 * PI) / pds;\n    } else {\n      // For bounce < 0 (overdamped)\n      // damping = 4  (perceptualDuration  (1 + bounce))\n      // Note: (1 + bounce) is positive since bounce is negative\n      this.d = (4 * PI) / (pds * (1 + this.bn));\n    }\n    this.s = round(clamp(this.s, minValue, maxSpringParamValue), 3);\n    this.d = round(clamp(this.d, minValue, 300), 3); // Clamping to 300 is needed to prevent insane values in the solver\n  }\n\n  calculateBDFromSD() {\n    // Calculate perceived duration and bounce from stiffness and damping\n    // Note: We assumes m = 1 and v = 0 for these calculations\n    const pds = (2 * PI) / sqrt(this.s);\n    this.pd = pds * (globals.timeScale === 1 ? K : 1);\n    const zeta = this.d / (2 * sqrt(this.s));\n    if (zeta <= 1) {\n      // Critically damped to underdamped\n      this.bn = 1 - (this.d * pds) / (4 * PI);\n    } else {\n      // Overdamped\n      this.bn = (4 * PI) / (this.d * pds) - 1;\n    }\n    this.bn = round(clamp(this.bn, -1, 1), 3);\n    this.pd = round(clamp(this.pd, 10 * globals.timeScale, maxSpringParamValue * globals.timeScale), 3);\n  }\n\n  compute() {\n    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n    const bouncedZeta = this.zeta = d / (2 * sqrt(s * m));\n    // Calculate wd based on damping type\n    if (bouncedZeta < 1) {\n      // Underdamped\n      this.wd = w0 * sqrt(1 - bouncedZeta * bouncedZeta);\n      this.b = (bouncedZeta * w0 + -v) / this.wd;\n    } else if (bouncedZeta === 1) {\n      // Critically damped\n      this.wd = 0;\n      this.b = -v + w0;\n    } else {\n      // Overdamped\n      this.wd = w0 * sqrt(bouncedZeta * bouncedZeta - 1);\n      this.b = (bouncedZeta * w0 + -v) / this.wd;\n    }\n\n    let solverTime = 0;\n    let restSteps = 0;\n    let iterations = 0;\n    while (restSteps <= maxRestSteps && iterations <= maxIterations) {\n      if (abs(1 - this.solve(solverTime)) < restThreshold) {\n        restSteps++;\n      } else {\n        restSteps = 0;\n      }\n      this.solverDuration = solverTime;\n      solverTime += timeStep;\n      iterations++;\n    }\n    this.settlingDuration = round(this.solverDuration * K, 0) * globals.timeScale;\n  }\n\n  get bounce() {\n    return this.bn;\n  }\n\n  set bounce(v) {\n    this.bn = clamp(setValue(v, 1), -1, 1);\n    this.calculateSDFromBD();\n    this.compute();\n  }\n\n  get duration() {\n    return this.pd;\n  }\n\n  set duration(v) {\n    this.pd = clamp(setValue(v, 1), 10 * globals.timeScale, maxSpringParamValue * globals.timeScale);\n    this.calculateSDFromBD();\n    this.compute();\n  }\n\n  get stiffness() {\n    return this.s;\n  }\n\n  set stiffness(v) {\n    this.s = clamp(setValue(v, 100), minValue, maxSpringParamValue);\n    this.calculateBDFromSD();\n    this.compute();\n  }\n\n  get damping() {\n    return this.d;\n  }\n\n  set damping(v) {\n    this.d = clamp(setValue(v, 10), minValue, maxSpringParamValue);\n    this.calculateBDFromSD();\n    this.compute();\n  }\n\n  get mass() {\n    return this.m;\n  }\n\n  set mass(v) {\n    this.m = clamp(setValue(v, 1), 1, maxSpringParamValue);\n    this.compute();\n  }\n\n  get velocity() {\n    return this.v;\n  }\n\n  set velocity(v) {\n    this.v = clamp(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.compute();\n  }\n}\n\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst spring = (parameters) => new Spring(parameters);\n\n/**\n * @deprecated createSpring() is deprecated use spring() instead\n *\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst createSpring = (parameters) => {\n  console.warn('createSpring() is deprecated use spring() instead');\n  return new Spring(parameters);\n};\n\nexport { Spring, createSpring, spring };\n","/**\n * Anime.js - waapi - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { removeChild, addChild } from '../core/helpers.js';\n\n/**\n * @import {\n *   DOMTarget,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\nconst WAAPIAnimationsLookups = {\n  _head: null,\n  _tail: null,\n};\n\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n * @return {globalThis.Animation}\n */\nconst removeWAAPIAnimation = ($el, property, parent) => {\n  let nextLookup = WAAPIAnimationsLookups._head;\n  let anim;\n  while (nextLookup) {\n    const next = nextLookup._next;\n    const matchTarget = nextLookup.$el === $el;\n    const matchProperty = !property || nextLookup.property === property;\n    const matchParent = !parent || nextLookup.parent === parent;\n    if (matchTarget && matchProperty && matchParent) {\n      anim = nextLookup.animation;\n      try { anim.commitStyles(); } catch {}      anim.cancel();\n      removeChild(WAAPIAnimationsLookups, nextLookup);\n      const lookupParent = nextLookup.parent;\n      if (lookupParent) {\n        lookupParent._completed++;\n        if (lookupParent.animations.length === lookupParent._completed) {\n          lookupParent.completed = true;\n          lookupParent.paused = true;\n          if (!lookupParent.muteCallbacks) {\n            lookupParent.onComplete(lookupParent);\n            lookupParent._resolve(lookupParent);\n          }\n        }\n      }\n    }\n    nextLookup = next;\n  }\n  return anim;\n};\n\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {globalThis.Animation}\n */\nconst addWAAPIAnimation = (parent, $el, property, keyframes, params) => {\n  const animation = $el.animate(keyframes, params);\n  const animTotalDuration = params.delay + (+params.duration * params.iterations);\n  animation.playbackRate = parent._speed;\n  if (parent.paused) animation.pause();\n  if (parent.duration < animTotalDuration) {\n    parent.duration = animTotalDuration;\n    parent.controlAnimation = animation;\n  }\n  parent.animations.push(animation);\n  removeWAAPIAnimation($el, property);\n  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });\n  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };\n  animation.oncancel = handleRemove;\n  animation.onremove = handleRemove;\n  if (!parent.persist) {\n    animation.onfinish = handleRemove;\n  }\n  return animation;\n};\n\nexport { addWAAPIAnimation, removeWAAPIAnimation };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from '../core/globals.js';\nimport { valueTypes, minValue, compositionTypes } from '../core/consts.js';\nimport { isUnd, round } from '../core/helpers.js';\nimport { registerTargets, parseTargets } from '../core/targets.js';\nimport { sanitizePropertyName } from '../core/styles.js';\nexport { cleanInlineStyles } from '../core/styles.js';\nimport { getTweenType, getOriginalAnimatableValue, decomposeRawValue, decomposedOriginalValue, setValue } from '../core/values.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { removeWAAPIAnimation } from '../waapi/composition.js';\nimport { removeTargetsFromRenderable } from '../animation/composition.js';\nimport { JSAnimation } from '../animation/animation.js';\n\n/**\n * @import {\n *   Renderable,\n *   DOMTargetSelector,\n *   JSTargetsParam,\n *   DOMTargetsParam,\n *   TargetsParam,\n *   DOMTarget,\n *   AnimationParams,\n *   TargetsArray,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String} propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String} propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String} propName\n * @param  {String} unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String} propName\n * @param  {Boolean} unit\n * @return {Number}\n *\n * @param  {TargetsParam} targetSelector\n * @param  {String} propName\n * @param  {String|Boolean} [unit]\n */\nfunction get(targetSelector, propName, unit) {\n  const targets = registerTargets(targetSelector);\n  if (!targets.length) return;\n  const [ target ] = targets;\n  const tweenType = getTweenType(target, propName);\n  const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n  let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n  if (isUnd(unit)) {\n    return originalValue;\n  } else {\n    decomposeRawValue(originalValue, decomposedOriginalValue);\n    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n      if (unit === false) {\n        return decomposedOriginalValue.n;\n      } else {\n        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);\n        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n      }\n    }\n  }\n}\n\n/**\n * @param  {TargetsParam} targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst set = (targets, parameters) => {\n  if (isUnd(parameters)) return;\n  parameters.duration = minValue;\n  // Do not overrides currently active tweens by default\n  parameters.composition = setValue(parameters.composition, compositionTypes.none);\n  // Skip init() and force rendering by playing the animation\n  return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String} [propertyName]\n * @return {TargetsArray}\n */\nconst remove = (targets, renderable, propertyName) => {\n  const targetsArray = parseTargets(targets);\n  for (let i = 0, l = targetsArray.length; i < l; i++) {\n    removeWAAPIAnimation(\n      /** @type {DOMTarget}  */(targetsArray[i]),\n      propertyName,\n      renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable),\n    );\n  }\n  removeTargetsFromRenderable(\n    targetsArray,\n    /** @type {Renderable} */(renderable),\n    propertyName\n  );\n  return targetsArray;\n};\n\nexport { registerTargets as $, get, remove, set };\n","/**\n * Anime.js - draggable - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals, scope } from '../core/globals.js';\nimport { doc, win, noop, maxValue, compositionTypes } from '../core/consts.js';\nimport { parseTargets } from '../core/targets.js';\nimport { isUnd, isObj, isArr, now, atan2, round, max, snap, clamp, isNum, abs, sqrt, cos, sin, isFnc } from '../core/helpers.js';\nimport { setValue } from '../core/values.js';\nimport { mapRange } from '../utils/number.js';\nimport { Timer } from '../timer/timer.js';\nimport { JSAnimation } from '../animation/animation.js';\nimport { removeTargetsFromRenderable } from '../animation/composition.js';\nimport { Animatable } from '../animatable/animatable.js';\nimport { parseEase, eases } from '../easings/eases/parser.js';\nimport { spring } from '../easings/spring/index.js';\nimport { get, set } from '../utils/target.js';\n\n/**\n * @import {\n *   DOMTarget,\n *   DOMTargetSelector,\n *   DraggableCursorParams,\n *   DraggableDragThresholdParams,\n *   TargetsParam,\n *   DraggableParams,\n *   EasingFunction,\n *   Callback,\n *   AnimatableParams,\n *   DraggableAxisParam,\n *   AnimatableObject,\n *   EasingParam,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n*/\n\n/**\n * @param {Event} e\n */\nconst preventDefault = e => {\n  if (e.cancelable) e.preventDefault();\n};\n\nclass DOMProxy {\n  /** @param {Object} el */\n  constructor(el) {\n    this.el = el;\n    this.zIndex = 0;\n    this.parentElement = null;\n    this.classList = {\n      add: noop,\n      remove: noop,\n    };\n  }\n\n  get x() { return this.el.x || 0 };\n  set x(v) { this.el.x = v; };\n\n  get y() { return this.el.y || 0 };\n  set y(v) { this.el.y = v; };\n\n  get width() { return this.el.width || 0 };\n  set width(v) { this.el.width = v; };\n\n  get height() { return this.el.height || 0 };\n  set height(v) { this.el.height = v; };\n\n  getBoundingClientRect() {\n    return {\n      top: this.y,\n      right: this.x,\n      bottom: this.y + this.height,\n      left: this.x + this.width,\n    }\n  }\n}\n\nclass Transforms {\n  /**\n   * @param {DOMTarget|DOMProxy} $el\n   */\n  constructor($el) {\n    this.$el = $el;\n    this.inlineTransforms = [];\n    this.point = new DOMPoint();\n    this.inversedMatrix = this.getMatrix().inverse();\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */\n  normalizePoint(x, y) {\n    this.point.x = x;\n    this.point.y = y;\n    return this.point.matrixTransform(this.inversedMatrix);\n  }\n\n  /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */\n\n  /**\n   * @param {TraverseParentsCallback} cb\n   */\n  traverseUp(cb) {\n    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;\n    while ($el && $el !== doc) {\n      cb(/** @type {DOMTarget} */($el), i);\n      $el = /** @type {DOMTarget} */($el.parentElement);\n      i++;\n    }\n  }\n\n  getMatrix() {\n    const matrix = new DOMMatrix();\n    this.traverseUp($el => {\n      const transformValue = getComputedStyle($el).transform;\n      if (transformValue) {\n        const elMatrix = new DOMMatrix(transformValue);\n        matrix.preMultiplySelf(elMatrix);\n      }\n    });\n    return matrix;\n  }\n\n  remove() {\n    this.traverseUp(($el, i) => {\n      this.inlineTransforms[i] = $el.style.transform;\n      $el.style.transform = 'none';\n    });\n  }\n\n  revert() {\n    this.traverseUp(($el, i) => {\n      const ct = this.inlineTransforms[i];\n      if (ct === '') {\n        $el.style.removeProperty('transform');\n      } else {\n        $el.style.transform = ct;\n      }\n    });\n  }\n}\n\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams|DraggableDragThresholdParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */\nconst parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : /** @type {T} */(value);\n\nlet zIndex = 0;\n\nclass Draggable {\n  /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    if (!target) return;\n    if (scope.current) scope.current.register(this);\n    const paramX = parameters.x;\n    const paramY = parameters.y;\n    const trigger = parameters.trigger;\n    const modifier = parameters.modifier;\n    const ease = parameters.releaseEase;\n    const customEase = ease && parseEase(ease);\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');\n    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');\n    const container = parseDraggableFunctionParameter(parameters.container, this);\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);\n    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);\n    this.fixed = get(this.$target, 'position') === 'fixed';\n    // Refreshable parameters\n    this.isFinePointer = true;\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerPadding = [0, 0, 0, 0];\n    /** @type {Number} */\n    this.containerFriction = 0;\n    /** @type {Number} */\n    this.releaseContainerFriction = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapX = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapY = 0;\n    /** @type {Number} */\n    this.scrollSpeed = 0;\n    /** @type {Number} */\n    this.scrollThreshold = 0;\n    /** @type {Number} */\n    this.dragSpeed = 0;\n    /** @type {Number} */\n    this.dragThreshold = 3;\n    /** @type {Number} */\n    this.maxVelocity = 0;\n    /** @type {Number} */\n    this.minVelocity = 0;\n    /** @type {Number} */\n    this.velocityMultiplier = 0;\n    /** @type {Boolean|DraggableCursorParams} */\n    this.cursor = false;\n    /** @type {Spring} */\n    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : spring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {Spring} */\n    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : spring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {EasingFunction} */\n    this.releaseEase = customEase || eases.outQuint;\n    /** @type {Boolean} */\n    this.hasReleaseSpring = hasSpring;\n    /** @type {Callback<this>} */\n    this.onGrab = parameters.onGrab || noop;\n    /** @type {Callback<this>} */\n    this.onDrag = parameters.onDrag || noop;\n    /** @type {Callback<this>} */\n    this.onRelease = parameters.onRelease || noop;\n    /** @type {Callback<this>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<this>} */\n    this.onSettle = parameters.onSettle || noop;\n    /** @type {Callback<this>} */\n    this.onSnap = parameters.onSnap || noop;\n    /** @type {Callback<this>} */\n    this.onResize = parameters.onResize || noop;\n    /** @type {Callback<this>} */\n    this.onAfterResize = parameters.onAfterResize || noop;\n    /** @type {[Number, Number]} */\n    this.disabled = [0, 0];\n    /** @type {AnimatableParams} */\n    const animatableParams = {};\n    if (modifier) animatableParams.modifier = modifier;\n    if (isUnd(paramX) || paramX === true) {\n      animatableParams[xProp] = 0;\n    } else if (isObj(paramX)) {\n      const paramXObject = /** @type {DraggableAxisParam} */(paramX);\n      const animatableXParams = {};\n      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n      animatableParams[xProp] = animatableXParams;\n    } else if (paramX === false) {\n      animatableParams[xProp] = 0;\n      this.disabled[0] = 1;\n    }\n    if (isUnd(paramY) || paramY === true) {\n      animatableParams[yProp] = 0;\n    } else if (isObj(paramY)) {\n      const paramYObject = /** @type {DraggableAxisParam} */(paramY);\n      const animatableYParams = {};\n      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n      animatableParams[yProp] = animatableYParams;\n    } else if (paramY === false) {\n      animatableParams[yProp] = 0;\n      this.disabled[1] = 1;\n    }\n    /** @type {AnimatableObject} */\n    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));\n    // Internal props\n    this.xProp = xProp;\n    this.yProp = yProp;\n    this.destX = 0;\n    this.destY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.scroll = {x: 0, y: 0};\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y\n    /** @type {[Number, Number]} */\n    this.snapped = [0, 0]; // x, y\n    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */\n    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n    /** @type {[Number, Number]} */\n    this.scrollView = [0, 0]; // w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.dragArea = [0, 0, 0, 0]; // x, y, w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number]} */\n    this.window = [0, 0]; // w, h\n    /** @type {[Number, Number, Number]} */\n    this.velocityStack = [0, 0, 0];\n    /** @type {Number} */\n    this.velocityStackIndex = 0;\n    /** @type {Number} */\n    this.velocityTime = now();\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Number} */\n    this.angle = 0;\n    /** @type {JSAnimation} */\n    this.cursorStyles = null;\n    /** @type {JSAnimation} */\n    this.triggerStyles = null;\n    /** @type {JSAnimation} */\n    this.bodyStyles = null;\n    /** @type {JSAnimation} */\n    this.targetStyles = null;\n    /** @type {JSAnimation} */\n    this.touchActionStyles = null;\n    this.transforms = new Transforms(this.$target);\n    this.overshootCoords = { x: 0, y: 0 };\n    this.overshootTicker = new Timer({\n      autoplay: false,\n      onUpdate: () => {\n        this.updated = true;\n        this.manual = true;\n        // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()\n        // https://github.com/juliangarnier/anime/issues/1045\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);\n      },\n      onComplete: () => {\n        this.manual = false;\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);\n      },\n    }, null, 0).init();\n    this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();\n    this.contained = !isUnd(container);\n    this.manual = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.enabled = false;\n    this.initialized = false;\n    this.activeProp = this.disabled[1] ? xProp : yProp;\n    this.animate.callbacks.onRender = () => {\n      const hasUpdated = this.updated;\n      const hasMoved = this.grabbed && hasUpdated;\n      const hasReleased = !hasMoved && this.released;\n      const x = this.x;\n      const y = this.y;\n      const dx = x - this.coords[2];\n      const dy = y - this.coords[3];\n      this.deltaX = dx;\n      this.deltaY = dy;\n      this.coords[2] = x;\n      this.coords[3] = y;\n      // Check if dx or dy are not 0 to check if the draggable has actually moved\n      // https://github.com/juliangarnier/anime/issues/1032\n      if (hasUpdated && (dx || dy)) {\n        this.onUpdate(this);\n      }\n      if (!hasReleased) {\n        this.updated = false;\n      } else {\n        this.computeVelocity(dx, dy);\n        this.angle = atan2(dy, dx);\n      }\n    };\n    this.animate.callbacks.onComplete = () => {\n      if ((!this.grabbed && this.released)) {\n        // Set released to false before calling onSettle to avoid recursion\n        this.released = false;\n      }\n      if (!this.manual) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.onSettle(this);\n      }\n    };\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 150 * globals.timeScale,\n      onComplete: () => {\n        this.onResize(this);\n        this.refresh();\n        this.onAfterResize(this);\n      },\n    }).init();\n    this.parameters = parameters;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (this.initialized) {\n        this.resizeTicker.restart();\n      } else {\n        this.initialized = true;\n      }\n    });\n    this.enable();\n    this.refresh();\n    this.resizeObserver.observe(this.$container);\n    if (!isObj(target)) this.resizeObserver.observe(this.$target);\n  }\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */\n  computeVelocity(dx, dy) {\n    const prevTime = this.velocityTime;\n    const curTime = now();\n    const elapsed = curTime - prevTime;\n    if (elapsed < 17) return this.velocity;\n    this.velocityTime = curTime;\n    const velocityStack = this.velocityStack;\n    const vMul = this.velocityMultiplier;\n    const minV = this.minVelocity;\n    const maxV = this.maxVelocity;\n    const vi = this.velocityStackIndex;\n    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);\n    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n    this.velocity = velocity;\n    this.velocityStackIndex = (vi + 1) % 3;\n    return velocity;\n  }\n\n  /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setX(x, muteUpdateCallback = false) {\n    if (this.disabled[0]) return;\n    const v = round(x, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destX = v;\n    this.snapped[0] = snap(v, this.snapX);\n    this.animate[this.xProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setY(y, muteUpdateCallback = false) {\n    if (this.disabled[1]) return;\n    const v = round(y, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destY = v;\n    this.snapped[1] = snap(v, this.snapY);\n    this.animate[this.yProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  get x() {\n    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);\n  }\n\n  set x(x) {\n    this.setX(x, false);\n  }\n\n  get y() {\n    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);\n  }\n\n  set y(y) {\n    this.setY(y, false);\n  }\n\n  get progressX() {\n    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n  }\n\n  set progressX(x) {\n    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n  }\n\n  get progressY() {\n    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n  }\n\n  set progressY(y) {\n    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n  }\n\n  updateScrollCoords() {\n    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const threshold = this.scrollThreshold;\n    this.scroll.x = sx;\n    this.scroll.y = sy;\n    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n  }\n\n  updateBoundingValues() {\n    const $container = this.$container;\n    // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight\n    // https://github.com/juliangarnier/anime/issues/1064\n    if (!$container) return;\n    const cx = this.x;\n    const cy = this.y;\n    const cx2 = this.coords[2];\n    const cy2 =  this.coords[3];\n    // Prevents interfering with the scroll area in cases the target is outside of the container\n    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n    this.coords[2] = 0;\n    this.coords[3] = 0;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.transforms.remove();\n    const iw = this.window[0] = win.innerWidth;\n    const ih = this.window[1] = win.innerHeight;\n    const uw = this.useWin;\n    const sw = $container.scrollWidth;\n    const sh = $container.scrollHeight;\n    const fx = this.fixed;\n    const transformContainerRect = $container.getBoundingClientRect();\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n    this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n    this.updateScrollCoords();\n    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n    const containerOverflow = get($container, 'overflow');\n    const visibleOverflow = containerOverflow === 'visible';\n    const hiddenOverflow = containerOverflow === 'hidden';\n    this.canScroll = fx ? false :\n      this.contained &&\n      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&\n      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&\n      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));\n    if (this.contained) {\n      const sx = this.scroll.x;\n      const sy = this.scroll.y;\n      const canScroll = this.canScroll;\n      const targetRect = this.$target.getBoundingClientRect();\n      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);\n      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);\n      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);\n      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);\n      if (this.containerArray) {\n        this.containerBounds[0] = this.containerArray[0] + cpt;\n        this.containerBounds[1] = this.containerArray[1] - cpr;\n        this.containerBounds[2] = this.containerArray[2] - cpb;\n        this.containerBounds[3] = this.containerArray[3] + cpl;\n      } else {\n        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n      }\n    }\n    this.transforms.revert();\n    // Restore coordinates\n    this.coords[2] = cx2;\n    this.coords[3] = cy2;\n    this.setX(cx, true);\n    this.setY(cy, true);\n  }\n\n  /**\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  isOutOfBounds(bounds, x, y) {\n    // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n    if (!this.contained) return 0;\n    const [ bt, br, bb, bl ] = bounds;\n    const [ dx, dy ] = this.disabled;\n    const obx = !dx && x < bl || !dx && x > br;\n    const oby = !dy && y < bt || !dy && y > bb;\n    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n  }\n\n  refresh() {\n    const params = this.parameters;\n    const paramX = params.x;\n    const paramY = params.y;\n    const container = parseDraggableFunctionParameter(params.container, this);\n    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);\n    const cx = this.x;\n    const cy = this.y;\n    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };\n    if (parsedCursorStyles) {\n      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);\n      if (onHover) cursorStyles.onHover = onHover;\n      if (onGrab) cursorStyles.onGrab = onGrab;\n    }\n    const parsedDragThreshold = parseDraggableFunctionParameter(params.dragThreshold, this);\n    const dragThreshold = { mouse: 3, touch: 7 };\n    if (isNum(parsedDragThreshold)) {\n      dragThreshold.mouse = parsedDragThreshold;\n      dragThreshold.touch = parsedDragThreshold;\n    } else if (parsedDragThreshold) {\n      const { mouse, touch } = parsedDragThreshold;\n      if (!isUnd(mouse)) dragThreshold.mouse = mouse;\n      if (!isUnd(touch)) dragThreshold.touch = touch;\n    }\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.isFinePointer = matchMedia('(pointer:fine)').matches;\n    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);\n    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n    this.dragThreshold = this.isFinePointer ? dragThreshold.mouse : dragThreshold.touch;\n    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n    this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n    this.updateBoundingValues();\n\n    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n    // if (ob === 1 || ob === 3) this.progressX = px;\n    // if (ob === 2 || ob === 3) this.progressY = py;\n\n    // if (this.initialized && this.contained) {\n    //   if (this.progressX !== px) this.progressX = px;\n    //   if (this.progressY !== py) this.progressY = py;\n    // }\n\n    const [ bt, br, bb, bl ] = this.containerBounds;\n    this.setX(clamp(cx, bl, br), true);\n    this.setY(clamp(cy, bt, bb), true);\n  }\n\n  update() {\n    this.updateScrollCoords();\n    if (this.canScroll) {\n      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n      const [ sw, sh ] = this.scrollView;\n      const daw = this.dragArea[2];\n      const dah = this.dragArea[3];\n      const csx = this.scroll.x;\n      const csy = this.scroll.y;\n      const nsw = this.$container.scrollWidth;\n      const nsh = this.$container.scrollHeight;\n      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n      const swd = sw - csw;\n      const shd = sh - csh;\n      // Handle cases where the scrollarea dimensions changes during drag\n      if (this.dragged && swd > 0) {\n        this.coords[0] -= swd;\n        this.scrollView[0] = csw;\n      }\n      if (this.dragged && shd > 0) {\n        this.coords[1] -= shd;\n        this.scrollView[1] = csh;\n      }\n      // Handle autoscroll when target is at the edges of the scroll bounds\n      const s = this.scrollSpeed * 10;\n      const threshold = this.scrollThreshold;\n      const [ x, y ] = this.coords;\n      const [ st, sr, sb, sl ] = this.scrollBounds;\n      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n      if (t || b || l || r) {\n        const [nx, ny] = this.disabled;\n        let scrollX = csx;\n        let scrollY = csy;\n        if (!nx) {\n          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n          this.coords[0] -= csx - scrollX;\n        }\n        if (!ny) {\n          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n          this.coords[1] -= csy - scrollY;\n        }\n        // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n        if (this.useWin) {\n          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n        } else {\n          this.$scrollContainer.scrollTo(scrollX, scrollY);\n        }\n      }\n    }\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    this.coords[0] += (px1 - px3) * this.dragSpeed;\n    this.coords[1] += (py1 - py3) * this.dragSpeed;\n    this.pointer[4] = px1;\n    this.pointer[5] = py1;\n    const [ cx, cy ] = this.coords;\n    const [ sx, sy ] = this.snapped;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n    this.computeVelocity(px1 - px3, py1 - py3);\n    this.angle = atan2(py1 - py2, px1 - px2);\n    const [ nsx, nsy ] = this.snapped;\n    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n      this.onSnap(this);\n    }\n  }\n\n  stop() {\n    this.updateTicker.pause();\n    this.overshootTicker.pause();\n    // Pauses the in bounds onRelease animations\n    for (let prop in this.animate.animations) this.animate.animations[prop].pause();\n    removeTargetsFromRenderable([this], null, 'x');\n    removeTargetsFromRenderable([this], null, 'y');\n    removeTargetsFromRenderable([this], null, 'progressX');\n    removeTargetsFromRenderable([this], null, 'progressY');\n    removeTargetsFromRenderable([this.scroll]); // Removes any active animations on the container scroll\n    removeTargetsFromRenderable([this.overshootCoords]); // Removes active overshoot animations\n    return this;\n  }\n\n  /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */\n  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.updateScrollCoords();\n    const x = this.destX;\n    const y = this.destY;\n    const scroll = this.scroll;\n    const scrollBounds = this.scrollBounds;\n    const canScroll = this.canScroll;\n    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n      const [ st, sr, sb, sl ] = scrollBounds;\n      const t = round(clamp(y - st, -maxValue, 0), 0);\n      const r = round(clamp(x - sr, 0, maxValue), 0);\n      const b = round(clamp(y - sb, 0, maxValue), 0);\n      const l = round(clamp(x - sl, -maxValue, 0), 0);\n      new JSAnimation(scroll, {\n        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n        duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n        ease,\n        onUpdate: () => {\n          this.canScroll = false;\n          this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n        }\n      }).init().then(() => {\n        this.canScroll = canScroll;\n      });\n    }\n    return this;\n  }\n\n  handleHover() {\n    if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n      this.cursorStyles = set(this.$trigger, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover\n      });\n    }\n  }\n\n  /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */\n  animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.stop();\n    this.updateBoundingValues();\n    const x = this.x;\n    const y = this.y;\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);\n    if (ob) {\n      const [ disabledX, disabledY ] = this.disabled;\n      const destX = clamp(snap(x, this.snapX), bl, br);\n      const destY = clamp(snap(y, this.snapY), bt, bb);\n      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n    }\n    return this;\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleDown(e) {\n    const $eTarget = /** @type {HTMLElement} */(e.target);\n    if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;\n\n    e.stopPropagation();\n\n    this.grabbed = true;\n    this.released = false;\n    this.stop();\n    this.updateBoundingValues();\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    const cx = this.x;\n    const cy = this.y;\n    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n    this.pointer[0] = x;\n    this.pointer[1] = y;\n    this.pointer[2] = x;\n    this.pointer[3] = y;\n    this.pointer[4] = x;\n    this.pointer[5] = y;\n    this.pointer[6] = x;\n    this.pointer[7] = y;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    const z = /** @type {Number} */(get(this.$target, 'zIndex', false));\n    zIndex = (z > zIndex ? z : zIndex) + 1;\n    this.targetStyles = set(this.$target, { zIndex });\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.isFinePointer && this.cursor) {\n      this.bodyStyles = set(doc.body, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab\n      });\n    }\n    this.scrollInView(100, 0, eases.out(3));\n    this.onGrab(this);\n\n    doc.addEventListener('touchmove', this);\n    doc.addEventListener('touchend', this);\n    doc.addEventListener('touchcancel', this);\n    doc.addEventListener('mousemove', this);\n    doc.addEventListener('mouseup', this);\n    doc.addEventListener('selectstart', this);\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleMove(e) {\n    if (!this.grabbed) return;\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const movedX = x - this.pointer[6];\n    const movedY = y - this.pointer[7];\n\n    let $parent = /** @type {HTMLElement} */(e.target);\n    let isAtTop = false;\n    let isAtBottom = false;\n    let canTouchScroll = false;\n\n    while (touches && $parent && $parent !== this.$trigger) {\n      const overflowY = get($parent, 'overflow-y');\n      if (overflowY !== 'hidden' && overflowY !== 'visible') {\n        const { scrollTop, scrollHeight, clientHeight } = $parent;\n        if (scrollHeight > clientHeight) {\n          canTouchScroll = true;\n          isAtTop = scrollTop <= 3;\n          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;\n          break;\n        }\n      }\n      $parent = $parent.parentElement;\n    }\n\n    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {\n\n      this.pointer[0] = x;\n      this.pointer[1] = y;\n      this.pointer[2] = x;\n      this.pointer[3] = y;\n      this.pointer[4] = x;\n      this.pointer[5] = y;\n      this.pointer[6] = x;\n      this.pointer[7] = y;\n\n    } else {\n\n      preventDefault(e);\n\n      // Needed to prevents click on handleUp\n      if (!this.triggerStyles) this.triggerStyles = set(this.$trigger, { pointerEvents: 'none' });\n      // Needed to prevent page scroll while dragging on touch devvice\n      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchend', preventDefault);\n\n      // Don't check for a miminim distance move if already dragging\n      if (this.dragged || (!this.disabled[0] && abs(movedX) > this.dragThreshold) || (!this.disabled[1] && abs(movedY) > this.dragThreshold)) {\n        this.updateTicker.resume();\n        this.pointer[2] = this.pointer[0];\n        this.pointer[3] = this.pointer[1];\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.dragged = true;\n        this.released = false;\n        this.onDrag(this);\n      }\n    }\n  }\n\n  handleUp() {\n\n    if (!this.grabbed) return;\n\n    this.updateTicker.pause();\n\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n\n    const [ disabledX, disabledY ] = this.disabled;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ sx, sy ] = this.snapped;\n    const springX = this.releaseXSpring;\n    const springY = this.releaseYSpring;\n    const releaseEase = this.releaseEase;\n    const hasReleaseSpring = this.hasReleaseSpring;\n    const overshootCoords = this.overshootCoords;\n    const cx = this.x;\n    const cy = this.y;\n    const pv = this.computeVelocity(px1 - px3, py1 - py3);\n    const pa = this.angle = atan2(py1 - py2, px1 - px2);\n    const ds = pv * 150;\n    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n    const nx = cx + (cos(pa) * ds);\n    const ny = cy + (sin(pa) * ds);\n    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n\n    let durationX = 0;\n    let durationY = 0;\n    let easeX = releaseEase;\n    let easeY = releaseEase;\n    let longestReleaseDuration = 0;\n\n    overshootCoords.x = cx;\n    overshootCoords.y = cy;\n\n    if (!disabledX) {\n      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n      const distanceX = round(cx - dx, 0);\n      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;\n      const { ease, settlingDuration, restDuration } = springX;\n      durationX = cx === dx ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeX = ease;\n      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n    }\n\n    if (!disabledY) {\n      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n      const distanceY = round(cy - dy, 0);\n      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;\n      const { ease, settlingDuration, restDuration } = springY;\n      durationY = cy === dy ? 0 : hasReleaseSpring ? settlingDuration : settlingDuration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeY = ease;\n      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n    }\n\n    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n\n        const composition = compositionTypes.blend;\n\n        new JSAnimation(overshootCoords, {\n          x: { to: bx, duration: durationX * .65 },\n          y: { to: by, duration: durationY * .65 },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        new JSAnimation(overshootCoords, {\n          x: { to: dx, duration: durationX },\n          y: { to: dy, duration: durationY },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        this.overshootTicker.stretch(max(durationX, durationY)).restart();\n\n    } else {\n\n      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n\n    }\n\n    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n\n    let hasSnapped = false;\n\n    if (dx !== sx) {\n      this.snapped[0] = dx;\n      if (this.snapX) hasSnapped = true;\n    }\n\n    if (dy !== sy && this.snapY) {\n      this.snapped[1] = dy;\n      if (this.snapY) hasSnapped = true;\n    }\n\n    if (hasSnapped) this.onSnap(this);\n\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = true;\n    this.released = true;\n\n    // It's important to trigger the callback after the release animations to be able to cancel them\n    this.onRelease(this);\n\n    this.$trigger.removeEventListener('touchstart', preventDefault);\n    this.$trigger.removeEventListener('touchmove', preventDefault);\n    this.$trigger.removeEventListener('touchend', preventDefault);\n\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n  }\n\n  reset() {\n    this.stop();\n    this.resizeTicker.pause();\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.coords[0] = 0;\n    this.coords[1] = 0;\n    this.pointer[0] = 0;\n    this.pointer[1] = 0;\n    this.pointer[2] = 0;\n    this.pointer[3] = 0;\n    this.pointer[4] = 0;\n    this.pointer[5] = 0;\n    this.pointer[6] = 0;\n    this.pointer[7] = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    return this;\n  }\n\n  enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.$target.classList.remove('is-disabled');\n      this.touchActionStyles = set(this.$trigger, {\n        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'\n      });\n      this.$trigger.addEventListener('touchstart', this, { passive: true });\n      this.$trigger.addEventListener('mousedown', this, { passive: true });\n      this.$trigger.addEventListener('mouseenter', this);\n    }\n    return this;\n  }\n\n  disable() {\n    this.enabled = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.touchActionStyles.revert();\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    this.$target.classList.add('is-disabled');\n    this.$trigger.removeEventListener('touchstart', this);\n    this.$trigger.removeEventListener('mousedown', this);\n    this.$trigger.removeEventListener('mouseenter', this);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n    return this;\n  }\n\n  revert() {\n    this.reset();\n    this.disable();\n    this.$target.classList.remove('is-disabled');\n    this.updateTicker.revert();\n    this.overshootTicker.revert();\n    this.resizeTicker.revert();\n    this.animate.revert();\n    this.resizeObserver.disconnect();\n    return this;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'mousedown':\n        this.handleDown(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchstart':\n        this.handleDown(/** @type {TouchEvent} */(e));\n        break;\n      case 'mousemove':\n        this.handleMove(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchmove':\n        this.handleMove(/** @type {TouchEvent} */(e));\n        break;\n      case 'mouseup':\n        this.handleUp();\n        break;\n      case 'touchend':\n        this.handleUp();\n        break;\n      case 'touchcancel':\n        this.handleUp();\n        break;\n      case 'mouseenter':\n        this.handleHover();\n        break;\n      case 'selectstart':\n        preventDefault(e);\n        break;\n    }\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */\nconst createDraggable = (target, parameters) => new Draggable(target, parameters);\n\nexport { Draggable, createDraggable };\n"],"mappings":"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"}