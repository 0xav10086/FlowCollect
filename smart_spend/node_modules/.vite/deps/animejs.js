import { n as __export } from "./chunk-DUEDWNxO.js";
import { $ as lerp$1, A as decomposedOriginalValue, B as clamp$1, C as Timer, Ct as shortTransforms, D as cleanInlineStyles, Dt as unitsExecRgx, E as engine, Et as transformsSymbol, F as PI, G as isFnc, H as floor, I as abs, J as isNum, K as isKey, L as addChild, M as getOriginalAnimatableValue, N as getRelativeValue, O as tick, Ot as validTransforms, P as setValue, Q as isUnd, R as atan2, S as registerTargets, St as relativeValuesExecRgx, T as removeTargetsFromRenderable, Tt as transformsFragmentStrings, U as forEachChildren, V as clampInfinity, W as isArr, X as isStr, Y as isObj, Z as isSvg, _ as parseEaseString, _t as isSvgSymbol, a as set, at as round$1, b as getNodeList, bt as noop, c as createSpring, ct as toLowerCase, d as Animatable, dt as K, et as max, f as createAnimatable, ft as compositionTypes, g as parseEase, gt as isDomSymbol, h as eases, ht as isBrowser, i as remove, it as removeChild, j as getFunctionValue, k as decomposeRawValue, kt as win, l as spring, lt as globals, m as animate, mt as emptyString, n as createDraggable, nt as normalizeTime, o as addWAAPIAnimation, ot as sqrt, p as JSAnimation, pt as doc, q as isNil, r as get, rt as parseNumber, s as Spring, st as stringStartsWith, t as Draggable, tt as mergeObjects, u as number_exports, ut as scope, v as none, vt as minValue, w as createTimer, wt as tickModes, x as parseTargets, xt as proxyTargetSymbol, y as convertValueUnit, yt as morphPointsSymbol, z as ceil } from "./draggable-D1wNpi7L.js";

//#region node_modules/animejs/dist/modules/timeline/position.js
/**
* Anime.js - timeline - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Tickable,
*   TimelinePosition,
* } from '../types/index.js'
*/
/**
* @import {
*   Timeline,
* } from './timeline.js'
*/
/**
* Timeline's children offsets positions parser
* @param  {Timeline} timeline
* @param  {String} timePosition
* @return {Number}
*/
var getPrevChildOffset = (timeline, timePosition) => {
	if (stringStartsWith(timePosition, "<")) {
		const goToPrevAnimationOffset = timePosition[1] === "<";
		const prevAnimation = timeline._tail;
		const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
		return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
	}
};
/**
* @param  {Timeline} timeline
* @param  {TimelinePosition} [timePosition]
* @return {Number}
*/
var parseTimelinePosition = (timeline, timePosition) => {
	let tlDuration = timeline.iterationDuration;
	if (tlDuration === minValue) tlDuration = 0;
	if (isUnd(timePosition)) return tlDuration;
	if (isNum(+timePosition)) return +timePosition;
	const timePosStr = timePosition;
	const tlLabels = timeline ? timeline.labels : null;
	const hasLabels = !isNil(tlLabels);
	const prevOffset = getPrevChildOffset(timeline, timePosStr);
	const hasSibling = !isUnd(prevOffset);
	const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
	if (matchedRelativeOperator) {
		const fullOperator = matchedRelativeOperator[0];
		const split$1 = timePosStr.split(fullOperator);
		const labelOffset = hasLabels && split$1[0] ? tlLabels[split$1[0]] : tlDuration;
		return getRelativeValue(hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration, +split$1[1], fullOperator[0]);
	} else return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;
};

//#endregion
//#region node_modules/animejs/dist/modules/timeline/timeline.js
/**
* Anime.js - timeline - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
*   Callback,
*   Tickable,
*   TimerParams,
*   AnimationParams,
*   Target,
*   Renderable,
*   TimelineParams,
*   DefaultsParams,
*   TimelinePosition,
*   StaggerFunction,
* } from '../types/index.js'
*/
/**
* @import {
*   WAAPIAnimation,
* } from '../waapi/waapi.js'
*/
/**
* @param {Timeline} tl
* @return {Number}
*/
function getTimelineTotalDuration(tl) {
	return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;
}
/**
* @overload
* @param  {TimerParams} childParams
* @param  {Timeline} tl
* @param  {Number} timePosition
* @return {Timeline}
*
* @overload
* @param  {AnimationParams} childParams
* @param  {Timeline} tl
* @param  {Number} timePosition
* @param  {TargetsParam} targets
* @param  {Number} [index]
* @param  {Number} [length]
* @return {Timeline}
*
* @param  {TimerParams|AnimationParams} childParams
* @param  {Timeline} tl
* @param  {Number} timePosition
* @param  {TargetsParam} [targets]
* @param  {Number} [index]
* @param  {Number} [length]
*/
function addTlChild(childParams, tl, timePosition, targets, index, length) {
	const adjustedPosition = isNum(childParams.duration) && childParams.duration <= minValue ? timePosition - minValue : timePosition;
	tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
	const tlChild = targets ? new JSAnimation(targets, childParams, tl, adjustedPosition, false, index, length) : new Timer(childParams, tl, adjustedPosition);
	tlChild.init(true);
	addChild(tl, tlChild);
	forEachChildren(tl, (child) => {
		const childDur = child._offset + child._delay + child.duration;
		if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;
	});
	tl.duration = getTimelineTotalDuration(tl);
	return tl;
}
var Timeline = class extends Timer {
	/**
	* @param {TimelineParams} [parameters]
	*/
	constructor(parameters = {}) {
		super(parameters, null, 0);
		/** @type {Number} */
		this.duration = 0;
		/** @type {Record<String, Number>} */
		this.labels = {};
		const defaultsParams = parameters.defaults;
		const globalDefaults = globals.defaults;
		/** @type {DefaultsParams} */
		this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
		/** @type {Callback<this>} */
		this.onRender = parameters.onRender || globalDefaults.onRender;
		const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
		this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;
		/** @type {Number} */
		this.iterationDuration = 0;
	}
	/**
	* @overload
	* @param {TargetsParam} a1
	* @param {AnimationParams} a2
	* @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
	* @return {this}
	*
	* @overload
	* @param {TimerParams} a1
	* @param {TimelinePosition} [a2]
	* @return {this}
	*
	* @param {TargetsParam|TimerParams} a1
	* @param {TimelinePosition|AnimationParams} a2
	* @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
	*/
	add(a1, a2, a3) {
		const isAnim = isObj(a2);
		const isTimer = isObj(a1);
		if (isAnim || isTimer) {
			this._hasChildren = true;
			if (isAnim) {
				const childParams = a2;
				if (isFnc(a3)) {
					const staggeredPosition = a3;
					const parsedTargetsArray = parseTargets(a1);
					const tlDuration = this.duration;
					const tlIterationDuration = this.iterationDuration;
					const id = childParams.id;
					let i = 0;
					/** @type {Number} */
					const parsedLength = parsedTargetsArray.length;
					parsedTargetsArray.forEach((target) => {
						const staggeredChildParams = { ...childParams };
						this.duration = tlDuration;
						this.iterationDuration = tlIterationDuration;
						if (!isUnd(id)) staggeredChildParams.id = id + "-" + i;
						addTlChild(staggeredChildParams, this, parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)), target, i, parsedLength);
						i++;
					});
				} else addTlChild(childParams, this, parseTimelinePosition(this, a3), a1);
			} else addTlChild(a1, this, parseTimelinePosition(this, a2));
			return this.init(true);
		}
	}
	/**
	* @overload
	* @param {Tickable} [synced]
	* @param {TimelinePosition} [position]
	* @return {this}
	*
	* @overload
	* @param {globalThis.Animation} [synced]
	* @param {TimelinePosition} [position]
	* @return {this}
	*
	* @overload
	* @param {WAAPIAnimation} [synced]
	* @param {TimelinePosition} [position]
	* @return {this}
	*
	* @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
	* @param {TimelinePosition} [position]
	*/
	sync(synced, position) {
		if (isUnd(synced) || synced && isUnd(synced.pause)) return this;
		synced.pause();
		const duration = +(synced.effect ? synced.effect.getTiming().duration : synced.duration);
		return this.add(synced, {
			currentTime: [0, duration],
			duration,
			ease: "linear"
		}, position);
	}
	/**
	* @param  {TargetsParam} targets
	* @param  {AnimationParams} parameters
	* @param  {TimelinePosition} [position]
	* @return {this}
	*/
	set(targets, parameters, position) {
		if (isUnd(parameters)) return this;
		parameters.duration = minValue;
		parameters.composition = compositionTypes.replace;
		return this.add(targets, parameters, position);
	}
	/**
	* @param {Callback<Timer>} callback
	* @param {TimelinePosition} [position]
	* @return {this}
	*/
	call(callback, position) {
		if (isUnd(callback) || callback && !isFnc(callback)) return this;
		return this.add({
			duration: 0,
			onComplete: () => callback(this)
		}, position);
	}
	/**
	* @param {String} labelName
	* @param {TimelinePosition} [position]
	* @return {this}
	*
	*/
	label(labelName, position) {
		if (isUnd(labelName) || labelName && !isStr(labelName)) return this;
		this.labels[labelName] = parseTimelinePosition(this, position);
		return this;
	}
	/**
	* @param  {TargetsParam} targets
	* @param  {String} [propertyName]
	* @return {this}
	*/
	remove(targets, propertyName) {
		removeTargetsFromRenderable(parseTargets(targets), this, propertyName);
		return this;
	}
	/**
	* @param  {Number} newDuration
	* @return {this}
	*/
	stretch(newDuration) {
		const currentDuration = this.duration;
		if (currentDuration === normalizeTime(newDuration)) return this;
		const timeScale = newDuration / currentDuration;
		const labels = this.labels;
		forEachChildren(this, (child) => child.stretch(child.duration * timeScale));
		for (let labelName in labels) labels[labelName] *= timeScale;
		return super.stretch(newDuration);
	}
	/**
	* @return {this}
	*/
	refresh() {
		forEachChildren(this, (child) => {
			if (child.refresh) child.refresh();
		});
		return this;
	}
	/**
	* @return {this}
	*/
	revert() {
		super.revert();
		forEachChildren(this, (child) => child.revert, true);
		return cleanInlineStyles(this);
	}
	/**
	* @typedef {this & {then: null}} ResolvedTimeline
	*/
	/**
	* @param  {Callback<ResolvedTimeline>} [callback]
	* @return Promise<this>
	*/
	then(callback) {
		return super.then(callback);
	}
};
/**
* @param {TimelineParams} [parameters]
* @return {Timeline}
*/
var createTimeline = (parameters) => new Timeline(parameters).init();

//#endregion
//#region node_modules/animejs/dist/modules/utils/time.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Callback,
*   Tickable,
* } from '../types/index.js'
*/
/**
* @param  {Callback<Timer>} [callback]
* @return {Timer}
*/
var sync = (callback = noop) => {
	return new Timer({
		duration: 1 * globals.timeScale,
		onComplete: callback
	}, null, 0).resume();
};
/**
* @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor
* @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}
*/
var keepTime = (constructor) => {
	/** @type {Tickable} */
	let tracked;
	return (...args) => {
		let currentIteration, currentIterationProgress, reversed, alternate;
		if (tracked) {
			currentIteration = tracked.currentIteration;
			currentIterationProgress = tracked.iterationProgress;
			reversed = tracked.reversed;
			alternate = tracked._alternate;
			tracked.revert();
		}
		const cleanup = constructor(...args);
		if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;
		if (!isUnd(currentIterationProgress)) {
			/** @type {Tickable} */ tracked.currentIteration = currentIteration;
			/** @type {Tickable} */ tracked.iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;
		}
		return cleanup || noop;
	};
};

//#endregion
//#region node_modules/animejs/dist/modules/scope/scope.js
/**
* Anime.js - scope - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Tickable,
*   ScopeParams,
*   DOMTarget,
*   ReactRef,
*   AngularRef,
*   DOMTargetSelector,
*   DefaultsParams,
*   ScopeConstructorCallback,
*   ScopeCleanupCallback,
*   Revertible,
*   ScopeMethod,
*   ScopedCallback,
* } from '../types/index.js'
*/
var Scope = class {
	/** @param {ScopeParams} [parameters] */
	constructor(parameters = {}) {
		if (scope.current) scope.current.register(this);
		const rootParam = parameters.root;
		/** @type {Document|DOMTarget} */
		let root = doc;
		if (rootParam) root = rootParam.current || rootParam.nativeElement || parseTargets(rootParam)[0] || doc;
		const scopeDefaults = parameters.defaults;
		const globalDefault = globals.defaults;
		const mediaQueries = parameters.mediaQueries;
		/** @type {DefaultsParams} */
		this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;
		/** @type {Document|DOMTarget} */
		this.root = root;
		/** @type {Array<ScopeConstructorCallback>} */
		this.constructors = [];
		/** @type {Array<ScopeCleanupCallback>} */
		this.revertConstructors = [];
		/** @type {Array<Revertible>} */
		this.revertibles = [];
		/** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */
		this.constructorsOnce = [];
		/** @type {Array<ScopeCleanupCallback>} */
		this.revertConstructorsOnce = [];
		/** @type {Array<Revertible>} */
		this.revertiblesOnce = [];
		/** @type {Boolean} */
		this.once = false;
		/** @type {Number} */
		this.onceIndex = 0;
		/** @type {Record<String, ScopeMethod>} */
		this.methods = {};
		/** @type {Record<String, Boolean>} */
		this.matches = {};
		/** @type {Record<String, MediaQueryList>} */
		this.mediaQueryLists = {};
		/** @type {Record<String, any>} */
		this.data = {};
		if (mediaQueries) for (let mq in mediaQueries) {
			const _mq = win.matchMedia(mediaQueries[mq]);
			this.mediaQueryLists[mq] = _mq;
			_mq.addEventListener("change", this);
		}
	}
	/**
	* @param {Revertible} revertible
	*/
	register(revertible) {
		(this.once ? this.revertiblesOnce : this.revertibles).push(revertible);
	}
	/**
	* @template T
	* @param {ScopedCallback<T>} cb
	* @return {T}
	*/
	execute(cb) {
		let activeScope = scope.current;
		let activeRoot = scope.root;
		let activeDefaults = globals.defaults;
		scope.current = this;
		scope.root = this.root;
		globals.defaults = this.defaults;
		const mqs = this.mediaQueryLists;
		for (let mq in mqs) this.matches[mq] = mqs[mq].matches;
		const returned = cb(this);
		scope.current = activeScope;
		scope.root = activeRoot;
		globals.defaults = activeDefaults;
		return returned;
	}
	/**
	* @return {this}
	*/
	refresh() {
		this.onceIndex = 0;
		this.execute(() => {
			let i = this.revertibles.length;
			let y = this.revertConstructors.length;
			while (i--) this.revertibles[i].revert();
			while (y--) this.revertConstructors[y](this);
			this.revertibles.length = 0;
			this.revertConstructors.length = 0;
			this.constructors.forEach((constructor) => {
				const revertConstructor = constructor(this);
				if (isFnc(revertConstructor)) this.revertConstructors.push(revertConstructor);
			});
		});
		return this;
	}
	/**
	* @overload
	* @param {String} a1
	* @param {ScopeMethod} a2
	* @return {this}
	*
	* @overload
	* @param {ScopeConstructorCallback} a1
	* @return {this}
	*
	* @param {String|ScopeConstructorCallback} a1
	* @param {ScopeMethod} [a2]
	*/
	add(a1, a2) {
		this.once = false;
		if (isFnc(a1)) {
			const constructor = a1;
			this.constructors.push(constructor);
			this.execute(() => {
				const revertConstructor = constructor(this);
				if (isFnc(revertConstructor)) this.revertConstructors.push(revertConstructor);
			});
		} else this.methods[a1] = (...args) => this.execute(() => a2(...args));
		return this;
	}
	/**
	* @param {ScopeConstructorCallback} scopeConstructorCallback
	* @return {this}
	*/
	addOnce(scopeConstructorCallback) {
		this.once = true;
		if (isFnc(scopeConstructorCallback)) {
			const currentIndex = this.onceIndex++;
			if (this.constructorsOnce[currentIndex]) return this;
			const constructor = scopeConstructorCallback;
			this.constructorsOnce[currentIndex] = constructor;
			this.execute(() => {
				const revertConstructor = constructor(this);
				if (isFnc(revertConstructor)) this.revertConstructorsOnce.push(revertConstructor);
			});
		}
		return this;
	}
	/**
	* @param  {(scope: this) => Tickable} cb
	* @return {Tickable}
	*/
	keepTime(cb) {
		this.once = true;
		const currentIndex = this.onceIndex++;
		const tracked = this.constructorsOnce[currentIndex];
		if (isFnc(tracked)) return tracked(this);
		const constructor = keepTime(cb);
		this.constructorsOnce[currentIndex] = constructor;
		let trackedTickable;
		this.execute(() => {
			trackedTickable = constructor(this);
		});
		return trackedTickable;
	}
	/**
	* @param {Event} e
	*/
	handleEvent(e) {
		switch (e.type) {
			case "change":
				this.refresh();
				break;
		}
	}
	revert() {
		const revertibles = this.revertibles;
		const revertConstructors = this.revertConstructors;
		const revertiblesOnce = this.revertiblesOnce;
		const revertConstructorsOnce = this.revertConstructorsOnce;
		const mqs = this.mediaQueryLists;
		let i = revertibles.length;
		let j = revertConstructors.length;
		let k = revertiblesOnce.length;
		let l = revertConstructorsOnce.length;
		while (i--) revertibles[i].revert();
		while (j--) revertConstructors[j](this);
		while (k--) revertiblesOnce[k].revert();
		while (l--) revertConstructorsOnce[l](this);
		for (let mq in mqs) mqs[mq].removeEventListener("change", this);
		revertibles.length = 0;
		revertConstructors.length = 0;
		this.constructors.length = 0;
		revertiblesOnce.length = 0;
		revertConstructorsOnce.length = 0;
		this.constructorsOnce.length = 0;
		this.onceIndex = 0;
		this.matches = {};
		this.methods = {};
		this.mediaQueryLists = {};
		this.data = {};
	}
};
/**
* @param {ScopeParams} [params]
* @return {Scope}
*/
var createScope = (params) => new Scope(params);

//#endregion
//#region node_modules/animejs/dist/modules/events/scroll.js
/**
* Anime.js - events - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
*   EasingFunction,
*   Callback,
*   EasingParam,
*   ScrollThresholdValue,
*   ScrollObserverParams,
*   Tickable,
*   ScrollThresholdParam,
*   ScrollThresholdCallback,
* } from '../types/index.js'
*/
/**
* @import {
*   JSAnimation,
* } from '../animation/animation.js'
*/
/**
* @import {
*   WAAPIAnimation,
* } from '../waapi/waapi.js'
*/
/**
* @import {
*   Timeline,
* } from '../timeline/timeline.js'
*/
/**
* @return {Number}
*/
var getMaxViewHeight = () => {
	const $el = doc.createElement("div");
	doc.body.appendChild($el);
	$el.style.height = "100lvh";
	const height = $el.offsetHeight;
	doc.body.removeChild($el);
	return height;
};
/**
* @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T
* @param {T | ((observer: ScrollObserver) => T)} value
* @param {ScrollObserver} scroller
* @return {T}
*/
var parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? value(scroller) : value;
var scrollContainers = /* @__PURE__ */ new Map();
var ScrollContainer = class {
	/**
	* @param {HTMLElement} $el
	*/
	constructor($el) {
		/** @type {HTMLElement} */
		this.element = $el;
		/** @type {Boolean} */
		this.useWin = this.element === doc.body;
		/** @type {Number} */
		this.winWidth = 0;
		/** @type {Number} */
		this.winHeight = 0;
		/** @type {Number} */
		this.width = 0;
		/** @type {Number} */
		this.height = 0;
		/** @type {Number} */
		this.left = 0;
		/** @type {Number} */
		this.top = 0;
		/** @type {Number} */
		this.scale = 1;
		/** @type {Number} */
		this.zIndex = 0;
		/** @type {Number} */
		this.scrollX = 0;
		/** @type {Number} */
		this.scrollY = 0;
		/** @type {Number} */
		this.prevScrollX = 0;
		/** @type {Number} */
		this.prevScrollY = 0;
		/** @type {Number} */
		this.scrollWidth = 0;
		/** @type {Number} */
		this.scrollHeight = 0;
		/** @type {Number} */
		this.velocity = 0;
		/** @type {Boolean} */
		this.backwardX = false;
		/** @type {Boolean} */
		this.backwardY = false;
		/** @type {Timer} */
		this.scrollTicker = new Timer({
			autoplay: false,
			onBegin: () => this.dataTimer.resume(),
			onUpdate: () => {
				const backwards = this.backwardX || this.backwardY;
				forEachChildren(this, (child) => child.handleScroll(), backwards);
			},
			onComplete: () => this.dataTimer.pause()
		}).init();
		/** @type {Timer} */
		this.dataTimer = new Timer({
			autoplay: false,
			frameRate: 30,
			onUpdate: (self) => {
				const dt = self.deltaTime;
				const px = this.prevScrollX;
				const py = this.prevScrollY;
				const nx = this.scrollX;
				const ny = this.scrollY;
				const dx = px - nx;
				const dy = py - ny;
				this.prevScrollX = nx;
				this.prevScrollY = ny;
				if (dx) this.backwardX = px > nx;
				if (dy) this.backwardY = py > ny;
				this.velocity = round$1(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);
			}
		}).init();
		/** @type {Timer} */
		this.resizeTicker = new Timer({
			autoplay: false,
			duration: 250 * globals.timeScale,
			onComplete: () => {
				this.updateWindowBounds();
				this.refreshScrollObservers();
				this.handleScroll();
			}
		}).init();
		/** @type {Timer} */
		this.wakeTicker = new Timer({
			autoplay: false,
			duration: 500 * globals.timeScale,
			onBegin: () => {
				this.scrollTicker.resume();
			},
			onComplete: () => {
				this.scrollTicker.pause();
			}
		}).init();
		/** @type {ScrollObserver} */
		this._head = null;
		/** @type {ScrollObserver} */
		this._tail = null;
		this.updateScrollCoords();
		this.updateWindowBounds();
		this.updateBounds();
		this.refreshScrollObservers();
		this.handleScroll();
		this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());
		this.resizeObserver.observe(this.element);
		(this.useWin ? win : this.element).addEventListener("scroll", this, false);
	}
	updateScrollCoords() {
		const useWin = this.useWin;
		const $el = this.element;
		this.scrollX = round$1(useWin ? win.scrollX : $el.scrollLeft, 0);
		this.scrollY = round$1(useWin ? win.scrollY : $el.scrollTop, 0);
	}
	updateWindowBounds() {
		this.winWidth = win.innerWidth;
		this.winHeight = getMaxViewHeight();
	}
	updateBounds() {
		const style = getComputedStyle(this.element);
		const $el = this.element;
		this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
		this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
		this.updateWindowBounds();
		let width, height;
		if (this.useWin) {
			width = this.winWidth;
			height = this.winHeight;
		} else {
			const elRect = $el.getBoundingClientRect();
			width = $el.clientWidth;
			height = $el.clientHeight;
			this.top = elRect.top;
			this.left = elRect.left;
			this.scale = elRect.width ? width / elRect.width : elRect.height ? height / elRect.height : 1;
		}
		this.width = width;
		this.height = height;
	}
	refreshScrollObservers() {
		forEachChildren(this, (child) => {
			if (child._debug) child.removeDebug();
		});
		this.updateBounds();
		forEachChildren(this, (child) => {
			child.refresh();
			if (child._debug) child.debug();
		});
	}
	refresh() {
		this.updateWindowBounds();
		this.updateBounds();
		this.refreshScrollObservers();
		this.handleScroll();
	}
	handleScroll() {
		this.updateScrollCoords();
		this.wakeTicker.restart();
	}
	/**
	* @param {Event} e
	*/
	handleEvent(e) {
		switch (e.type) {
			case "scroll":
				this.handleScroll();
				break;
		}
	}
	revert() {
		this.scrollTicker.cancel();
		this.dataTimer.cancel();
		this.resizeTicker.cancel();
		this.wakeTicker.cancel();
		this.resizeObserver.disconnect();
		(this.useWin ? win : this.element).removeEventListener("scroll", this);
		scrollContainers.delete(this.element);
	}
};
/**
* @param {TargetsParam} target
* @return {ScrollContainer}
*/
var registerAndGetScrollContainer = (target) => {
	const $el = target ? parseTargets(target)[0] || doc.body : doc.body;
	let scrollContainer = scrollContainers.get($el);
	if (!scrollContainer) {
		scrollContainer = new ScrollContainer($el);
		scrollContainers.set($el, scrollContainer);
	}
	return scrollContainer;
};
/**
* @param {HTMLElement} $el
* @param {Number|string} v
* @param {Number} size
* @param {Number} [under]
* @param {Number} [over]
* @return {Number}
*/
var convertValueToPx = ($el, v, size, under, over) => {
	const clampMin = v === "min";
	const clampMax = v === "max";
	const { n, u } = decomposeRawValue(v === "top" || v === "left" || v === "start" || clampMin ? 0 : v === "bottom" || v === "right" || v === "end" || clampMax ? "100%" : v === "center" ? "50%" : v, decomposedOriginalValue);
	let px = n;
	if (u === "%") px = n / 100 * size;
	else if (u) px = convertValueUnit($el, decomposedOriginalValue, "px", true).n;
	if (clampMax && under < 0) px += under;
	if (clampMin && over > 0) px += over;
	return px;
};
/**
* @param {HTMLElement} $el
* @param {ScrollThresholdValue} v
* @param {Number} size
* @param {Number} [under]
* @param {Number} [over]
* @return {Number}
*/
var parseBoundValue = ($el, v, size, under, over) => {
	/** @type {Number} */
	let value;
	if (isStr(v)) {
		const matchedOperator = relativeValuesExecRgx.exec(v);
		if (matchedOperator) {
			const splitter = matchedOperator[0];
			const operator = splitter[0];
			const splitted = v.split(splitter);
			const clampMin = splitted[0] === "min";
			const clampMax = splitted[0] === "max";
			const valueAPx = convertValueToPx($el, splitted[0], size, under, over);
			const valueBPx = convertValueToPx($el, splitted[1], size, under, over);
			if (clampMin) {
				const min = getRelativeValue(convertValueToPx($el, "min", size), valueBPx, operator);
				value = min < valueAPx ? valueAPx : min;
			} else if (clampMax) {
				const max$1 = getRelativeValue(convertValueToPx($el, "max", size), valueBPx, operator);
				value = max$1 > valueAPx ? valueAPx : max$1;
			} else value = getRelativeValue(valueAPx, valueBPx, operator);
		} else value = convertValueToPx($el, v, size, under, over);
	} else value = v;
	return round$1(value, 0);
};
/**
* @param {JSAnimation} linked
* @return {HTMLElement}
*/
var getAnimationDomTarget = (linked) => {
	let $linkedTarget;
	const linkedTargets = linked.targets;
	for (let i = 0, l = linkedTargets.length; i < l; i++) {
		const target = linkedTargets[i];
		if (target[isDomSymbol]) {
			$linkedTarget = target;
			break;
		}
	}
	return $linkedTarget;
};
var scrollerIndex = 0;
var debugColors$1 = [
	"#FF4B4B",
	"#FF971B",
	"#FFC730",
	"#F9F640",
	"#7AFF5A",
	"#18FF74",
	"#17E09B",
	"#3CFFEC",
	"#05DBE9",
	"#33B3F1",
	"#638CF9",
	"#C563FE",
	"#FF4FCF",
	"#F93F8A"
];
var ScrollObserver = class {
	/**
	* @param {ScrollObserverParams} parameters
	*/
	constructor(parameters = {}) {
		if (scope.current) scope.current.register(this);
		const syncMode = setValue(parameters.sync, "play pause");
		const ease = syncMode ? parseEase(syncMode) : null;
		const isLinear = syncMode && (syncMode === "linear" || syncMode === none);
		const isEase = syncMode && !(ease === none && !isLinear);
		const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);
		const isMethods = syncMode && isStr(syncMode) && !isEase && !isSmooth;
		const syncMethods = isMethods ? syncMode.split(" ").map((m) => () => {
			const linked = this.linked;
			return linked && linked[m] ? linked[m]() : null;
		}) : null;
		const biDirSync = isMethods && syncMethods.length > 2;
		/** @type {Number} */
		this.index = scrollerIndex++;
		/** @type {String|Number} */
		this.id = !isUnd(parameters.id) ? parameters.id : this.index;
		/** @type {ScrollContainer} */
		this.container = registerAndGetScrollContainer(parameters.container);
		/** @type {HTMLElement} */
		this.target = null;
		/** @type {Tickable|WAAPIAnimation} */
		this.linked = null;
		/** @type {Boolean} */
		this.repeat = null;
		/** @type {Boolean} */
		this.horizontal = null;
		/** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
		this.enter = null;
		/** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
		this.leave = null;
		/** @type {Boolean} */
		this.sync = isEase || isSmooth || !!syncMethods;
		/** @type {EasingFunction} */
		this.syncEase = isEase ? ease : null;
		/** @type {Number} */
		this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : syncMode : null;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;
		/** @type {Callback<ScrollObserver>} */
		this.onEnter = parameters.onEnter || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onLeave = parameters.onLeave || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onEnterForward = parameters.onEnterForward || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onLeaveForward = parameters.onLeaveForward || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onEnterBackward = parameters.onEnterBackward || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onLeaveBackward = parameters.onLeaveBackward || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onUpdate = parameters.onUpdate || noop;
		/** @type {Callback<ScrollObserver>} */
		this.onSyncComplete = parameters.onSyncComplete || noop;
		/** @type {Boolean} */
		this.reverted = false;
		/** @type {Boolean} */
		this.ready = false;
		/** @type {Boolean} */
		this.completed = false;
		/** @type {Boolean} */
		this.began = false;
		/** @type {Boolean} */
		this.isInView = false;
		/** @type {Boolean} */
		this.forceEnter = false;
		/** @type {Boolean} */
		this.hasEntered = false;
		/** @type {Number} */
		this.offset = 0;
		/** @type {Number} */
		this.offsetStart = 0;
		/** @type {Number} */
		this.offsetEnd = 0;
		/** @type {Number} */
		this.distance = 0;
		/** @type {Number} */
		this.prevProgress = 0;
		/** @type {Array} */
		this.thresholds = [
			"start",
			"end",
			"end",
			"start"
		];
		/** @type {[Number, Number, Number, Number]} */
		this.coords = [
			0,
			0,
			0,
			0
		];
		/** @type {JSAnimation} */
		this.debugStyles = null;
		/** @type {HTMLElement} */
		this.$debug = null;
		/** @type {ScrollObserverParams} */
		this._params = parameters;
		/** @type {Boolean} */
		this._debug = setValue(parameters.debug, false);
		/** @type {ScrollObserver} */
		this._next = null;
		/** @type {ScrollObserver} */
		this._prev = null;
		addChild(this.container, this);
		sync(() => {
			if (this.reverted) return;
			if (!this.target) {
				this.target = parseTargets(parameters.target)[0] || doc.body;
				this.refresh();
			}
			if (this._debug) this.debug();
		});
	}
	/**
	* @param {Tickable|WAAPIAnimation} linked
	*/
	link(linked) {
		if (linked) {
			linked.pause();
			this.linked = linked;
			if (!isUnd(linked)) /** @type {WAAPIAnimation} */ linked.persist = true;
			if (!this._params.target) {
				/** @type {HTMLElement} */
				let $linkedTarget;
				if (!isUnd(
					/** @type {JSAnimation} */
					linked.targets
				)) $linkedTarget = getAnimationDomTarget(linked);
				else forEachChildren(linked, (child) => {
					if (child.targets && !$linkedTarget) $linkedTarget = getAnimationDomTarget(child);
				});
				this.target = $linkedTarget || doc.body;
				this.refresh();
			}
		}
		return this;
	}
	get velocity() {
		return this.container.velocity;
	}
	get backward() {
		return this.horizontal ? this.container.backwardX : this.container.backwardY;
	}
	get scroll() {
		return this.horizontal ? this.container.scrollX : this.container.scrollY;
	}
	get progress() {
		const p = (this.scroll - this.offsetStart) / this.distance;
		return p === Infinity || isNaN(p) ? 0 : round$1(clamp$1(p, 0, 1), 6);
	}
	refresh() {
		this.ready = true;
		this.reverted = false;
		const params = this._params;
		this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);
		this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), "y") === "x";
		this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), "end start");
		this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), "start end");
		this.updateBounds();
		this.handleScroll();
		return this;
	}
	removeDebug() {
		if (this.$debug) {
			this.$debug.parentNode.removeChild(this.$debug);
			this.$debug = null;
		}
		if (this.debugStyles) {
			this.debugStyles.revert();
			this.$debug = null;
		}
		return this;
	}
	debug() {
		this.removeDebug();
		const container = this.container;
		const isHori = this.horizontal;
		const $existingDebug = container.element.querySelector(":scope > .animejs-onscroll-debug");
		const $debug = doc.createElement("div");
		const $thresholds = doc.createElement("div");
		const $triggers = doc.createElement("div");
		const color = debugColors$1[this.index % debugColors$1.length];
		const useWin = container.useWin;
		const containerWidth = useWin ? container.winWidth : container.width;
		const containerHeight = useWin ? container.winHeight : container.height;
		const scrollWidth = container.scrollWidth;
		const scrollHeight = container.scrollHeight;
		const size = this.container.width > 360 ? 320 : 260;
		const offLeft = isHori ? 0 : 10;
		const offTop = isHori ? 10 : 0;
		const half = isHori ? 24 : size / 2;
		const labelHeight = isHori ? half : 15;
		const labelWidth = isHori ? 60 : half;
		const labelSize = isHori ? labelWidth : labelHeight;
		const repeat = isHori ? "repeat-x" : "repeat-y";
		/**
		* @param {Number} v
		* @return {String}
		*/
		const gradientOffset = (v) => isHori ? "0px " + v + "px" : v + "px 2px";
		/**
		* @param {String} c
		* @return {String}
		*/
		const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;
		/**
		* @param {String} p
		* @param {Number} l
		* @param {Number} t
		* @param {Number} w
		* @param {Number} h
		* @return {String}
		*/
		const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;
		$debug.style.cssText = `${baseCSS("absolute", offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${isHori ? "column" : "row"};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `;
		$thresholds.style.cssText = `${baseCSS("sticky", 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;
		if (!$existingDebug) $thresholds.style.cssText += `background:
        ${lineCSS("#FFFF")}${gradientOffset(half - 10)} / ${isHori ? "100px 100px" : "100px 100px"} ${repeat},
        ${lineCSS("#FFF8")}${gradientOffset(half - 10)} / ${isHori ? "10px 10px" : "10px 10px"} ${repeat};
      `;
		$triggers.style.cssText = `${baseCSS("relative", 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;
		if (!$existingDebug) $triggers.style.cssText += `background:
        ${lineCSS("#FFFF")}${gradientOffset(0)} / ${isHori ? "100px 10px" : "10px 100px"} ${repeat},
        ${lineCSS("#FFF8")}${gradientOffset(0)} / ${isHori ? "10px 0px" : "0px 10px"} ${repeat};
      `;
		const labels = [" enter: ", " leave: "];
		this.coords.forEach((v, i) => {
			const isView = i > 1;
			const value = (isView ? 0 : this.offset) + v;
			const isTail = i % 2;
			const isFirst = value < labelSize;
			const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;
			const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;
			const $label = doc.createElement("div");
			const $text = doc.createElement("div");
			const dirProp = isHori ? isFlip ? "right" : "left" : isFlip ? "bottom" : "top";
			const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;
			$text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;
			$label.style.cssText = `${baseCSS("absolute", 0, 0, labelWidth, labelHeight)}
        display: flex;
        flex-direction: ${isHori ? "column" : "row"};
        justify-content: flex-${isView ? "start" : "end"};
        align-items: flex-${isFlip ? "end" : "start"};
        border-${dirProp}: 2px ${isTail ? "solid" : "solid"} ${color};
      `;
			$text.style.cssText = `
        overflow: hidden;
        max-width: ${size / 2 - 10}px;
        height: ${labelHeight};
        margin-${isHori ? isFlip ? "right" : "left" : isFlip ? "bottom" : "top"}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${isHori && isFlip || !isHori && !isView ? "right" : "left"};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${isTail ? color : "rgba(0,0,0,.75)"};
        background-color: ${isTail ? "rgba(0,0,0,.65)" : color};
        border: 2px solid ${isTail ? color : "transparent"};
        border-${isHori ? isFlip ? "top-left" : "top-right" : isFlip ? "top-left" : "bottom-left"}-radius: 5px;
        border-${isHori ? isFlip ? "bottom-left" : "bottom-right" : isFlip ? "top-right" : "bottom-right"}-radius: 5px;
      `;
			$label.appendChild($text);
			let position = value - flipOffset + (isHori ? 1 : 0);
			$label.style[isHori ? "left" : "top"] = `${position}px`;
			(isView ? $thresholds : $triggers).appendChild($label);
		});
		$debug.appendChild($thresholds);
		$debug.appendChild($triggers);
		container.element.appendChild($debug);
		if (!$existingDebug) $debug.classList.add("animejs-onscroll-debug");
		this.$debug = $debug;
		if (get(container.element, "position") === "static") this.debugStyles = set(container.element, { position: "relative " });
	}
	updateBounds() {
		if (this._debug) this.removeDebug();
		let stickys;
		const $target = this.target;
		const container = this.container;
		const isHori = this.horizontal;
		const linked = this.linked;
		let linkedTime;
		let $el = $target;
		/** @type {Element} */
		if (linked) {
			linkedTime = linked.currentTime;
			linked.seek(0, true);
		}
		$el.parentElement;
		while ($el && $el !== container.element && $el !== doc.body) {
			const isSticky = get($el, "position") === "sticky" ? set($el, { position: "static" }) : false;
			$el = $el.parentElement;
			if (isSticky) {
				if (!stickys) stickys = [];
				stickys.push(isSticky);
			}
		}
		const rect = $target.getBoundingClientRect();
		const scale = container.scale;
		const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;
		const targetSize = (isHori ? rect.width : rect.height) * scale;
		const containerSize = isHori ? container.width : container.height;
		const maxScroll = (isHori ? container.scrollWidth : container.scrollHeight) - containerSize;
		const enter = this.enter;
		const leave = this.leave;
		/** @type {ScrollThresholdValue} */
		let enterTarget = "start";
		/** @type {ScrollThresholdValue} */
		let leaveTarget = "end";
		/** @type {ScrollThresholdValue} */
		let enterContainer = "end";
		/** @type {ScrollThresholdValue} */
		let leaveContainer = "start";
		if (isStr(enter)) {
			const splitted = enter.split(" ");
			enterContainer = splitted[0];
			enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;
		} else if (isObj(enter)) {
			const e = enter;
			if (!isUnd(e.container)) enterContainer = e.container;
			if (!isUnd(e.target)) enterTarget = e.target;
		} else if (isNum(enter)) enterContainer = enter;
		if (isStr(leave)) {
			const splitted = leave.split(" ");
			leaveContainer = splitted[0];
			leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;
		} else if (isObj(leave)) {
			const t = leave;
			if (!isUnd(t.container)) leaveContainer = t.container;
			if (!isUnd(t.target)) leaveTarget = t.target;
		} else if (isNum(leave)) leaveContainer = leave;
		const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);
		const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);
		const under = parsedEnterTarget + offset - containerSize;
		const over = parsedLeaveTarget + offset - maxScroll;
		const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);
		const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);
		const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;
		const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;
		const scrollDelta = offsetEnd - offsetStart;
		this.offset = offset;
		this.offsetStart = offsetStart;
		this.offsetEnd = offsetEnd;
		this.distance = scrollDelta <= 0 ? 0 : scrollDelta;
		this.thresholds = [
			enterTarget,
			leaveTarget,
			enterContainer,
			leaveContainer
		];
		this.coords = [
			parsedEnterTarget,
			parsedLeaveTarget,
			parsedEnterContainer,
			parsedLeaveContainer
		];
		if (stickys) stickys.forEach((sticky) => sticky.revert());
		if (linked) linked.seek(linkedTime, true);
		if (this._debug) this.debug();
	}
	handleScroll() {
		if (!this.ready) return;
		const linked = this.linked;
		const sync$1 = this.sync;
		const syncEase = this.syncEase;
		const syncSmooth = this.syncSmooth;
		const shouldSeek = linked && (syncEase || syncSmooth);
		const isHori = this.horizontal;
		const container = this.container;
		const scroll = this.scroll;
		const isBefore = scroll <= this.offsetStart;
		const isAfter = scroll >= this.offsetEnd;
		const isInView = !isBefore && !isAfter;
		const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;
		const forceEnter = !this.hasEntered && isOnTheEdge;
		const $debug = this._debug && this.$debug;
		let hasUpdated = false;
		let syncCompleted = false;
		let p = this.progress;
		if (isBefore && this.began) this.began = false;
		if (p > 0 && !this.began) this.began = true;
		if (shouldSeek) {
			const lp = linked.progress;
			if (syncSmooth && isNum(syncSmooth)) {
				if (syncSmooth < 1) {
					const step = 1e-4;
					const snap$1 = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;
					p = round$1(lerp$1(lp, p, lerp$1(.01, .2, syncSmooth)) + snap$1, 6);
				}
			} else if (syncEase) p = syncEase(p);
			hasUpdated = p !== this.prevProgress;
			syncCompleted = lp === 1;
			if (hasUpdated && !syncCompleted && syncSmooth && lp) container.wakeTicker.restart();
		}
		if ($debug) {
			const sticky = isHori ? container.scrollY : container.scrollX;
			$debug.style[isHori ? "top" : "left"] = sticky + 10 + "px";
		}
		if (isInView && !this.isInView || forceEnter && !this.forceEnter && !this.hasEntered) {
			if (isInView) this.isInView = true;
			if (!this.forceEnter || !this.hasEntered) {
				if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;
				this.onSyncEnter(this);
				this.onEnter(this);
				if (this.backward) {
					this.onSyncEnterBackward(this);
					this.onEnterBackward(this);
				} else {
					this.onSyncEnterForward(this);
					this.onEnterForward(this);
				}
				this.hasEntered = true;
				if (forceEnter) this.forceEnter = true;
			} else if (isInView) this.forceEnter = false;
		}
		if (isInView || !isInView && this.isInView) hasUpdated = true;
		if (hasUpdated) {
			if (shouldSeek) linked.seek(linked.duration * p);
			this.onUpdate(this);
		}
		if (!isInView && this.isInView) {
			this.isInView = false;
			this.onSyncLeave(this);
			this.onLeave(this);
			if (this.backward) {
				this.onSyncLeaveBackward(this);
				this.onLeaveBackward(this);
			} else {
				this.onSyncLeaveForward(this);
				this.onLeaveForward(this);
			}
			if (sync$1 && !syncSmooth) syncCompleted = true;
		}
		if (p >= 1 && this.began && !this.completed && (sync$1 && syncCompleted || !sync$1)) {
			if (sync$1) this.onSyncComplete(this);
			this.completed = true;
			if (!this.repeat && !linked || !this.repeat && linked && linked.completed) this.revert();
		}
		if (p < 1 && this.completed) this.completed = false;
		this.prevProgress = p;
	}
	revert() {
		if (this.reverted) return;
		const container = this.container;
		removeChild(container, this);
		if (!container._head) container.revert();
		if (this._debug) this.removeDebug();
		this.reverted = true;
		this.ready = false;
		return this;
	}
};
/**
* @param {ScrollObserverParams} [parameters={}]
* @return {ScrollObserver}
*/
var onScroll = (parameters = {}) => new ScrollObserver(parameters);

//#endregion
//#region node_modules/animejs/dist/modules/easings/cubic-bezier/index.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
* } from '../../types/index.js'
*/
/**
* Cubic Bezier solver adapted from https://github.com/gre/bezier-easing
* (c) 2014 GaÃ«tan Renaudeau
*/
/**
* @param  {Number} aT
* @param  {Number} aA1
* @param  {Number} aA2
* @return {Number}
*/
var calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;
/**
* @param  {Number} aX
* @param  {Number} mX1
* @param  {Number} mX2
* @return {Number}
*/
var binarySubdivide = (aX, mX1, mX2) => {
	let aA = 0, aB = 1, currentX, currentT, i = 0;
	do {
		currentT = aA + (aB - aA) / 2;
		currentX = calcBezier(currentT, mX1, mX2) - aX;
		if (currentX > 0) aB = currentT;
		else aA = currentT;
	} while (abs(currentX) > 1e-7 && ++i < 100);
	return currentT;
};
/**
* @param  {Number} [mX1] The x coordinate of the first point
* @param  {Number} [mY1] The y coordinate of the first point
* @param  {Number} [mX2] The x coordinate of the second point
* @param  {Number} [mY2] The y coordinate of the second point
* @return {EasingFunction}
*/
var cubicBezier = (mX1 = .5, mY1 = 0, mX2 = .5, mY2 = 1) => mX1 === mY1 && mX2 === mY2 ? none : (t) => t === 0 || t === 1 ? t : calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);

//#endregion
//#region node_modules/animejs/dist/modules/easings/steps/index.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
* } from '../../types/index.js'
*/
/**
* Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
* Only covers 'end' and 'start' jumpterms
* @param  {Number} steps
* @param  {Boolean} [fromStart]
* @return {EasingFunction}
*/
var steps = (steps$1 = 10, fromStart) => {
	const roundMethod = fromStart ? ceil : floor;
	return (t) => roundMethod(clamp$1(t, 0, 1) * steps$1) * (1 / steps$1);
};

//#endregion
//#region node_modules/animejs/dist/modules/easings/linear/index.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
* } from '../../types/index.js'
*/
/**
* Without parameters, the linear function creates a non-eased transition.
* Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.
*
* @param  {...(String|Number)} args - Points
* @return {EasingFunction}
*/
var linear = (...args) => {
	const argsLength = args.length;
	if (!argsLength) return none;
	const totalPoints = argsLength - 1;
	const firstArg = args[0];
	const lastArg = args[totalPoints];
	const xPoints = [0];
	const yPoints = [parseNumber(firstArg)];
	for (let i = 1; i < totalPoints; i++) {
		const arg = args[i];
		const splitValue = isStr(arg) ? arg.trim().split(" ") : [arg];
		const value = splitValue[0];
		const percent = splitValue[1];
		xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
		yPoints.push(parseNumber(value));
	}
	yPoints.push(parseNumber(lastArg));
	xPoints.push(1);
	return function easeLinear(t) {
		for (let i = 1, l = xPoints.length; i < l; i++) {
			const currentX = xPoints[i];
			if (t <= currentX) {
				const prevX = xPoints[i - 1];
				const prevY = yPoints[i - 1];
				return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
			}
		}
		return yPoints[yPoints.length - 1];
	};
};

//#endregion
//#region node_modules/animejs/dist/modules/easings/irregular/index.js
/**
* Anime.js - easings - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   EasingFunction,
* } from '../../types/index.js'
*/
/**
* Generate random steps
* @param  {Number} [length] - The number of steps
* @param  {Number} [randomness] - How strong the randomness is
* @return {EasingFunction}
*/
var irregular = (length = 10, randomness = 1) => {
	const values = [0];
	const total = length - 1;
	for (let i = 1; i < total; i++) {
		const previousValue = values[i - 1];
		const spacing = i / total;
		const randomVariation = spacing + ((i + 1) / total - spacing) * Math.random();
		const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
		values.push(clamp$1(randomValue, previousValue, 1));
	}
	values.push(1);
	return linear(...values);
};

//#endregion
//#region node_modules/animejs/dist/modules/easings/index.js
var easings_exports = /* @__PURE__ */ __export({
	Spring: () => Spring,
	createSpring: () => createSpring,
	cubicBezier: () => cubicBezier,
	eases: () => eases,
	irregular: () => irregular,
	linear: () => linear,
	spring: () => spring,
	steps: () => steps
});

//#endregion
//#region node_modules/animejs/dist/modules/utils/chainable.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
var numberUtils = number_exports;
var chainables = {};
/**
* @callback UtilityFunction
* @param {...*} args
* @return {Number|String}
*
* @param {UtilityFunction} fn
* @param {Number} [last=0]
* @return {function(...(Number|String)): function(Number|String): (Number|String)}
*/
var curry = (fn, last = 0) => (...args) => last ? (v) => fn(...args, v) : (v) => fn(v, ...args);
/**
* @param {Function} fn
* @return {function(...(Number|String))}
*/
var chain = (fn) => {
	return (...args) => {
		const result = fn(...args);
		return new Proxy(noop, {
			apply: (_, __, [v]) => result(v),
			get: (_, prop) => chain(
				/**@param {...Number|String} nextArgs */
				(...nextArgs) => {
					const nextResult = chainables[prop](...nextArgs);
					return (v) => nextResult(result(v));
				}
			)
		});
	};
};
/**
* @param {UtilityFunction} fn
* @param {String} name
* @param {Number} [right]
* @return {function(...(Number|String)): UtilityFunction}
*/
var makeChainable = (name, fn, right = 0) => {
	const chained = (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
	if (!chainables[name]) chainables[name] = chained;
	return chained;
};
/**
* @typedef {Object} ChainablesMap
* @property {ChainedClamp} clamp
* @property {ChainedRound} round
* @property {ChainedSnap} snap
* @property {ChainedWrap} wrap
* @property {ChainedLerp} lerp
* @property {ChainedDamp} damp
* @property {ChainedMapRange} mapRange
* @property {ChainedRoundPad} roundPad
* @property {ChainedPadStart} padStart
* @property {ChainedPadEnd} padEnd
* @property {ChainedDegToRad} degToRad
* @property {ChainedRadToDeg} radToDeg
*/
/**
* @callback ChainedUtilsResult
* @param {Number} value - The value to process through the chained operations
* @return {Number} The processed result
*/
/**
* @typedef {ChainablesMap & ChainedUtilsResult} ChainableUtil
*/
/**
* @callback ChainedRoundPad
* @param {Number} decimalLength - Number of decimal places
* @return {ChainableUtil}
*/
var roundPad = makeChainable("roundPad", numberUtils.roundPad);
/**
* @callback ChainedPadStart
* @param {Number} totalLength - Target length
* @param {String} padString - String to pad with
* @return {ChainableUtil}
*/
var padStart = makeChainable("padStart", numberUtils.padStart);
/**
* @callback ChainedPadEnd
* @param {Number} totalLength - Target length
* @param {String} padString - String to pad with
* @return {ChainableUtil}
*/
var padEnd = makeChainable("padEnd", numberUtils.padEnd);
/**
* @callback ChainedWrap
* @param {Number} min - Minimum boundary
* @param {Number} max - Maximum boundary
* @return {ChainableUtil}
*/
var wrap = makeChainable("wrap", numberUtils.wrap);
/**
* @callback ChainedMapRange
* @param {Number} inLow - Input range minimum
* @param {Number} inHigh - Input range maximum
* @param {Number} outLow - Output range minimum
* @param {Number} outHigh - Output range maximum
* @return {ChainableUtil}
*/
var mapRange = makeChainable("mapRange", numberUtils.mapRange);
/**
* @callback ChainedDegToRad
* @return {ChainableUtil}
*/
var degToRad = makeChainable("degToRad", numberUtils.degToRad);
/**
* @callback ChainedRadToDeg
* @return {ChainableUtil}
*/
var radToDeg = makeChainable("radToDeg", numberUtils.radToDeg);
/**
* @callback ChainedSnap
* @param {Number|Array<Number>} increment - Step size or array of snap points
* @return {ChainableUtil}
*/
var snap = makeChainable("snap", numberUtils.snap);
/**
* @callback ChainedClamp
* @param {Number} min - Minimum boundary
* @param {Number} max - Maximum boundary
* @return {ChainableUtil}
*/
var clamp = makeChainable("clamp", numberUtils.clamp);
/**
* @callback ChainedRound
* @param {Number} decimalLength - Number of decimal places
* @return {ChainableUtil}
*/
var round = makeChainable("round", numberUtils.round);
/**
* @callback ChainedLerp
* @param {Number} start - Starting value
* @param {Number} end - Ending value
* @return {ChainableUtil}
*/
var lerp = makeChainable("lerp", numberUtils.lerp, 1);
/**
* @callback ChainedDamp
* @param {Number} start - Starting value
* @param {Number} end - Target value
* @param {Number} deltaTime - Delta time in ms
* @return {ChainableUtil}
*/
var damp = makeChainable("damp", numberUtils.damp, 1);

//#endregion
//#region node_modules/animejs/dist/modules/utils/random.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* Generate a random number between optional min and max (inclusive) and decimal precision
*
* @callback RandomNumberGenerator
* @param    {Number} [min=0] - The minimum value (inclusive)
* @param    {Number} [max=1] - The maximum value (inclusive)
* @param    {Number} [decimalLength=0] - Number of decimal places to round to
* @return   {Number} A random number between min and max
*/
/**
* Generates a random number between min and max (inclusive) with optional decimal precision
*
* @type {RandomNumberGenerator}
*/
var random = (min = 0, max$1 = 1, decimalLength = 0) => {
	const m = 10 ** decimalLength;
	return Math.floor((Math.random() * (max$1 - min + 1 / m) + min) * m) / m;
};
var _seed = 0;
/**
* Creates a seeded pseudorandom number generator function
*
* @param  {Number} [seed] - The seed value for the random number generator
* @param  {Number} [seededMin=0] - The minimum default value (inclusive) of the returned function
* @param  {Number} [seededMax=1] - The maximum default value (inclusive) of the returned function
* @param  {Number} [seededDecimalLength=0] - Default number of decimal places to round to of the returned function
* @return {RandomNumberGenerator} A function to generate a random number between optional min and max (inclusive) and decimal precision
*/
var createSeededRandom = (seed, seededMin = 0, seededMax = 1, seededDecimalLength = 0) => {
	let t = seed === void 0 ? _seed++ : seed;
	return (min = seededMin, max$1 = seededMax, decimalLength = seededDecimalLength) => {
		t += 1831565813;
		t = Math.imul(t ^ t >>> 15, t | 1);
		t ^= t + Math.imul(t ^ t >>> 7, t | 61);
		const m = 10 ** decimalLength;
		return Math.floor((((t ^ t >>> 14) >>> 0) / 4294967296 * (max$1 - min + 1 / m) + min) * m) / m;
	};
};
/**
* Picks a random element from an array or a string
*
* @template T
* @param    {String|Array<T>} items - The array or string to pick from
* @return   {String|T} A random element from the array or character from the string
*/
var randomPick = (items) => items[random(0, items.length - 1)];
/**
* Shuffles an array in-place using the Fisher-Yates algorithm
* Adapted from https://bost.ocks.org/mike/shuffle/
*
* @param  {Array} items - The array to shuffle (will be modified in-place)
* @return {Array} The same array reference, now shuffled
*/
var shuffle = (items) => {
	let m = items.length, t, i;
	while (m) {
		i = random(0, --m);
		t = items[m];
		items[m] = items[i];
		items[i] = t;
	}
	return items;
};

//#endregion
//#region node_modules/animejs/dist/modules/utils/stagger.js
/**
* Anime.js - utils - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   StaggerParams,
*   StaggerFunction,
* } from '../types/index.js'
*/
/**
* @import {
*   Spring,
* } from '../easings/spring/index.js'
*/
/**
* @overload
* @param {Number} val
* @param {StaggerParams} [params]
* @return {StaggerFunction<Number>}
*/
/**
* @overload
* @param {String} val
* @param {StaggerParams} [params]
* @return {StaggerFunction<String>}
*/
/**
* @overload
* @param {[Number, Number]} val
* @param {StaggerParams} [params]
* @return {StaggerFunction<Number>}
*/
/**
* @overload
* @param {[String, String]} val
* @param {StaggerParams} [params]
* @return {StaggerFunction<String>}
*/
/**
* @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range
* @param {StaggerParams} [params] The stagger parameters
* @return {StaggerFunction<Number|String>}
*/
var stagger = (val, params = {}) => {
	let values = [];
	let maxValue = 0;
	const from = params.from;
	const reversed = params.reversed;
	const ease = params.ease;
	const hasEasing = !isUnd(ease);
	const staggerEase = hasEasing && !isUnd(
		/** @type {Spring} */
		ease.ease
	) ? ease.ease : hasEasing ? parseEase(ease) : null;
	const grid = params.grid;
	const axis = params.axis;
	const customTotal = params.total;
	const fromFirst = isUnd(from) || from === 0 || from === "first";
	const fromCenter = from === "center";
	const fromLast = from === "last";
	const fromRandom = from === "random";
	const isRange = isArr(val);
	const useProp = params.use;
	const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
	const val2 = isRange ? parseNumber(val[1]) : 0;
	const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
	const start = params.start || 0 + (isRange ? val1 : 0);
	let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
	return (target, i, t, tl) => {
		const [registeredTarget] = registerTargets(target);
		const total = isUnd(customTotal) ? t : customTotal;
		const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;
		const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;
		if (fromCenter) fromIndex = (total - 1) / 2;
		if (fromLast) fromIndex = total - 1;
		if (!values.length) {
			for (let index = 0; index < total; index++) {
				if (!grid) values.push(abs(fromIndex - index));
				else {
					const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
					const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
					const toX = index % grid[0];
					const toY = floor(index / grid[0]);
					const distanceX = fromX - toX;
					const distanceY = fromY - toY;
					let value = sqrt(distanceX * distanceX + distanceY * distanceY);
					if (axis === "x") value = -distanceX;
					if (axis === "y") value = -distanceY;
					values.push(value);
				}
				maxValue = max(...values);
			}
			if (staggerEase) values = values.map((val$1) => staggerEase(val$1 / maxValue) * maxValue);
			if (reversed) values = values.map((val$1) => axis ? val$1 < 0 ? val$1 * -1 : -val$1 : abs(maxValue - val$1));
			if (fromRandom) values = shuffle(values);
		}
		const spacing = isRange ? (val2 - val1) / maxValue : val1;
		/** @type {String|Number} */
		let output = (tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : start) + (spacing * round$1(values[staggerIndex], 2) || 0);
		if (params.modifier) output = params.modifier(output);
		if (unitMatch) output = `${output}${unitMatch[2]}`;
		return output;
	};
};

//#endregion
//#region node_modules/animejs/dist/modules/utils/index.js
var utils_exports = /* @__PURE__ */ __export({
	$: () => registerTargets,
	clamp: () => clamp,
	cleanInlineStyles: () => cleanInlineStyles,
	createSeededRandom: () => createSeededRandom,
	damp: () => damp,
	degToRad: () => degToRad,
	get: () => get,
	keepTime: () => keepTime,
	lerp: () => lerp,
	mapRange: () => mapRange,
	padEnd: () => padEnd,
	padStart: () => padStart,
	radToDeg: () => radToDeg,
	random: () => random,
	randomPick: () => randomPick,
	remove: () => remove,
	round: () => round,
	roundPad: () => roundPad,
	set: () => set,
	shuffle: () => shuffle,
	snap: () => snap,
	stagger: () => stagger,
	sync: () => sync,
	wrap: () => wrap
});

//#endregion
//#region node_modules/animejs/dist/modules/svg/helpers.js
/**
* Anime.js - svg - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
* } from '../types/index.js'
*/
/**
* @param  {TargetsParam} path
* @return {SVGGeometryElement|void}
*/
var getPath = (path) => {
	const $parsedSvg = parseTargets(path)[0];
	if (!$parsedSvg || !isSvg($parsedSvg)) return console.warn(`${path} is not a valid SVGGeometryElement`);
	return $parsedSvg;
};

//#endregion
//#region node_modules/animejs/dist/modules/svg/motionpath.js
/**
* Anime.js - svg - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
*   FunctionValue,
*   TweenObjectValue,
*   TweenModifier,
* } from '../types/index.js'
*/
/**
* @param {SVGGeometryElement} $path
* @param {Number} totalLength
* @param {Number} progress
* @param {Number} lookup
* @param {Boolean} shouldClamp
* @return {DOMPoint}
*/
var getPathPoint = ($path, totalLength, progress, lookup, shouldClamp) => {
	const point = progress + lookup;
	const pointOnPath = shouldClamp ? Math.max(0, Math.min(point, totalLength)) : (point % totalLength + totalLength) % totalLength;
	return $path.getPointAtLength(pointOnPath);
};
/**
* @param {SVGGeometryElement} $path
* @param {String} pathProperty
* @param {Number} [offset=0]
* @return {FunctionValue}
*/
var getPathProgess = ($path, pathProperty, offset = 0) => {
	return ($el) => {
		const totalLength = +$path.getTotalLength();
		const inSvg = $el[isSvgSymbol];
		const ctm = $path.getCTM();
		const shouldClamp = offset === 0;
		/** @type {TweenObjectValue} */
		return {
			from: 0,
			to: totalLength,
			modifier: (progress) => {
				const newProgress = progress + offset * totalLength;
				if (pathProperty === "a") {
					const p0 = getPathPoint($path, totalLength, newProgress, -1, shouldClamp);
					const p1 = getPathPoint($path, totalLength, newProgress, 1, shouldClamp);
					return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
				} else {
					const p = getPathPoint($path, totalLength, newProgress, 0, shouldClamp);
					return pathProperty === "x" ? inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e : inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;
				}
			}
		};
	};
};
/**
* @param {TargetsParam} path
* @param {Number} [offset=0]
*/
var createMotionPath = (path, offset = 0) => {
	const $path = getPath(path);
	if (!$path) return;
	return {
		translateX: getPathProgess($path, "x", offset),
		translateY: getPathProgess($path, "y", offset),
		rotate: getPathProgess($path, "a", offset)
	};
};

//#endregion
//#region node_modules/animejs/dist/modules/svg/drawable.js
/**
* Anime.js - svg - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
*   DrawableSVGGeometry,
* } from '../types/index.js'
*/
/**
* @param {SVGGeometryElement} [$el]
* @return {Number}
*/
var getScaleFactor = ($el) => {
	let scaleFactor = 1;
	if ($el && $el.getCTM) {
		const ctm = $el.getCTM();
		if (ctm) scaleFactor = (sqrt(ctm.a * ctm.a + ctm.b * ctm.b) + sqrt(ctm.c * ctm.c + ctm.d * ctm.d)) / 2;
	}
	return scaleFactor;
};
/**
* Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.
* @param {SVGGeometryElement} $el - The SVG element to transform into a drawable
* @param {number} start - Starting position (0-1)
* @param {number} end - Ending position (0-1)
* @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality
*/
var createDrawableProxy = ($el, start, end) => {
	const pathLength = K;
	const computedStyles = getComputedStyle($el);
	const strokeLineCap = computedStyles.strokeLinecap;
	const $scalled = computedStyles.vectorEffect === "non-scaling-stroke" ? $el : null;
	let currentCap = strokeLineCap;
	const proxy = new Proxy($el, { get(target, property) {
		const value = target[property];
		if (property === proxyTargetSymbol) return target;
		if (property === "setAttribute") return (...args) => {
			if (args[0] === "draw") {
				const values = args[1].split(" ");
				const v1 = +values[0];
				const v2 = +values[1];
				const scaleFactor = getScaleFactor($scalled);
				const os = v1 * -pathLength * scaleFactor;
				const d1 = v2 * pathLength * scaleFactor + os;
				const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;
				if (strokeLineCap !== "butt") {
					const newCap = v1 === v2 ? "butt" : strokeLineCap;
					if (currentCap !== newCap) {
						target.style.strokeLinecap = `${newCap}`;
						currentCap = newCap;
					}
				}
				target.setAttribute("stroke-dashoffset", `${os}`);
				target.setAttribute("stroke-dasharray", `${d1} ${d2}`);
			}
			return Reflect.apply(value, target, args);
		};
		if (isFnc(value)) return (...args) => Reflect.apply(value, target, args);
		else return value;
	} });
	if ($el.getAttribute("pathLength") !== `${pathLength}`) {
		$el.setAttribute("pathLength", `${pathLength}`);
		proxy.setAttribute("draw", `${start} ${end}`);
	}
	return proxy;
};
/**
* Creates drawable proxies for multiple SVG elements.
* @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors
* @param {number} [start=0] - Starting position (0-1)
* @param {number} [end=0] - Ending position (0-1)
* @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality
*/
var createDrawable = (selector, start = 0, end = 0) => {
	return parseTargets(selector).map(($el) => createDrawableProxy($el, start, end));
};

//#endregion
//#region node_modules/animejs/dist/modules/svg/morphto.js
/**
* Anime.js - svg - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   TargetsParam,
*   FunctionValue
* } from '../types/index.js'
*/
/**
* @param  {TargetsParam} path2
* @param  {Number} [precision]
* @return {FunctionValue}
*/
var morphTo = (path2, precision = .33) => ($path1) => {
	if (!($path1.tagName || "").toLowerCase().match(/^(path|polygon|polyline)$/)) throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
	const $path2 = getPath(path2);
	if (!$path2) throw new Error("Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.");
	if (!($path2.tagName || "").toLowerCase().match(/^(path|polygon|polyline)$/)) throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);
	const isPath = $path1.tagName === "path";
	const separator = isPath ? " " : ",";
	const previousPoints = $path1[morphPointsSymbol];
	if (previousPoints) $path1.setAttribute(isPath ? "d" : "points", previousPoints);
	let v1 = "", v2 = "";
	if (!precision) {
		v1 = $path1.getAttribute(isPath ? "d" : "points");
		v2 = $path2.getAttribute(isPath ? "d" : "points");
	} else {
		const length1 = $path1.getTotalLength();
		const length2 = $path2.getTotalLength();
		const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
		for (let i = 0; i < maxPoints; i++) {
			const t = i / (maxPoints - 1);
			const pointOnPath1 = $path1.getPointAtLength(length1 * t);
			const pointOnPath2 = $path2.getPointAtLength(length2 * t);
			const prefix = isPath ? i === 0 ? "M" : "L" : "";
			v1 += prefix + round$1(pointOnPath1.x, 3) + separator + pointOnPath1.y + " ";
			v2 += prefix + round$1(pointOnPath2.x, 3) + separator + pointOnPath2.y + " ";
		}
	}
	$path1[morphPointsSymbol] = v2;
	return [v1, v2];
};

//#endregion
//#region node_modules/animejs/dist/modules/svg/index.js
var svg_exports = /* @__PURE__ */ __export({
	createDrawable: () => createDrawable,
	createMotionPath: () => createMotionPath,
	morphTo: () => morphTo
});

//#endregion
//#region node_modules/animejs/dist/modules/text/split.js
/**
* Anime.js - text - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Tickable,
*   DOMTarget,
*   SplitTemplateParams,
*   SplitFunctionValue,
*   TextSplitterParams,
* } from '../types/index.js'
*/
var segmenter = typeof Intl !== "undefined" && Intl.Segmenter;
var valueRgx = /\{value\}/g;
var indexRgx = /\{i\}/g;
var whiteSpaceGroupRgx = /(\s+)/;
var whiteSpaceRgx = /^\s+$/;
var lineType = "line";
var wordType = "word";
var charType = "char";
var dataLine = `data-line`;
/**
* @typedef {Object} Segment
* @property {String} segment
* @property {Boolean} [isWordLike]
*/
/**
* @typedef {Object} Segmenter
* @property {function(String): Iterable<Segment>} segment
*/
/** @type {Segmenter} */
var wordSegmenter = null;
/** @type {Segmenter} */
var graphemeSegmenter = null;
var $splitTemplate = null;
/**
* @param  {Segment} seg
* @return {Boolean}
*/
var isSegmentWordLike = (seg) => {
	return seg.isWordLike || seg.segment === " " || isNum(+seg.segment);
};
/**
* @param {HTMLElement} $el
*/
var setAriaHidden = ($el) => $el.setAttribute("aria-hidden", "true");
/**
* @param {DOMTarget} $el
* @param {String} type
* @return {Array<HTMLElement>}
*/
var getAllTopLevelElements = ($el, type) => [...$el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`)];
var debugColors = {
	line: "#00D672",
	word: "#FF4B4B",
	char: "#5A87FF"
};
/**
* @param {HTMLElement} $el
*/
var filterEmptyElements = ($el) => {
	if (!$el.childElementCount && !$el.textContent.trim()) {
		const $parent = $el.parentElement;
		$el.remove();
		if ($parent) filterEmptyElements($parent);
	}
};
/**
* @param {HTMLElement} $el
* @param {Number} lineIndex
* @param {Set<HTMLElement>} bin
* @returns {Set<HTMLElement>}
*/
var filterLineElements = ($el, lineIndex, bin) => {
	const dataLineAttr = $el.getAttribute(dataLine);
	if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === "BR") bin.add($el);
	let i = $el.childElementCount;
	while (i--) filterLineElements($el.children[i], lineIndex, bin);
	return bin;
};
/**
* @param  {'line'|'word'|'char'} type
* @param  {SplitTemplateParams} params
* @return {String}
*/
var generateTemplate = (type, params = {}) => {
	let template = ``;
	const classString = isStr(params.class) ? ` class="${params.class}"` : "";
	const cloneType = setValue(params.clone, false);
	const wrapType = setValue(params.wrap, false);
	const overflow = wrapType ? wrapType === true ? "clip" : wrapType : cloneType ? "clip" : false;
	if (wrapType) template += `<span${overflow ? ` style="overflow:${overflow};"` : ""}>`;
	template += `<span${classString}${cloneType ? ` style="position:relative;"` : ""} data-${type}="{i}">`;
	if (cloneType) {
		const left = cloneType === "left" ? "-100%" : cloneType === "right" ? "100%" : "0";
		const top = cloneType === "top" ? "-100%" : cloneType === "bottom" ? "100%" : "0";
		template += `<span>{value}</span>`;
		template += `<span inert style="position:absolute;top:${top};left:${left};white-space:nowrap;">{value}</span>`;
	} else template += `{value}`;
	template += `</span>`;
	if (wrapType) template += `</span>`;
	return template;
};
/**
* @param  {String|SplitFunctionValue} htmlTemplate
* @param  {Array<HTMLElement>} store
* @param  {Node|HTMLElement} node
* @param  {DocumentFragment} $parentFragment
* @param  {'line'|'word'|'char'} type
* @param  {Boolean} debug
* @param  {Number} lineIndex
* @param  {Number} [wordIndex]
* @param  {Number} [charIndex]
* @return {HTMLElement}
*/
var processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {
	const isLine = type === lineType;
	const isChar = type === charType;
	const className = `_${type}_`;
	const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;
	const displayStyle = isLine ? "block" : "inline-block";
	$splitTemplate.innerHTML = template.replace(valueRgx, `<i class="${className}"></i>`).replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);
	const $content = $splitTemplate.content;
	const $highestParent = $content.firstElementChild;
	const $split = $content.querySelector(`[data-${type}]`) || $highestParent;
	const $replacables = $content.querySelectorAll(`i.${className}`);
	const replacablesLength = $replacables.length;
	if (replacablesLength) {
		$highestParent.style.display = displayStyle;
		$split.style.display = displayStyle;
		$split.setAttribute(dataLine, `${lineIndex}`);
		if (!isLine) {
			$split.setAttribute("data-word", `${wordIndex}`);
			if (isChar) $split.setAttribute("data-char", `${charIndex}`);
		}
		let i = replacablesLength;
		while (i--) {
			const $replace = $replacables[i];
			const $closestParent = $replace.parentElement;
			$closestParent.style.display = displayStyle;
			if (isLine) $closestParent.innerHTML = node.innerHTML;
			else $closestParent.replaceChild(node.cloneNode(true), $replace);
		}
		store.push($split);
		$parentFragment.appendChild($content);
	} else console.warn(`The expression "{value}" is missing from the provided template.`);
	if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;
	return $highestParent;
};
/**
* A class that splits text into words and wraps them in span elements while preserving the original HTML structure.
* @class
*/
var TextSplitter = class {
	/**
	* @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
	* @param  {TextSplitterParams} [parameters]
	*/
	constructor(target, parameters = {}) {
		if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : { segment: (text) => {
			const segments = [];
			const words$1 = text.split(whiteSpaceGroupRgx);
			for (let i = 0, l = words$1.length; i < l; i++) {
				const segment = words$1[i];
				segments.push({
					segment,
					isWordLike: !whiteSpaceRgx.test(segment)
				});
			}
			return segments;
		} };
		if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: "grapheme" }) : { segment: (text) => [...text].map((char) => ({ segment: char })) };
		if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement("template");
		if (scope.current) scope.current.register(this);
		const { words, chars, lines, accessible, includeSpaces, debug } = parameters;
		const $target = (target = isArr(target) ? target[0] : target) && target.nodeType ? target : (getNodeList(target) || [])[0];
		const lineParams = lines === true ? {} : lines;
		const wordParams = words === true || isUnd(words) ? {} : words;
		const charParams = chars === true ? {} : chars;
		this.debug = setValue(debug, false);
		this.includeSpaces = setValue(includeSpaces, false);
		this.accessible = setValue(accessible, true);
		this.linesOnly = lineParams && !wordParams && !charParams;
		/** @type {String|false|SplitFunctionValue} */
		this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, lineParams) : lineParams;
		/** @type {String|false|SplitFunctionValue} */
		this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, wordParams) : wordParams;
		/** @type {String|false|SplitFunctionValue} */
		this.charTemplate = isObj(charParams) ? generateTemplate(charType, charParams) : charParams;
		this.$target = $target;
		this.html = $target && $target.innerHTML;
		this.lines = [];
		this.words = [];
		this.chars = [];
		this.effects = [];
		this.effectsCleanups = [];
		this.cache = null;
		this.ready = false;
		this.width = 0;
		this.resizeTimeout = null;
		const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();
		this.resizeObserver = new ResizeObserver(() => {
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = setTimeout(() => {
				const currentWidth = $target.offsetWidth;
				if (currentWidth === this.width) return;
				this.width = currentWidth;
				handleSplit();
			}, 150);
		});
		if (this.lineTemplate && !this.ready) doc.fonts.ready.then(handleSplit);
		else handleSplit();
		$target ? this.resizeObserver.observe($target) : console.warn("No Text Splitter target found.");
	}
	/**
	* @param  {(...args: any[]) => Tickable | (() => void)} effect
	* @return this
	*/
	addEffect(effect) {
		if (!isFnc(effect)) return console.warn("Effect must return a function.");
		const refreshableEffect = keepTime(effect);
		this.effects.push(refreshableEffect);
		if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);
		return this;
	}
	revert() {
		clearTimeout(this.resizeTimeout);
		this.lines.length = this.words.length = this.chars.length = 0;
		this.resizeObserver.disconnect();
		this.effectsCleanups.forEach((cleanup) => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());
		this.$target.innerHTML = this.html;
		return this;
	}
	/**
	* Recursively processes a node and its children
	* @param {Node} node
	*/
	splitNode(node) {
		const wordTemplate = this.wordTemplate;
		const charTemplate = this.charTemplate;
		const includeSpaces = this.includeSpaces;
		const debug = this.debug;
		const nodeType = node.nodeType;
		if (nodeType === 3) {
			const nodeText = node.nodeValue;
			if (nodeText.trim()) {
				const tempWords = [];
				const words = this.words;
				const chars = this.chars;
				const wordSegments = wordSegmenter.segment(nodeText);
				const $wordsFragment = doc.createDocumentFragment();
				let prevSeg = null;
				for (const wordSegment of wordSegments) {
					const segment = wordSegment.segment;
					const isWordLike = isSegmentWordLike(wordSegment);
					if (!prevSeg || isWordLike && prevSeg && isSegmentWordLike(prevSeg)) tempWords.push(segment);
					else {
						const lastWordIndex = tempWords.length - 1;
						if (!tempWords[lastWordIndex].includes(" ") && !segment.includes(" ")) tempWords[lastWordIndex] += segment;
						else tempWords.push(segment);
					}
					prevSeg = wordSegment;
				}
				for (let i = 0, l = tempWords.length; i < l; i++) {
					const word = tempWords[i];
					if (!word.trim()) {
						if (i && includeSpaces) continue;
						$wordsFragment.appendChild(doc.createTextNode(word));
					} else {
						const nextWord = tempWords[i + 1];
						const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();
						const wordToProcess = word;
						const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;
						const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + "\xA0" : word);
						if (charTemplate) {
							const charSegmentsArray = [...charSegments];
							for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {
								const charSegment = charSegmentsArray[j];
								const charText = j === jl - 1 && hasWordFollowingSpace ? charSegment.segment + "\xA0" : charSegment.segment;
								processHTMLTemplate(charTemplate, chars, doc.createTextNode(charText), $charsFragment, charType, debug, -1, words.length, chars.length);
							}
						}
						if (wordTemplate) processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);
						else if (charTemplate) $wordsFragment.appendChild($charsFragment);
						else $wordsFragment.appendChild(doc.createTextNode(word));
						if (hasWordFollowingSpace) i++;
					}
				}
				node.parentNode.replaceChild($wordsFragment, node);
			}
		} else if (nodeType === 1) {
			const childNodes = [...node.childNodes];
			for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);
		}
	}
	/**
	* @param {Boolean} clearCache
	* @return {this}
	*/
	split(clearCache = false) {
		const $el = this.$target;
		const isCached = !!this.cache && !clearCache;
		const lineTemplate = this.lineTemplate;
		const wordTemplate = this.wordTemplate;
		const charTemplate = this.charTemplate;
		const fontsReady = doc.fonts.status !== "loading";
		const canSplitLines = lineTemplate && fontsReady;
		this.ready = !lineTemplate || fontsReady;
		if (canSplitLines || clearCache) this.effectsCleanups.forEach((cleanup) => isFnc(cleanup) && cleanup(this));
		if (!isCached) {
			if (clearCache) {
				$el.innerHTML = this.html;
				this.words.length = this.chars.length = 0;
			}
			this.splitNode($el);
			this.cache = $el.innerHTML;
		}
		if (canSplitLines) {
			if (isCached) $el.innerHTML = this.cache;
			this.lines.length = 0;
			if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
		}
		if (charTemplate && (canSplitLines || wordTemplate)) this.chars = getAllTopLevelElements($el, charType);
		const elementsArray = this.words.length ? this.words : this.chars;
		let y, linesCount = 0;
		for (let i = 0, l = elementsArray.length; i < l; i++) {
			const $el$1 = elementsArray[i];
			const { top, height } = $el$1.getBoundingClientRect();
			if (y && top - y > height * .5) linesCount++;
			$el$1.setAttribute(dataLine, `${linesCount}`);
			const nested = $el$1.querySelectorAll(`[${dataLine}]`);
			let c = nested.length;
			while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);
			y = top;
		}
		if (canSplitLines) {
			const linesFragment = doc.createDocumentFragment();
			const parents = /* @__PURE__ */ new Set();
			const clones = [];
			for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {
				const $clone = $el.cloneNode(true);
				filterLineElements($clone, lineIndex, /* @__PURE__ */ new Set()).forEach(($el$1) => {
					const $parent = $el$1.parentElement;
					if ($parent) parents.add($parent);
					$el$1.remove();
				});
				clones.push($clone);
			}
			parents.forEach(filterEmptyElements);
			for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);
			$el.innerHTML = "";
			$el.appendChild(linesFragment);
			if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);
			if (charTemplate) this.chars = getAllTopLevelElements($el, charType);
		}
		if (this.linesOnly) {
			const words = this.words;
			let w = words.length;
			while (w--) {
				const $word = words[w];
				$word.replaceWith($word.textContent);
			}
			words.length = 0;
		}
		if (this.accessible && (canSplitLines || !isCached)) {
			const $accessible = doc.createElement("span");
			$accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;
			$accessible.innerHTML = this.html;
			$el.insertBefore($accessible, $el.firstChild);
			this.lines.forEach(setAriaHidden);
			this.words.forEach(setAriaHidden);
			this.chars.forEach(setAriaHidden);
		}
		this.width = $el.offsetWidth;
		if (canSplitLines || clearCache) this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));
		return this;
	}
	refresh() {
		this.split(true);
	}
};
/**
* @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
* @param  {TextSplitterParams} [parameters]
* @return {TextSplitter}
*/
var splitText = (target, parameters) => new TextSplitter(target, parameters);
/**
* @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()
*
* @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target
* @param  {TextSplitterParams} [parameters]
* @return {TextSplitter}
*/
var split = (target, parameters) => {
	console.warn("text.split() is deprecated, import splitText() directly, or text.splitText()");
	return new TextSplitter(target, parameters);
};

//#endregion
//#region node_modules/animejs/dist/modules/text/index.js
var text_exports = /* @__PURE__ */ __export({
	TextSplitter: () => TextSplitter,
	split: () => split,
	splitText: () => splitText
});

//#endregion
//#region node_modules/animejs/dist/modules/waapi/waapi.js
/**
* Anime.js - waapi - ESM
* @version v4.2.2
* @license MIT
* @copyright 2025 - Julian Garnier
*/
/**
* @import {
*   Callback,
*   EasingFunction,
*   EasingParam,
*   DOMTarget,
*   DOMTargetsParam,
*   DOMTargetsArray,
*   WAAPIAnimationParams,
*   WAAPITweenOptions,
*   WAAPIKeyframeValue,
*   WAAPITweenValue
* } from '../types/index.js'
*/
/**
* @import {
*   Spring,
* } from '../easings/spring/index.js'
*/
/**
* @import {
*   ScrollObserver,
* } from '../events/scroll.js'
*/
/**
* Converts an easing function into a valid CSS linear() timing function string
* @param {EasingFunction} fn
* @param {number} [samples=100]
* @returns {string} CSS linear() timing function
*/
var easingToLinear = (fn, samples = 100) => {
	const points = [];
	for (let i = 0; i <= samples; i++) points.push(round$1(fn(i / samples), 4));
	return `linear(${points.join(", ")})`;
};
var WAAPIEasesLookups = {};
/**
* @param  {EasingParam} ease
* @return {String}
*/
var parseWAAPIEasing = (ease) => {
	let parsedEase = WAAPIEasesLookups[ease];
	if (parsedEase) return parsedEase;
	parsedEase = "linear";
	if (isStr(ease)) {
		if (stringStartsWith(ease, "linear") || stringStartsWith(ease, "cubic-") || stringStartsWith(ease, "steps") || stringStartsWith(ease, "ease")) parsedEase = ease;
		else if (stringStartsWith(ease, "cubicB")) parsedEase = toLowerCase(ease);
		else {
			const parsed = parseEaseString(ease);
			if (isFnc(parsed)) parsedEase = parsed === none ? "linear" : easingToLinear(parsed);
		}
		WAAPIEasesLookups[ease] = parsedEase;
	} else if (isFnc(ease)) {
		const easing = easingToLinear(ease);
		if (easing) parsedEase = easing;
	} else if (ease.ease) parsedEase = easingToLinear(
		/** @type {Spring} */
		ease.ease
	);
	return parsedEase;
};
var transformsShorthands = [
	"x",
	"y",
	"z"
];
var commonDefaultPXProperties = [
	"perspective",
	"width",
	"height",
	"margin",
	"padding",
	"top",
	"right",
	"bottom",
	"left",
	"borderWidth",
	"fontSize",
	"borderRadius",
	...transformsShorthands
];
var validIndividualTransforms = /* @__PURE__ */ (() => [...transformsShorthands, ...validTransforms.filter((t) => [
	"X",
	"Y",
	"Z"
].some((axis) => t.endsWith(axis)))])();
var transformsPropertiesRegistered = null;
/**
* @param  {String} propName
* @param  {WAAPIKeyframeValue} value
* @param  {DOMTarget} $el
* @param  {Number} i
* @param  {Number} targetsLength
* @return {String}
*/
var normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
	let v = isStr(value) ? value : getFunctionValue(value, $el, i, targetsLength);
	if (!isNum(v)) return v;
	if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, "translate")) return `${v}px`;
	if (stringStartsWith(propName, "rotate") || stringStartsWith(propName, "skew")) return `${v}deg`;
	return `${v}`;
};
/**
* @param  {DOMTarget} $el
* @param  {String} propName
* @param  {WAAPIKeyframeValue} from
* @param  {WAAPIKeyframeValue} to
* @param  {Number} i
* @param  {Number} targetsLength
* @return {WAAPITweenValue}
*/
var parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
	/** @type {WAAPITweenValue} */
	let tweenValue = "0";
	const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
	if (!isUnd(from)) tweenValue = [normalizeTweenValue(propName, from, $el, i, targetsLength), computedTo];
	else tweenValue = isArr(to) ? to.map((v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
	return tweenValue;
};
var WAAPIAnimation = class {
	/**
	* @param {DOMTargetsParam} targets
	* @param {WAAPIAnimationParams} params
	*/
	constructor(targets, params) {
		if (scope.current) scope.current.register(this);
		if (isNil(transformsPropertiesRegistered)) if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, "registerProperty"))) transformsPropertiesRegistered = false;
		else {
			validTransforms.forEach((t) => {
				const isSkew = stringStartsWith(t, "skew");
				const isScale = stringStartsWith(t, "scale");
				const isRotate = stringStartsWith(t, "rotate");
				const isTranslate = stringStartsWith(t, "translate");
				const isAngle = isRotate || isSkew;
				const syntax = isAngle ? "<angle>" : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
				try {
					CSS.registerProperty({
						name: "--" + t,
						syntax,
						inherits: false,
						initialValue: isTranslate ? "0px" : isAngle ? "0deg" : isScale ? "1" : "0"
					});
				} catch {}
			});
			transformsPropertiesRegistered = true;
		}
		const parsedTargets = registerTargets(targets);
		const targetsLength = parsedTargets.length;
		if (!targetsLength) console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
		const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));
		const spring$1 = ease.ease && ease;
		const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
		const scroll = autoplay && autoplay.link ? autoplay : false;
		const alternate = params.alternate && params.alternate === true;
		const reversed = params.reversed && params.reversed === true;
		const loop = setValue(params.loop, globals.defaults.loop);
		const iterations = loop === true || loop === Infinity ? Infinity : isNum(loop) ? loop + 1 : 1;
		/** @type {PlaybackDirection} */
		const direction = alternate ? reversed ? "alternate-reverse" : "alternate" : reversed ? "reverse" : "normal";
		/** @type {FillMode} */
		const fill = "both";
		/** @type {String} */
		const easing = parseWAAPIEasing(ease);
		const timeScale = globals.timeScale === 1 ? 1 : K;
		/** @type {DOMTargetsArray}] */
		this.targets = parsedTargets;
		/** @type {Array<globalThis.Animation>}] */
		this.animations = [];
		/** @type {globalThis.Animation}] */
		this.controlAnimation = null;
		/** @type {Callback<this>} */
		this.onComplete = params.onComplete || globals.defaults.onComplete;
		/** @type {Number} */
		this.duration = 0;
		/** @type {Boolean} */
		this.muteCallbacks = false;
		/** @type {Boolean} */
		this.completed = false;
		/** @type {Boolean} */
		this.paused = !autoplay || scroll !== false;
		/** @type {Boolean} */
		this.reversed = reversed;
		/** @type {Boolean} */
		this.persist = setValue(params.persist, globals.defaults.persist);
		/** @type {Boolean|ScrollObserver} */
		this.autoplay = autoplay;
		/** @type {Number} */
		this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
		/** @type {Function} */
		this._resolve = noop;
		/** @type {Number} */
		this._completed = 0;
		/** @type {Array.<Object>} */
		this._inlineStyles = [];
		parsedTargets.forEach(($el, i) => {
			const cachedTransforms = $el[transformsSymbol];
			const hasIndividualTransforms = validIndividualTransforms.some((t) => params.hasOwnProperty(t));
			const elStyle = $el.style;
			const inlineStyles = this._inlineStyles[i] = {};
			/** @type {Number} */
			const duration = (spring$1 ? spring$1.settlingDuration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
			/** @type {Number} */
			const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
			/** @type {CompositeOperation} */
			const composite = setValue(params.composition, "replace");
			for (let name in params) {
				if (!isKey(name)) continue;
				/** @type {PropertyIndexedKeyframes} */
				const keyframes = {};
				/** @type {KeyframeAnimationOptions} */
				const tweenParams = {
					iterations,
					direction,
					fill,
					easing,
					duration,
					delay,
					composite
				};
				const propertyValue = params[name];
				const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;
				const styleName = individualTransformProperty ? "transform" : name;
				if (!inlineStyles[styleName]) inlineStyles[styleName] = elStyle[styleName];
				let parsedPropertyValue;
				if (isObj(propertyValue)) {
					const tweenOptions = propertyValue;
					const tweenOptionsEase = setValue(tweenOptions.ease, ease);
					const tweenOptionsSpring = tweenOptionsEase.ease && tweenOptionsEase;
					const to = tweenOptions.to;
					const from = tweenOptions.from;
					/** @type {Number} */
					tweenParams.duration = (tweenOptionsSpring ? tweenOptionsSpring.settlingDuration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
					/** @type {Number} */
					tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
					/** @type {CompositeOperation} */
					tweenParams.composite = setValue(tweenOptions.composition, composite);
					/** @type {String} */
					tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
					parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
					if (individualTransformProperty) {
						keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
						cachedTransforms[individualTransformProperty] = parsedPropertyValue;
					} else keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
					addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
					if (!isUnd(from)) if (!individualTransformProperty) elStyle[name] = keyframes[name][0];
					else {
						const key = `--${individualTransformProperty}`;
						elStyle.setProperty(key, keyframes[key][0]);
					}
				} else {
					parsedPropertyValue = isArr(propertyValue) ? propertyValue.map((v) => normalizeTweenValue(name, v, $el, i, targetsLength)) : normalizeTweenValue(name, propertyValue, $el, i, targetsLength);
					if (individualTransformProperty) {
						keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
						cachedTransforms[individualTransformProperty] = parsedPropertyValue;
					} else keyframes[name] = parsedPropertyValue;
					addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
				}
			}
			if (hasIndividualTransforms) {
				let transforms = emptyString;
				for (let t in cachedTransforms) transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
				elStyle.transform = transforms;
			}
		});
		if (scroll)
 /** @type {ScrollObserver} */ this.autoplay.link(this);
	}
	/**
	* @callback forEachCallback
	* @param {globalThis.Animation} animation
	*/
	/**
	* @param  {forEachCallback|String} callback
	* @return {this}
	*/
	forEach(callback) {
		const cb = isStr(callback) ? (a) => a[callback]() : callback;
		this.animations.forEach(cb);
		return this;
	}
	get speed() {
		return this._speed;
	}
	set speed(speed) {
		this._speed = +speed;
		this.forEach((anim) => anim.playbackRate = speed);
	}
	get currentTime() {
		const controlAnimation = this.controlAnimation;
		const timeScale = globals.timeScale;
		return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
	}
	set currentTime(time) {
		const t = time * (globals.timeScale === 1 ? 1 : K);
		this.forEach((anim) => {
			if (!this.persist && t >= this.duration) anim.play();
			anim.currentTime = t;
		});
	}
	get progress() {
		return this.currentTime / this.duration;
	}
	set progress(progress) {
		this.forEach((anim) => anim.currentTime = progress * this.duration || 0);
	}
	resume() {
		if (!this.paused) return this;
		this.paused = false;
		return this.forEach("play");
	}
	pause() {
		if (this.paused) return this;
		this.paused = true;
		return this.forEach("pause");
	}
	alternate() {
		this.reversed = !this.reversed;
		this.forEach("reverse");
		if (this.paused) this.forEach("pause");
		return this;
	}
	play() {
		if (this.reversed) this.alternate();
		return this.resume();
	}
	reverse() {
		if (!this.reversed) this.alternate();
		return this.resume();
	}
	/**
	* @param {Number} time
	* @param {Boolean} muteCallbacks
	*/
	seek(time, muteCallbacks = false) {
		if (muteCallbacks) this.muteCallbacks = true;
		if (time < this.duration) this.completed = false;
		this.currentTime = time;
		this.muteCallbacks = false;
		if (this.paused) this.pause();
		return this;
	}
	restart() {
		this.completed = false;
		return this.seek(0, true).resume();
	}
	commitStyles() {
		return this.forEach("commitStyles");
	}
	complete() {
		return this.seek(this.duration);
	}
	cancel() {
		this.muteCallbacks = true;
		return this.commitStyles().forEach("cancel");
	}
	revert() {
		this.cancel().targets.forEach(($el, i) => {
			const targetStyle = $el.style;
			const targetInlineStyles = this._inlineStyles[i];
			for (let name in targetInlineStyles) {
				const originalInlinedValue = targetInlineStyles[name];
				if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) targetStyle.removeProperty(toLowerCase(name));
				else targetStyle[name] = originalInlinedValue;
			}
			if ($el.getAttribute("style") === emptyString) $el.removeAttribute("style");
		});
		return this;
	}
	/**
	* @typedef {this & {then: null}} ResolvedWAAPIAnimation
	*/
	/**
	* @param  {Callback<ResolvedWAAPIAnimation>} [callback]
	* @return Promise<this>
	*/
	then(callback = noop) {
		const then = this.then;
		const onResolve = () => {
			this.then = null;
			callback(this);
			this.then = then;
			this._resolve = noop;
		};
		return new Promise((r) => {
			this._resolve = () => r(onResolve());
			if (this.completed) this._resolve();
			return this;
		});
	}
};
var waapi = {
	animate: (targets, params) => new WAAPIAnimation(targets, params),
	convertEase: easingToLinear
};

//#endregion
export { registerTargets as $, Animatable, Draggable, JSAnimation, Scope, ScrollObserver, Spring, TextSplitter, Timeline, Timer, WAAPIAnimation, animate, clamp, cleanInlineStyles, createAnimatable, createDraggable, createDrawable, createMotionPath, createScope, createSeededRandom, createSpring, createTimeline, createTimer, cubicBezier, damp, degToRad, eases, easings_exports as easings, engine, get, irregular, keepTime, lerp, linear, mapRange, morphTo, onScroll, padEnd, padStart, radToDeg, random, randomPick, remove, round, roundPad, scrollContainers, set, shuffle, snap, split, splitText, spring, stagger, steps, svg_exports as svg, sync, text_exports as text, utils_exports as utils, waapi, wrap };
//# sourceMappingURL=animejs.js.map