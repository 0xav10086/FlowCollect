{"version":3,"file":"animejs.js","names":["split","round","max","debugColors","clamp","sync","snap","lerp","clamp","steps","clamp","number","max","val","round","round","words","$el","round","spring"],"sources":["../../animejs/dist/modules/timeline/position.js","../../animejs/dist/modules/timeline/timeline.js","../../animejs/dist/modules/utils/time.js","../../animejs/dist/modules/scope/scope.js","../../animejs/dist/modules/events/scroll.js","../../animejs/dist/modules/easings/cubic-bezier/index.js","../../animejs/dist/modules/easings/steps/index.js","../../animejs/dist/modules/easings/linear/index.js","../../animejs/dist/modules/easings/irregular/index.js","../../animejs/dist/modules/easings/index.js","../../animejs/dist/modules/utils/chainable.js","../../animejs/dist/modules/utils/random.js","../../animejs/dist/modules/utils/stagger.js","../../animejs/dist/modules/utils/index.js","../../animejs/dist/modules/svg/helpers.js","../../animejs/dist/modules/svg/motionpath.js","../../animejs/dist/modules/svg/drawable.js","../../animejs/dist/modules/svg/morphto.js","../../animejs/dist/modules/svg/index.js","../../animejs/dist/modules/text/split.js","../../animejs/dist/modules/text/index.js","../../animejs/dist/modules/waapi/waapi.js"],"sourcesContent":["/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { relativeValuesExecRgx, minValue } from '../core/consts.js';\nimport { isUnd, isNum, stringStartsWith, isNil } from '../core/helpers.js';\nimport { getRelativeValue } from '../core/values.js';\n\n/**\n * @import {\n *   Tickable,\n *   TimelinePosition,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from './timeline.js'\n*/\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */(timeline._tail);\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimelinePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */(timePosition);\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset :\n           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :\n           tlDuration : tlDuration;\n  }\n};\n\nexport { parseTimelinePosition };\n","/**\n * Anime.js - timeline - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { globals } from '../core/globals.js';\nimport { minValue, compositionTypes, tickModes } from '../core/consts.js';\nimport { mergeObjects, isObj, isFnc, isUnd, isStr, normalizeTime, forEachChildren, isNum, addChild, clampInfinity } from '../core/helpers.js';\nimport { setValue } from '../core/values.js';\nimport { parseTargets } from '../core/targets.js';\nimport { tick } from '../core/render.js';\nimport { cleanInlineStyles } from '../core/styles.js';\nimport { removeTargetsFromRenderable } from '../animation/composition.js';\nimport { JSAnimation } from '../animation/animation.js';\nimport { Timer } from '../timer/timer.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { parseTimelinePosition } from './position.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   Callback,\n *   Tickable,\n *   TimerParams,\n *   AnimationParams,\n *   Target,\n *   Renderable,\n *   TimelineParams,\n *   DefaultsParams,\n *   TimelinePosition,\n *   StaggerFunction,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ?\n    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :\n    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);\n  tlChild.init(true);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\n\nclass Timeline extends Timer {\n\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEase(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimelinePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {TimelinePosition|AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */(a2);\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          /** @type {Number} */\n          const parsedLength = (parsedTargetsArray.length);\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = { ...childParams };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(\n              staggeredChildParams,\n              this,\n              parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),\n              target,\n              i,\n              parsedLength\n            );\n            i++;\n          });\n        } else {\n          addTlChild(\n            childParams,\n            this,\n            parseTimelinePosition(this, a3),\n            /** @type {TargetsParam} */(a1),\n          );\n        }\n      } else {\n        // It's a Timer\n        addTlChild(\n          /** @type TimerParams */(a1),\n          this,\n          parseTimelinePosition(this,a2),\n        );\n      }\n      return this.init(true);\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);\n    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimelinePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({ duration: 0, onComplete: () => callback(this) }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    removeTargetsFromRenderable(parseTargets(targets), this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedTimeline\n   */\n\n  /**\n   * @param  {Callback<ResolvedTimeline>} [callback]\n   * @return Promise<this>\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\n\nexport { Timeline, createTimeline };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop } from '../core/consts.js';\nimport { globals } from '../core/globals.js';\nimport { isFnc, isUnd } from '../core/helpers.js';\nimport { Timer } from '../timer/timer.js';\n\n/**\n * @import {\n *   Callback,\n *   Tickable,\n * } from '../types/index.js'\n*/\n\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */\nconst sync = (callback = noop) => {\n  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();\n};\n\n/**\n * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor\n * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}\n */\nconst keepTime = constructor => {\n  /** @type {Tickable} */\n  let tracked;\n  return (...args) => {\n    let currentIteration, currentIterationProgress, reversed, alternate;\n    if (tracked) {\n      currentIteration = tracked.currentIteration;\n      currentIterationProgress = tracked.iterationProgress;\n      reversed = tracked.reversed;\n      alternate = tracked._alternate;\n      tracked.revert();\n    }\n    const cleanup = constructor(...args);\n    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;\n    if (!isUnd(currentIterationProgress)) {\n      /** @type {Tickable} */(tracked).currentIteration = currentIteration;\n      /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;\n    }\n    return cleanup || noop;\n  }\n};\n\nexport { keepTime, sync };\n","/**\n * Anime.js - scope - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { doc, win } from '../core/consts.js';\nimport { globals, scope } from '../core/globals.js';\nimport { mergeObjects, isFnc } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\nimport { keepTime } from '../utils/time.js';\n\n/**\n * @import {\n *   Tickable,\n *   ScopeParams,\n *   DOMTarget,\n *   ReactRef,\n *   AngularRef,\n *   DOMTargetSelector,\n *   DefaultsParams,\n *   ScopeConstructorCallback,\n *   ScopeCleanupCallback,\n *   Revertible,\n *   ScopeMethod,\n *   ScopedCallback,\n * } from '../types/index.js'\n*/\n\nclass Scope {\n  /** @param {ScopeParams} [parameters] */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const rootParam = parameters.root;\n    /** @type {Document|DOMTarget} */\n    let root = doc;\n    if (rootParam) {\n      root = /** @type {ReactRef} */(rootParam).current ||\n             /** @type {AngularRef} */(rootParam).nativeElement ||\n             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||\n             doc;\n    }\n    const scopeDefaults = parameters.defaults;\n    const globalDefault = globals.defaults;\n    const mediaQueries = parameters.mediaQueries;\n    /** @type {DefaultsParams} */\n    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n    /** @type {Document|DOMTarget} */\n    this.root = root;\n    /** @type {Array<ScopeConstructorCallback>} */\n    this.constructors = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructors = [];\n    /** @type {Array<Revertible>} */\n    this.revertibles = [];\n    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */\n    this.constructorsOnce = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructorsOnce = [];\n    /** @type {Array<Revertible>} */\n    this.revertiblesOnce = [];\n    /** @type {Boolean} */\n    this.once = false;\n    /** @type {Number} */\n    this.onceIndex = 0;\n    /** @type {Record<String, ScopeMethod>} */\n    this.methods = {};\n    /** @type {Record<String, Boolean>} */\n    this.matches = {};\n    /** @type {Record<String, MediaQueryList>} */\n    this.mediaQueryLists = {};\n    /** @type {Record<String, any>} */\n    this.data = {};\n    if (mediaQueries) {\n      for (let mq in mediaQueries) {\n        const _mq = win.matchMedia(mediaQueries[mq]);\n        this.mediaQueryLists[mq] = _mq;\n        _mq.addEventListener('change', this);\n      }\n    }\n  }\n\n  /**\n   * @param {Revertible} revertible\n   */\n  register(revertible) {\n    const store = this.once ? this.revertiblesOnce : this.revertibles;\n    store.push(revertible);\n  }\n\n  /**\n   * @template T\n   * @param {ScopedCallback<T>} cb\n   * @return {T}\n   */\n  execute(cb) {\n    let activeScope = scope.current;\n    let activeRoot = scope.root;\n    let activeDefaults = globals.defaults;\n    scope.current = this;\n    scope.root = this.root;\n    globals.defaults = this.defaults;\n    const mqs = this.mediaQueryLists;\n    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;\n    const returned = cb(this);\n    scope.current = activeScope;\n    scope.root = activeRoot;\n    globals.defaults = activeDefaults;\n    return returned;\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    this.onceIndex = 0;\n    this.execute(() => {\n      let i = this.revertibles.length;\n      let y = this.revertConstructors.length;\n      while (i--) this.revertibles[i].revert();\n      while (y--) this.revertConstructors[y](this);\n      this.revertibles.length = 0;\n      this.revertConstructors.length = 0;\n      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {ScopeConstructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|ScopeConstructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */\n  add(a1, a2) {\n    this.once = false;\n    if (isFnc(a1)) {\n      const constructor = /** @type {ScopeConstructorCallback} */(a1);\n      this.constructors.push(constructor);\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    } else {\n      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));\n    }\n    return this;\n  }\n\n  /**\n   * @param {ScopeConstructorCallback} scopeConstructorCallback\n   * @return {this}\n   */\n  addOnce(scopeConstructorCallback) {\n    this.once = true;\n    if (isFnc(scopeConstructorCallback)) {\n      const currentIndex = this.onceIndex++;\n      const tracked = this.constructorsOnce[currentIndex];\n      if (tracked) return this;\n      const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);\n      this.constructorsOnce[currentIndex] = constructor;\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructorsOnce.push(revertConstructor);\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @param  {(scope: this) => Tickable} cb\n   * @return {Tickable}\n   */\n  keepTime(cb) {\n    this.once = true;\n    const currentIndex = this.onceIndex++;\n    const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);\n    if (isFnc(tracked)) return tracked(this);\n    const constructor = /** @type {(scope: this) => Tickable} */(keepTime(cb));\n    this.constructorsOnce[currentIndex] = constructor;\n    let trackedTickable;\n    this.execute(() => {\n      trackedTickable = constructor(this);\n    });\n    return trackedTickable;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'change':\n        this.refresh();\n        break;\n    }\n  }\n\n  revert() {\n    const revertibles = this.revertibles;\n    const revertConstructors = this.revertConstructors;\n    const revertiblesOnce = this.revertiblesOnce;\n    const revertConstructorsOnce = this.revertConstructorsOnce;\n    const mqs = this.mediaQueryLists;\n    let i = revertibles.length;\n    let j = revertConstructors.length;\n    let k = revertiblesOnce.length;\n    let l = revertConstructorsOnce.length;\n    while (i--) revertibles[i].revert();\n    while (j--) revertConstructors[j](this);\n    while (k--) revertiblesOnce[k].revert();\n    while (l--) revertConstructorsOnce[l](this);\n    for (let mq in mqs) mqs[mq].removeEventListener('change', this);\n    revertibles.length = 0;\n    revertConstructors.length = 0;\n    this.constructors.length = 0;\n    revertiblesOnce.length = 0;\n    revertConstructorsOnce.length = 0;\n    this.constructorsOnce.length = 0;\n    this.onceIndex = 0;\n    this.matches = {};\n    this.methods = {};\n    this.mediaQueryLists = {};\n    this.data = {};\n  }\n}\n\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */\nconst createScope = params => new Scope(params);\n\nexport { Scope, createScope };\n","/**\n * Anime.js - events - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop, doc, isDomSymbol, relativeValuesExecRgx, win } from '../core/consts.js';\nimport { scope, globals } from '../core/globals.js';\nimport { isUnd, isNum, addChild, forEachChildren, round, isStr, isObj, removeChild, clamp, lerp, isFnc } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\nimport { setValue, getRelativeValue, decomposeRawValue, decomposedOriginalValue } from '../core/values.js';\nimport { convertValueUnit } from '../core/units.js';\nimport { Timer } from '../timer/timer.js';\nimport { get, set } from '../utils/target.js';\nimport { sync } from '../utils/time.js';\nimport { none } from '../easings/none.js';\nimport { parseEase } from '../easings/eases/parser.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   EasingFunction,\n *   Callback,\n *   EasingParam,\n *   ScrollThresholdValue,\n *   ScrollObserverParams,\n *   Tickable,\n *   ScrollThresholdParam,\n *   ScrollThresholdCallback,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   JSAnimation,\n * } from '../animation/animation.js'\n*/\n\n/**\n * @import {\n *   WAAPIAnimation,\n * } from '../waapi/waapi.js'\n*/\n\n/**\n * @import {\n *   Timeline,\n * } from '../timeline/timeline.js'\n*/\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : /** @type {T} */(value);\n\nconst scrollContainers = new Map();\n\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.scale = 1;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: (/** @type {Timer} */self) => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = $el.clientWidth;\n      height = $el.clientHeight;\n      this.top = elRect.top;\n      this.left = elRect.left;\n      this.scale = elRect.width ? width / elRect.width : (elRect.height ? height / elRect.height : 1);\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :\n                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :\n                v === 'center' ? '50%' :\n                v;\n  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = (n / 100) * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */(v).split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */(v);\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */(target);\n      break;\n    }\n  }\n  return $linkedTarget;\n};\n\nlet scrollerIndex = 0;\n\nconst debugColors = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEase(/** @type {EasingParam} */(syncMode)) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);\n    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(\n      (/** @type {String} */m) => () => {\n        const linked = this.linked;\n        return linked && linked[m] ? linked[m]() : null;\n      }\n    ) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.ready = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Forces WAAPI Animation to persist; otherwise, they will stop syncing on finish.\n      if (!isUnd(/** @type {WAAPIAnimation} */(linked))) /** @type {WAAPIAnimation} */(linked).persist = true;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));\n        } else {\n          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n\n  get velocity() {\n    return this.container.velocity;\n  }\n\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n\n  refresh() {\n    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not yet calculated\n    this.ready = true;\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors[this.index % debugColors.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${(size / 2) - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = get(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = set(container.element, { position: 'relative '});\n    }\n\n  }\n\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = get(container.element, 'position') === 'static' ? set(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = get($el, 'position') === 'sticky' ?\n    //                    set($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */($el.parentElement);\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = get($el, 'position') === 'sticky' ? set($el, { position: 'static' }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const scale = container.scale;\n    const offset = (isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top) * scale;\n    const targetSize = (isHori ? rect.width : rect.height) * scale;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */(enter).split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */(enter);\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */(enter);\n    }\n\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */(leave).split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */(leave);\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */(leave);\n    }\n\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = (parsedEnterTarget + offset) - containerSize;\n    const over = (parsedLeaveTarget + offset) - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n\n  handleScroll() {\n    if (!this.ready) return;\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */(syncSmooth) < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;\n          p = round(lerp(lp, p, lerp(.01, .2, /** @type {Number} */(syncSmooth))) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {\n        container.wakeTicker.restart();\n      }\n    }\n\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {\n        this.revert();\n      }\n    }\n\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n\n    this.prevProgress = p;\n  }\n\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    this.ready = false;\n    return this;\n  }\n\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\n\nexport { ScrollObserver, onScroll, scrollContainers };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { abs } from '../../core/helpers.js';\nimport { none } from '../none.js';\n\n/**\n * @import {\n *   EasingFunction,\n * } from '../../types/index.js'\n*/\n\n/**\n * Cubic Bezier solver adapted from https://github.com/gre/bezier-easing\n * (c) 2014 Gatan Renaudeau\n */\n\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */\nconst calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;\n\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */\nconst binarySubdivide = (aX, mX1, mX2) => {\n  let aA = 0, aB = 1, currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (abs(currentX) > .0000001 && ++i < 100);\n  return currentT;\n};\n\n/**\n * @param  {Number} [mX1] The x coordinate of the first point\n * @param  {Number} [mY1] The y coordinate of the first point\n * @param  {Number} [mX2] The x coordinate of the second point\n * @param  {Number} [mY2] The y coordinate of the second point\n * @return {EasingFunction}\n */\n\nconst cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :\n  t => t === 0 || t === 1 ? t :\n  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n\nexport { cubicBezier };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { ceil, floor, clamp } from '../../core/helpers.js';\n\n/**\n * @import {\n *   EasingFunction,\n * } from '../../types/index.js'\n*/\n\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */\nconst steps = (steps = 10, fromStart) => {\n  const roundMethod = fromStart ? ceil : floor;\n  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n\nexport { steps };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isStr, parseNumber, isUnd } from '../../core/helpers.js';\nimport { none } from '../none.js';\n\n/**\n * @import {\n *   EasingFunction,\n * } from '../../types/index.js'\n*/\n\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n *\n * @param  {...(String|Number)} args - Points\n * @return {EasingFunction}\n */\nconst linear = (...args) => {\n  const argsLength = args.length;\n  if (!argsLength) return none;\n  const totalPoints = argsLength - 1;\n  const firstArg = args[0];\n  const lastArg = args[totalPoints];\n  const xPoints = [0];\n  const yPoints = [parseNumber(firstArg)];\n  for (let i = 1; i < totalPoints; i++) {\n    const arg = args[i];\n    const splitValue = isStr(arg) ?\n    /** @type {String} */(arg).trim().split(' ') :\n    [arg];\n    const value = splitValue[0];\n    const percent = splitValue[1];\n    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n    yPoints.push(parseNumber(value));\n  }\n  yPoints.push(parseNumber(lastArg));\n  xPoints.push(1);\n  return function easeLinear(t) {\n    for (let i = 1, l = xPoints.length; i < l; i++) {\n      const currentX = xPoints[i];\n      if (t <= currentX) {\n        const prevX = xPoints[i - 1];\n        const prevY = yPoints[i - 1];\n        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n      }\n    }\n    return yPoints[yPoints.length - 1];\n  }\n};\n\nexport { linear };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { clamp } from '../../core/helpers.js';\nimport { linear } from '../linear/index.js';\n\n/**\n * @import {\n *   EasingFunction,\n * } from '../../types/index.js'\n*/\n\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */\nconst irregular = (length = 10, randomness = 1) => {\n  const values = [0];\n  const total = length - 1;\n  for (let i = 1; i < total; i++) {\n    const previousValue = values[i - 1];\n    const spacing = i / total;\n    const segmentEnd = (i + 1) / total;\n    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n    // Mix the even spacing and random variation based on the randomness parameter\n    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n    values.push(clamp(randomValue, previousValue, 1));\n  }\n  values.push(1);\n  return linear(...values);\n};\n\nexport { irregular };\n","/**\n * Anime.js - easings - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nexport { cubicBezier } from './cubic-bezier/index.js';\nexport { steps } from './steps/index.js';\nexport { linear } from './linear/index.js';\nexport { irregular } from './irregular/index.js';\nexport { Spring, createSpring, spring } from './spring/index.js';\nexport { eases } from './eases/parser.js';\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { noop } from '../core/consts.js';\nimport * as number from './number.js';\n\n// Chain-able utilities\n\nconst numberUtils = number; // Needed to keep the import when bundling\n\nconst chainables = {};\n\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */\nconst curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);\n\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */\nconst chain = fn => {\n   return (...args) => {\n    const result = fn(...args);\n    return new Proxy(noop, {\n      apply: (_, __, [v]) => result(v),\n      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {\n        const nextResult = chainables[prop](...nextArgs);\n        return (/**@type {Number|String} */v) => nextResult(result(v));\n      })\n    });\n  }\n};\n\n/**\n * @param {UtilityFunction} fn\n * @param {String} name\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */\nconst makeChainable = (name, fn, right = 0) => {\n  const chained = (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n  if (!chainables[name]) chainables[name] = chained;\n  return chained;\n};\n\n/**\n * @typedef {Object} ChainablesMap\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedLerp} lerp\n * @property {ChainedDamp} damp\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n */\n\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value - The value to process through the chained operations\n * @return {Number} The processed result\n */\n\n/**\n * @typedef {ChainablesMap & ChainedUtilsResult} ChainableUtil\n */\n\n// Chainable\n\n/**\n * @callback ChainedRoundPad\n * @param {Number} decimalLength - Number of decimal places\n * @return {ChainableUtil}\n */\nconst roundPad = /** @type {typeof numberUtils.roundPad & ChainedRoundPad} */(makeChainable('roundPad', numberUtils.roundPad));\n\n/**\n * @callback ChainedPadStart\n * @param {Number} totalLength - Target length\n * @param {String} padString - String to pad with\n * @return {ChainableUtil}\n */\nconst padStart = /** @type {typeof numberUtils.padStart & ChainedPadStart} */(makeChainable('padStart', numberUtils.padStart));\n\n/**\n * @callback ChainedPadEnd\n * @param {Number} totalLength - Target length\n * @param {String} padString - String to pad with\n * @return {ChainableUtil}\n */\nconst padEnd = /** @type {typeof numberUtils.padEnd & ChainedPadEnd} */(makeChainable('padEnd', numberUtils.padEnd));\n\n/**\n * @callback ChainedWrap\n * @param {Number} min - Minimum boundary\n * @param {Number} max - Maximum boundary\n * @return {ChainableUtil}\n */\nconst wrap = /** @type {typeof numberUtils.wrap & ChainedWrap} */(makeChainable('wrap', numberUtils.wrap));\n\n/**\n * @callback ChainedMapRange\n * @param {Number} inLow - Input range minimum\n * @param {Number} inHigh - Input range maximum\n * @param {Number} outLow - Output range minimum\n * @param {Number} outHigh - Output range maximum\n * @return {ChainableUtil}\n */\nconst mapRange = /** @type {typeof numberUtils.mapRange & ChainedMapRange} */(makeChainable('mapRange', numberUtils.mapRange));\n\n/**\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n */\nconst degToRad = /** @type {typeof numberUtils.degToRad & ChainedDegToRad} */(makeChainable('degToRad', numberUtils.degToRad));\n\n/**\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */\nconst radToDeg = /** @type {typeof numberUtils.radToDeg & ChainedRadToDeg} */(makeChainable('radToDeg', numberUtils.radToDeg));\n\n/**\n * @callback ChainedSnap\n * @param {Number|Array<Number>} increment - Step size or array of snap points\n * @return {ChainableUtil}\n */\nconst snap = /** @type {typeof numberUtils.snap & ChainedSnap} */(makeChainable('snap', numberUtils.snap));\n\n/**\n * @callback ChainedClamp\n * @param {Number} min - Minimum boundary\n * @param {Number} max - Maximum boundary\n * @return {ChainableUtil}\n */\nconst clamp = /** @type {typeof numberUtils.clamp & ChainedClamp} */(makeChainable('clamp', numberUtils.clamp));\n\n/**\n * @callback ChainedRound\n * @param {Number} decimalLength - Number of decimal places\n * @return {ChainableUtil}\n */\nconst round = /** @type {typeof numberUtils.round & ChainedRound} */(makeChainable('round', numberUtils.round));\n\n/**\n * @callback ChainedLerp\n * @param {Number} start - Starting value\n * @param {Number} end - Ending value\n * @return {ChainableUtil}\n */\nconst lerp = /** @type {typeof numberUtils.lerp & ChainedLerp} */(makeChainable('lerp', numberUtils.lerp, 1));\n\n/**\n * @callback ChainedDamp\n * @param {Number} start - Starting value\n * @param {Number} end - Target value\n * @param {Number} deltaTime - Delta time in ms\n * @return {ChainableUtil}\n */\nconst damp = /** @type {typeof numberUtils.damp & ChainedDamp} */(makeChainable('damp', numberUtils.damp, 1));\n\nexport { clamp, damp, degToRad, lerp, mapRange, padEnd, padStart, radToDeg, round, roundPad, snap, wrap };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\n/**\n * Generate a random number between optional min and max (inclusive) and decimal precision\n *\n * @callback RandomNumberGenerator\n * @param    {Number} [min=0] - The minimum value (inclusive)\n * @param    {Number} [max=1] - The maximum value (inclusive)\n * @param    {Number} [decimalLength=0] - Number of decimal places to round to\n * @return   {Number} A random number between min and max\n */\n\n/**\n * Generates a random number between min and max (inclusive) with optional decimal precision\n *\n * @type {RandomNumberGenerator}\n */\nconst random = (min = 0, max = 1, decimalLength = 0) => {\n  const m = 10 ** decimalLength;\n  return Math.floor((Math.random() * (max - min + (1 / m)) + min) * m) / m;\n};\n\nlet _seed = 0;\n\n/**\n * Creates a seeded pseudorandom number generator function\n *\n * @param  {Number} [seed] - The seed value for the random number generator\n * @param  {Number} [seededMin=0] - The minimum default value (inclusive) of the returned function\n * @param  {Number} [seededMax=1] - The maximum default value (inclusive) of the returned function\n * @param  {Number} [seededDecimalLength=0] - Default number of decimal places to round to of the returned function\n * @return {RandomNumberGenerator} A function to generate a random number between optional min and max (inclusive) and decimal precision\n */\nconst createSeededRandom = (seed, seededMin = 0, seededMax = 1, seededDecimalLength = 0) => {\n  let t = seed === undefined ? _seed++ : seed;\n  return (min = seededMin, max = seededMax, decimalLength = seededDecimalLength) => {\n    t += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    const m = 10 ** decimalLength;\n    return Math.floor(((((t ^ t >>> 14) >>> 0) / 4294967296) * (max - min + (1 / m)) + min) * m) / m;\n  }\n};\n\n/**\n * Picks a random element from an array or a string\n *\n * @template T\n * @param    {String|Array<T>} items - The array or string to pick from\n * @return   {String|T} A random element from the array or character from the string\n */\nconst randomPick = items => items[random(0, items.length - 1)];\n\n/**\n * Shuffles an array in-place using the Fisher-Yates algorithm\n * Adapted from https://bost.ocks.org/mike/shuffle/\n *\n * @param  {Array} items - The array to shuffle (will be modified in-place)\n * @return {Array} The same array reference, now shuffled\n */\nconst shuffle = items => {\n  let m = items.length, t, i;\n  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }\n  return items;\n};\n\nexport { createSeededRandom, random, randomPick, shuffle };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { unitsExecRgx, emptyString } from '../core/consts.js';\nimport { isUnd, parseNumber, isFnc, abs, floor, sqrt, round, isArr, isNum, isStr, max } from '../core/helpers.js';\nimport { parseEase } from '../easings/eases/parser.js';\nimport { parseTimelinePosition } from '../timeline/position.js';\nimport { getOriginalAnimatableValue } from '../core/values.js';\nimport { registerTargets } from '../core/targets.js';\nimport { shuffle } from './random.js';\n\n/**\n * @import {\n *   StaggerParams,\n *   StaggerFunction,\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n*/\n\n/**\n * @overload\n * @param {Number} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {String} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @overload\n * @param {[Number, Number]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {[String, String]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range\n * @param {StaggerParams} [params] The stagger parameters\n * @return {StaggerFunction<Number|String>}\n */\nconst stagger = (val, params = {}) => {\n  let values = [];\n  let maxValue = 0;\n  const from = params.from;\n  const reversed = params.reversed;\n  const ease = params.ease;\n  const hasEasing = !isUnd(ease);\n  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);\n  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEase(ease) : null;\n  const grid = params.grid;\n  const axis = params.axis;\n  const customTotal = params.total;\n  const fromFirst = isUnd(from) || from === 0 || from === 'first';\n  const fromCenter = from === 'center';\n  const fromLast = from === 'last';\n  const fromRandom = from === 'random';\n  const isRange = isArr(val);\n  const useProp = params.use;\n  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n  const val2 = isRange ? parseNumber(val[1]) : 0;\n  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n  const start = params.start || 0 + (isRange ? val1 : 0);\n  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n  return (target, i, t, tl) => {\n    const [ registeredTarget ] = registerTargets(target);\n    const total = isUnd(customTotal) ? t : customTotal;\n    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;\n    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;\n    if (fromCenter) fromIndex = (total - 1) / 2;\n    if (fromLast) fromIndex = total - 1;\n    if (!values.length) {\n      for (let index = 0; index < total; index++) {\n        if (!grid) {\n          values.push(abs(fromIndex - index));\n        } else {\n          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n          const toX = index % grid[0];\n          const toY = floor(index / grid[0]);\n          const distanceX = fromX - toX;\n          const distanceY = fromY - toY;\n          let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') value = -distanceX;\n          if (axis === 'y') value = -distanceY;\n          values.push(value);\n        }\n        maxValue = max(...values);\n      }\n      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);\n      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));\n      if (fromRandom) values = shuffle(values);\n    }\n    const spacing = isRange ? (val2 - val1) / maxValue : val1;\n    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);\n    /** @type {String|Number} */\n    let output = offset + ((spacing * round(values[staggerIndex], 2)) || 0);\n    if (params.modifier) output = params.modifier(output);\n    if (unitMatch) output = `${output}${unitMatch[2]}`;\n    return output;\n  }\n};\n\nexport { stagger };\n","/**\n * Anime.js - utils - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nexport { clamp, damp, degToRad, lerp, mapRange, padEnd, padStart, radToDeg, round, roundPad, snap, wrap } from './chainable.js';\nexport { createSeededRandom, random, randomPick, shuffle } from './random.js';\nexport { keepTime, sync } from './time.js';\nexport { get, remove, set } from './target.js';\nexport { stagger } from './stagger.js';\nexport { cleanInlineStyles } from '../core/styles.js';\nexport { registerTargets as $ } from '../core/targets.js';\n","/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isSvg } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\n\n/**\n * @import {\n *   TargetsParam,\n * } from '../types/index.js'\n*/\n\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|void}\n */\nconst getPath = path => {\n  const parsedTargets = parseTargets(path);\n  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);\n  if (!$parsedSvg || !isSvg($parsedSvg)) return console.warn(`${path} is not a valid SVGGeometryElement`);\n  return $parsedSvg;\n};\n\nexport { getPath };\n","/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isSvgSymbol } from '../core/consts.js';\nimport { atan2, PI } from '../core/helpers.js';\nimport { getPath } from './helpers.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   FunctionValue,\n *   TweenObjectValue,\n *   TweenModifier,\n * } from '../types/index.js'\n*/\n\n// Motion path animation\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} totalLength\n * @param {Number} progress\n * @param {Number} lookup\n * @param {Boolean} shouldClamp\n * @return {DOMPoint}\n */\nconst getPathPoint = ($path, totalLength, progress, lookup, shouldClamp) => {\n  const point = progress + lookup;\n  const pointOnPath = shouldClamp\n    ? Math.max(0, Math.min(point, totalLength)) // Clamp between 0 and totalLength\n    : (point % totalLength + totalLength) % totalLength; // Wrap around\n  return $path.getPointAtLength(pointOnPath);\n};\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @param {Number} [offset=0]\n * @return {FunctionValue}\n */\nconst getPathProgess = ($path, pathProperty, offset = 0) => {\n  return $el => {\n    const totalLength = +($path.getTotalLength());\n    const inSvg = $el[isSvgSymbol];\n    const ctm = $path.getCTM();\n    const shouldClamp = offset === 0;\n    /** @type {TweenObjectValue} */\n    return {\n      from: 0,\n      to: totalLength,\n      /** @type {TweenModifier} */\n      modifier: progress => {\n        const offsetLength = offset * totalLength;\n        const newProgress = progress + offsetLength;\n        if (pathProperty === 'a') {\n          const p0 = getPathPoint($path, totalLength, newProgress, -1, shouldClamp);\n          const p1 = getPathPoint($path, totalLength, newProgress, 1, shouldClamp);\n          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n        } else {\n          const p = getPathPoint($path, totalLength, newProgress, 0, shouldClamp);\n          return pathProperty === 'x' ?\n            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :\n            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {TargetsParam} path\n * @param {Number} [offset=0]\n */\nconst createMotionPath = (path, offset = 0) => {\n  const $path = getPath(path);\n  if (!$path) return;\n  return {\n    translateX: getPathProgess($path, 'x', offset),\n    translateY: getPathProgess($path, 'y', offset),\n    rotate: getPathProgess($path, 'a', offset),\n  }\n};\n\nexport { createMotionPath };\n","/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { proxyTargetSymbol, K } from '../core/consts.js';\nimport { isFnc, sqrt } from '../core/helpers.js';\nimport { parseTargets } from '../core/targets.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   DrawableSVGGeometry,\n * } from '../types/index.js'\n*/\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -pathLength * scaleFactor;\n            const d1 = (v2 * pathLength * scaleFactor) + os;\n            const d2 = (pathLength * scaleFactor +\n                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n\n  return /** @type {DrawableSVGGeometry} */(proxy);\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(\n    /** @type {SVGGeometryElement} */($el),\n    start,\n    end\n  ));\n};\n\nexport { createDrawable };\n","/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { morphPointsSymbol } from '../core/consts.js';\nimport { round } from '../core/helpers.js';\nimport { getPath } from './helpers.js';\n\n/**\n * @import {\n *   TargetsParam,\n *   FunctionValue\n * } from '../types/index.js'\n*/\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => ($path1) => {\n  const tagName1 = ($path1.tagName || '').toLowerCase();\n  if (!tagName1.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path1.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));\n  if (!$path2) {\n    throw new Error(\"Can't morph to an invalid target. 'path2' must resolve to an existing <path>, <polygon> or <polyline> SVG element.\");\n  }\n  const tagName2 = ($path2.tagName || '').toLowerCase();\n  if (!tagName2.match(/^(path|polygon|polyline)$/)) {\n    throw new Error(`Can't morph a <${$path2.tagName}> SVG element. Use <path>, <polygon> or <polyline>.`);\n  }\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n\n  let v1 = '', v2 = '';\n\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n\n  $path1[morphPointsSymbol] = v2;\n\n  return [v1, v2];\n};\n\nexport { morphTo };\n","/**\n * Anime.js - svg - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nexport { createMotionPath } from './motionpath.js';\nexport { createDrawable } from './drawable.js';\nexport { morphTo } from './morphto.js';\n","/**\n * Anime.js - text - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isBrowser, doc } from '../core/consts.js';\nimport { scope } from '../core/globals.js';\nimport { isArr, isObj, isFnc, isUnd, isStr, isNum } from '../core/helpers.js';\nimport { getNodeList } from '../core/targets.js';\nimport { setValue } from '../core/values.js';\nimport { keepTime } from '../utils/time.js';\n\n/**\n * @import {\n *   Tickable,\n *   DOMTarget,\n *   SplitTemplateParams,\n *   SplitFunctionValue,\n *   TextSplitterParams,\n * } from '../types/index.js'\n*/\n\nconst segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike ||\n         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later\n         isNum(+seg.segment);   // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\n\nconst debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {SplitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template\n    .replace(valueRgx, `<i class=\"${className}\"></i>`)\n    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);\n  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {\n      segment: (text) => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {\n      segment: text => [...text].map(char => ({ segment: char }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;\n    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && (!wordParams && !charParams);\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {SplitTemplateParams} */(lineParams)) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {SplitTemplateParams} */(wordParams)) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {SplitTemplateParams} */(charParams)) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = keepTime(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y, linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const { top, height } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */($el).offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst splitText = (target, parameters) => new TextSplitter(target, parameters);\n\n/**\n * @deprecated text.split() is deprecated, import splitText() directly, or text.splitText()\n *\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => {\n  console.warn('text.split() is deprecated, import splitText() directly, or text.splitText()');\n  return new TextSplitter(target, parameters);\n};\n\nexport { TextSplitter, split, splitText };\n","/**\n * Anime.js - text - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nexport { TextSplitter, split, splitText } from './split.js';\n","/**\n * Anime.js - waapi - ESM\n * @version v4.2.2\n * @license MIT\n * @copyright 2025 - Julian Garnier\n */\n\nimport { isNil, isUnd, stringStartsWith, isKey, isObj, isArr, toLowerCase, round, isStr, isFnc, isNum } from '../core/helpers.js';\nimport { scope, globals } from '../core/globals.js';\nimport { registerTargets } from '../core/targets.js';\nimport { setValue, getFunctionValue } from '../core/values.js';\nimport { isBrowser, validTransforms, noop, transformsSymbol, shortTransforms, transformsFragmentStrings, emptyString, K } from '../core/consts.js';\nimport { none } from '../easings/none.js';\nimport { parseEaseString } from '../easings/eases/parser.js';\nimport { addWAAPIAnimation } from './composition.js';\n\n/**\n * @import {\n *   Callback,\n *   EasingFunction,\n *   EasingParam,\n *   DOMTarget,\n *   DOMTargetsParam,\n *   DOMTargetsArray,\n *   WAAPIAnimationParams,\n *   WAAPITweenOptions,\n *   WAAPIKeyframeValue,\n *   WAAPITweenValue\n * } from '../types/index.js'\n*/\n\n/**\n * @import {\n *   Spring,\n * } from '../easings/spring/index.js'\n*/\n\n/**\n * @import {\n *   ScrollObserver,\n * } from '../events/scroll.js'\n*/\n\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */\nconst easingToLinear = (fn, samples = 100) => {\n  const points = [];\n  for (let i = 0; i <= samples; i++) points.push(round(fn(i / samples), 4));\n  return `linear(${points.join(', ')})`;\n};\n\nconst WAAPIEasesLookups = {};\n\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */\nconst parseWAAPIEasing = (ease) => {\n  let parsedEase = WAAPIEasesLookups[ease];\n  if (parsedEase) return parsedEase;\n  parsedEase = 'linear';\n  if (isStr(ease)) {\n    if (\n      stringStartsWith(ease, 'linear') ||\n      stringStartsWith(ease, 'cubic-') ||\n      stringStartsWith(ease, 'steps') ||\n      stringStartsWith(ease, 'ease')\n    ) {\n      parsedEase = ease;\n    } else if (stringStartsWith(ease, 'cubicB')) {\n      parsedEase = toLowerCase(ease);\n    } else {\n      const parsed = parseEaseString(ease);\n      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);\n    }\n    // Only cache string based easing name, otherwise function arguments get lost\n    WAAPIEasesLookups[ease] = parsedEase;\n  } else if (isFnc(ease)) {\n    const easing = easingToLinear(ease);\n    if (easing) parsedEase = easing;\n  } else if (/** @type {Spring} */(ease).ease) {\n    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);\n  }\n  return parsedEase;\n};\n\nconst transformsShorthands = ['x', 'y', 'z'];\nconst commonDefaultPXProperties = [\n  'perspective',\n  'width',\n  'height',\n  'margin',\n  'padding',\n  'top',\n  'right',\n  'bottom',\n  'left',\n  'borderWidth',\n  'fontSize',\n  'borderRadius',\n  ...transformsShorthands\n];\n\nconst validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();\n\nlet transformsPropertiesRegistered = null;\n\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */\nconst normalizeTweenValue = (propName, value, $el, i, targetsLength) => {\n  // Do not try to compute strings with getFunctionValue otherwise it will convert CSS variables\n  let v = isStr(value) ? value : getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);\n  if (!isNum(v)) return v;\n  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;\n  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;\n  return `${v}`;\n};\n\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */\nconst parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {\n  /** @type {WAAPITweenValue} */\n  let tweenValue = '0';\n  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n  if (!isUnd(from)) {\n    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n    tweenValue = [computedFrom, computedTo];\n  } else {\n    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n  }\n  return tweenValue;\n};\n\nclass WAAPIAnimation {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */\n  constructor(targets, params) {\n\n    if (scope.current) scope.current.register(this);\n\n    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported\n    if (isNil(transformsPropertiesRegistered)) {\n      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {\n        transformsPropertiesRegistered = false;\n      } else {\n        validTransforms.forEach(t => {\n          const isSkew = stringStartsWith(t, 'skew');\n          const isScale = stringStartsWith(t, 'scale');\n          const isRotate = stringStartsWith(t, 'rotate');\n          const isTranslate = stringStartsWith(t, 'translate');\n          const isAngle = isRotate || isSkew;\n          const syntax = isAngle ? '<angle>' : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n          try {\n            CSS.registerProperty({\n              name: '--' + t,\n              syntax,\n              inherits: false,\n              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',\n            });\n          } catch {}        });\n        transformsPropertiesRegistered = true;\n      }\n    }\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n    const spring = /** @type {Spring} */(ease).ease && ease;\n    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;\n    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;\n    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;\n    const loop = setValue(params.loop, globals.defaults.loop);\n    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);\n    /** @type {PlaybackDirection} */\n    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';\n    /** @type {FillMode} */\n    const fill = 'both'; // We use 'both' here because the animation can be reversed during playback\n    /** @type {String} */\n    const easing = parseWAAPIEasing(ease);\n    const timeScale = (globals.timeScale === 1 ? 1 : K);\n\n    /** @type {DOMTargetsArray}] */\n    this.targets = parsedTargets;\n    /** @type {Array<globalThis.Animation>}] */\n    this.animations = [];\n    /** @type {globalThis.Animation}] */\n    this.controlAnimation = null;\n    /** @type {Callback<this>} */\n    this.onComplete = params.onComplete || /** @type {Callback<WAAPIAnimation>} */(/** @type {unknown} */(globals.defaults.onComplete));\n    /** @type {Number} */\n    this.duration = 0;\n    /** @type {Boolean} */\n    this.muteCallbacks = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.paused = !autoplay || scroll !== false;\n    /** @type {Boolean} */\n    this.reversed = reversed;\n    /** @type {Boolean} */\n    this.persist = setValue(params.persist, globals.defaults.persist);\n    /** @type {Boolean|ScrollObserver} */\n    this.autoplay = autoplay;\n    /** @type {Number} */\n    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Number} */\n    this._completed = 0;\n    /** @type {Array.<Object>} */\n    this._inlineStyles = [];\n\n    parsedTargets.forEach(($el, i) => {\n\n      const cachedTransforms = $el[transformsSymbol];\n      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));\n      const elStyle = $el.style;\n      const inlineStyles = this._inlineStyles[i] = {};\n\n      /** @type {Number} */\n      const duration = (spring ? /** @type {Spring} */(spring).settlingDuration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n      /** @type {Number} */\n      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n      /** @type {CompositeOperation} */\n      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));\n\n      for (let name in params) {\n        if (!isKey(name)) continue;\n        /** @type {PropertyIndexedKeyframes} */\n        const keyframes = {};\n        /** @type {KeyframeAnimationOptions} */\n        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };\n        const propertyValue = params[name];\n        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n\n        const styleName = individualTransformProperty ? 'transform' : name;\n        if (!inlineStyles[styleName]) {\n          inlineStyles[styleName] = elStyle[styleName];\n        }\n\n        let parsedPropertyValue;\n        if (isObj(propertyValue)) {\n          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);\n          const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;\n          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;\n          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;\n          /** @type {Number} */\n          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).settlingDuration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n          /** @type {Number} */\n          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n          /** @type {CompositeOperation} */\n          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));\n          /** @type {String} */\n          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n          if (!isUnd(from)) {\n            if (!individualTransformProperty) {\n              elStyle[name] = keyframes[name][0];\n            } else {\n              const key = `--${individualTransformProperty}`;\n              elStyle.setProperty(key, keyframes[key][0]);\n            }\n          }\n        } else {\n          parsedPropertyValue = isArr(propertyValue) ?\n                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :\n                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parsedPropertyValue;\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n        }\n      }\n      if (hasIndividualTransforms) {\n        let transforms = emptyString;\n        for (let t in cachedTransforms) {\n          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n        }\n        elStyle.transform = transforms;\n      }\n    });\n\n    if (scroll) {\n      /** @type {ScrollObserver} */(this.autoplay).link(this);\n    }\n  }\n\n  /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */\n\n  /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */\n  forEach(callback) {\n    const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;\n    this.animations.forEach(cb);\n    return this;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  set speed(speed) {\n    this._speed = +speed;\n    this.forEach(anim => anim.playbackRate = speed);\n  }\n\n  get currentTime() {\n    const controlAnimation = this.controlAnimation;\n    const timeScale = globals.timeScale;\n    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n  }\n\n  set currentTime(time) {\n    const t = time * (globals.timeScale === 1 ? 1 : K);\n    this.forEach(anim => {\n      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n      // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n      // This is not needed for persisting animations since they never finish.\n      if (!this.persist && t >= this.duration) anim.play();\n      anim.currentTime = t;\n    });\n  }\n\n  get progress() {\n    return this.currentTime / this.duration;\n  }\n\n  set progress(progress) {\n    this.forEach(anim => anim.currentTime = progress * this.duration || 0);\n  }\n\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // TODO: Store the current time, and seek back to the last position\n    return this.forEach('play');\n  }\n\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    return this.forEach('pause');\n  }\n\n  alternate() {\n    this.reversed = !this.reversed;\n    this.forEach('reverse');\n    if (this.paused) this.forEach('pause');\n    return this;\n  }\n\n  play() {\n    if (this.reversed) this.alternate();\n    return this.resume();\n  }\n\n  reverse() {\n    if (!this.reversed) this.alternate();\n    return this.resume();\n  }\n\n /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */\n  seek(time, muteCallbacks = false) {\n    if (muteCallbacks) this.muteCallbacks = true;\n    if (time < this.duration) this.completed = false;\n    this.currentTime = time;\n    this.muteCallbacks = false;\n    if (this.paused) this.pause();\n    return this;\n  }\n\n  restart() {\n    this.completed = false;\n    return this.seek(0, true).resume();\n  }\n\n  commitStyles() {\n    return this.forEach('commitStyles');\n  }\n\n  complete() {\n    return this.seek(this.duration);\n  }\n\n  cancel() {\n    this.muteCallbacks = true; // This prevents triggering the onComplete callback and resolving the Promise\n    return this.commitStyles().forEach('cancel');\n  }\n\n  revert() {\n    // NOTE: We need a better way to revert the transforms, since right now the entire transform property value is reverted,\n    // This means if you have multiple animations animating different transforms on the same target,\n    // reverting one of them will also override the transform property of the other animations.\n    // A better approach would be to store the original custom property values is they exist instead of the entire transform value,\n    // and update the CSS variables with the orignal value\n    this.cancel().targets.forEach(($el, i) => {\n      const targetStyle = $el.style;\n      const targetInlineStyles = this._inlineStyles[i];\n      for (let name in targetInlineStyles) {\n        const originalInlinedValue = targetInlineStyles[name];\n        if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n          targetStyle.removeProperty(toLowerCase(name));\n        } else {\n          targetStyle[name] = originalInlinedValue;\n        }\n      }\n      // Remove style attribute if empty\n      if ($el.getAttribute('style') === emptyString) $el.removeAttribute('style');\n    });\n    return this;\n  }\n\n  /**\n   * @typedef {this & {then: null}} ResolvedWAAPIAnimation\n   */\n\n  /**\n   * @param  {Callback<ResolvedWAAPIAnimation>} [callback]\n   * @return Promise<this>\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      this.then = null;\n      callback(/** @type {ResolvedWAAPIAnimation} */(this));\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\nconst waapi = {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */\n  animate: (targets, params) => new WAAPIAnimation(targets, params),\n  convertEase: easingToLinear\n};\n\nexport { WAAPIAnimation, waapi };\n"],"mappings":"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"}